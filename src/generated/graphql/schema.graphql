"""The root query type which gives access points into the data universe."""
type Query implements Node {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  """
  id: ID!

  """Fetches an object given its globally unique `ID`."""
  node(
    """The globally unique `ID`."""
    id: ID!
  ): Node

  """Get a single `ProjectProjectLabel`."""
  projectProjectLabel(projectId: UUID!, projectLabelId: UUID!): ProjectProjectLabel

  """Get a single `TaskLabel`."""
  taskLabel(taskId: UUID!, labelId: UUID!): TaskLabel

  """Get a single `TaskLabel`."""
  taskLabelByTaskIdAndLabelId(taskId: UUID!, labelId: UUID!): TaskLabel

  """Get a single `Assignee`."""
  assignee(taskId: UUID!, userId: UUID!): Assignee

  """Get a single `Assignee`."""
  assigneeByTaskIdAndUserId(taskId: UUID!, userId: UUID!): Assignee

  """Get a single `Emoji`."""
  emoji(rowId: UUID!): Emoji

  """Get a single `User`."""
  user(rowId: UUID!): User

  """Get a single `User`."""
  userByEmail(email: String!): User

  """Get a single `User`."""
  userByIdentityProviderId(identityProviderId: UUID!): User

  """Get a single `Post`."""
  post(rowId: UUID!): Post

  """Get a single `ProjectLabel`."""
  projectLabel(rowId: UUID!): ProjectLabel

  """Get a single `Label`."""
  label(rowId: UUID!): Label

  """Get a single `Column`."""
  column(rowId: UUID!): Column

  """Get a single `ProjectColumn`."""
  projectColumn(rowId: UUID!): ProjectColumn

  """Get a single `UserPreference`."""
  userPreference(rowId: UUID!): UserPreference

  """Get a single `UserPreference`."""
  userPreferenceByUserIdAndProjectId(userId: UUID!, projectId: UUID!): UserPreference

  """Get a single `Setting`."""
  setting(rowId: UUID!): Setting

  """Get a single `Setting`."""
  settingByOrganizationId(organizationId: String!): Setting

  """Get a single `Task`."""
  task(rowId: UUID!): Task

  """Get a single `Task`."""
  taskByProjectIdAndNumber(projectId: UUID!, number: Int!): Task

  """Get a single `Project`."""
  project(rowId: UUID!): Project

  """Get a single `Project`."""
  projectBySlugAndOrganizationId(slug: String!, organizationId: String!): Project

  """Reads a single `ProjectProjectLabel` using its globally unique `ID`."""
  projectProjectLabelById(
    """
    The globally unique `ID` to be used in selecting a single `ProjectProjectLabel`.
    """
    id: ID!
  ): ProjectProjectLabel

  """Reads a single `TaskLabel` using its globally unique `ID`."""
  taskLabelById(
    """The globally unique `ID` to be used in selecting a single `TaskLabel`."""
    id: ID!
  ): TaskLabel

  """Reads a single `Assignee` using its globally unique `ID`."""
  assigneeById(
    """The globally unique `ID` to be used in selecting a single `Assignee`."""
    id: ID!
  ): Assignee

  """Reads a single `Emoji` using its globally unique `ID`."""
  emojiById(
    """The globally unique `ID` to be used in selecting a single `Emoji`."""
    id: ID!
  ): Emoji

  """Reads a single `User` using its globally unique `ID`."""
  userById(
    """The globally unique `ID` to be used in selecting a single `User`."""
    id: ID!
  ): User

  """Reads a single `Post` using its globally unique `ID`."""
  postById(
    """The globally unique `ID` to be used in selecting a single `Post`."""
    id: ID!
  ): Post

  """Reads a single `ProjectLabel` using its globally unique `ID`."""
  projectLabelById(
    """
    The globally unique `ID` to be used in selecting a single `ProjectLabel`.
    """
    id: ID!
  ): ProjectLabel

  """Reads a single `Label` using its globally unique `ID`."""
  labelById(
    """The globally unique `ID` to be used in selecting a single `Label`."""
    id: ID!
  ): Label

  """Reads a single `Column` using its globally unique `ID`."""
  columnById(
    """The globally unique `ID` to be used in selecting a single `Column`."""
    id: ID!
  ): Column

  """Reads a single `ProjectColumn` using its globally unique `ID`."""
  projectColumnById(
    """
    The globally unique `ID` to be used in selecting a single `ProjectColumn`.
    """
    id: ID!
  ): ProjectColumn

  """Reads a single `UserPreference` using its globally unique `ID`."""
  userPreferenceById(
    """
    The globally unique `ID` to be used in selecting a single `UserPreference`.
    """
    id: ID!
  ): UserPreference

  """Reads a single `Setting` using its globally unique `ID`."""
  settingById(
    """The globally unique `ID` to be used in selecting a single `Setting`."""
    id: ID!
  ): Setting

  """Reads a single `Task` using its globally unique `ID`."""
  taskById(
    """The globally unique `ID` to be used in selecting a single `Task`."""
    id: ID!
  ): Task

  """Reads a single `Project` using its globally unique `ID`."""
  projectById(
    """The globally unique `ID` to be used in selecting a single `Project`."""
    id: ID!
  ): Project

  """Reads and enables pagination through a set of `ProjectProjectLabel`."""
  projectProjectLabels(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectProjectLabelCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectProjectLabelFilter

    """The method to use when ordering `ProjectProjectLabel`."""
    orderBy: [ProjectProjectLabelOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectProjectLabelConnection

  """Reads and enables pagination through a set of `TaskLabel`."""
  taskLabels(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TaskLabelCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TaskLabelFilter

    """The method to use when ordering `TaskLabel`."""
    orderBy: [TaskLabelOrderBy!] = [PRIMARY_KEY_ASC]
  ): TaskLabelConnection

  """Reads and enables pagination through a set of `Assignee`."""
  assignees(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AssigneeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AssigneeFilter

    """The method to use when ordering `Assignee`."""
    orderBy: [AssigneeOrderBy!] = [PRIMARY_KEY_ASC]
  ): AssigneeConnection

  """Reads and enables pagination through a set of `Emoji`."""
  emojis(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EmojiCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EmojiFilter

    """The method to use when ordering `Emoji`."""
    orderBy: [EmojiOrderBy!] = [PRIMARY_KEY_ASC]
  ): EmojiConnection

  """Reads and enables pagination through a set of `User`."""
  users(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter

    """The method to use when ordering `User`."""
    orderBy: [UserOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserConnection

  """Reads and enables pagination through a set of `Post`."""
  posts(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PostCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PostFilter

    """The method to use when ordering `Post`."""
    orderBy: [PostOrderBy!] = [PRIMARY_KEY_ASC]
  ): PostConnection

  """Reads and enables pagination through a set of `ProjectLabel`."""
  projectLabels(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectLabelCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectLabelFilter

    """The method to use when ordering `ProjectLabel`."""
    orderBy: [ProjectLabelOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectLabelConnection

  """Reads and enables pagination through a set of `Label`."""
  labels(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LabelCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: LabelFilter

    """The method to use when ordering `Label`."""
    orderBy: [LabelOrderBy!] = [PRIMARY_KEY_ASC]
  ): LabelConnection

  """Reads and enables pagination through a set of `Column`."""
  columns(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ColumnCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ColumnFilter

    """The method to use when ordering `Column`."""
    orderBy: [ColumnOrderBy!] = [PRIMARY_KEY_ASC]
  ): ColumnConnection

  """Reads and enables pagination through a set of `ProjectColumn`."""
  projectColumns(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectColumnCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectColumnFilter

    """The method to use when ordering `ProjectColumn`."""
    orderBy: [ProjectColumnOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectColumnConnection

  """Reads and enables pagination through a set of `UserPreference`."""
  userPreferences(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserPreferenceCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserPreferenceFilter

    """The method to use when ordering `UserPreference`."""
    orderBy: [UserPreferenceOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserPreferenceConnection

  """Reads and enables pagination through a set of `Setting`."""
  settings(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SettingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SettingFilter

    """The method to use when ordering `Setting`."""
    orderBy: [SettingOrderBy!] = [PRIMARY_KEY_ASC]
  ): SettingConnection

  """Reads and enables pagination through a set of `Task`."""
  tasks(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TaskCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TaskFilter

    """The method to use when ordering `Task`."""
    orderBy: [TaskOrderBy!] = [PRIMARY_KEY_ASC]
  ): TaskConnection

  """Reads and enables pagination through a set of `Project`."""
  projects(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectFilter

    """The method to use when ordering `Project`."""
    orderBy: [ProjectOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectConnection

  """
  Returns the currently authenticated user (observer).
  Returns null if not authenticated.
  """
  observer: Observer
}

"""An object with a globally unique `ID`."""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
}

type ProjectProjectLabel implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  projectId: UUID!
  projectLabelId: UUID!
  createdAt: Datetime!

  """
  Reads a single `Project` that is related to this `ProjectProjectLabel`.
  """
  project: Project

  """
  Reads a single `ProjectLabel` that is related to this `ProjectProjectLabel`.
  """
  projectLabel: ProjectLabel
}

"""
A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122).
"""
scalar UUID

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) and, if it has a timezone, [RFC
3339](https://datatracker.ietf.org/doc/html/rfc3339) standards. Input values
that do not conform to both ISO 8601 and RFC 3339 may be coerced, which may lead
to unexpected results.
"""
scalar Datetime

type Project implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  name: String!
  description: String
  prefix: String
  organizationId: String!
  createdAt: Datetime!
  updatedAt: Datetime!
  projectColumnId: UUID!
  slug: String!
  columnIndex: Int!
  isPublic: Boolean!
  nextTaskNumber: Int!

  """Reads a single `ProjectColumn` that is related to this `Project`."""
  projectColumn: ProjectColumn

  """Reads and enables pagination through a set of `Column`."""
  columns(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ColumnCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ColumnFilter

    """The method to use when ordering `Column`."""
    orderBy: [ColumnOrderBy!] = [PRIMARY_KEY_ASC]
  ): ColumnConnection!

  """Reads and enables pagination through a set of `Task`."""
  tasks(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TaskCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TaskFilter

    """The method to use when ordering `Task`."""
    orderBy: [TaskOrderBy!] = [PRIMARY_KEY_ASC]
  ): TaskConnection!

  """Reads and enables pagination through a set of `Label`."""
  labels(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LabelCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: LabelFilter

    """The method to use when ordering `Label`."""
    orderBy: [LabelOrderBy!] = [PRIMARY_KEY_ASC]
  ): LabelConnection!

  """Reads and enables pagination through a set of `UserPreference`."""
  userPreferences(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserPreferenceCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserPreferenceFilter

    """The method to use when ordering `UserPreference`."""
    orderBy: [UserPreferenceOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserPreferenceConnection!

  """Reads and enables pagination through a set of `ProjectProjectLabel`."""
  projectProjectLabels(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectProjectLabelCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectProjectLabelFilter

    """The method to use when ordering `ProjectProjectLabel`."""
    orderBy: [ProjectProjectLabelOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectProjectLabelConnection!
}

type ProjectColumn implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  icon: String
  title: String!
  organizationId: String!
  index: Int!
  createdAt: Datetime!
  updatedAt: Datetime!

  """Reads and enables pagination through a set of `Project`."""
  projects(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectFilter

    """The method to use when ordering `Project`."""
    orderBy: [ProjectOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectConnection!
}

"""A connection to a list of `Project` values."""
type ProjectConnection {
  """A list of `Project` objects."""
  nodes: [Project!]!

  """
  A list of edges which contains the `Project` and cursor to aid in pagination.
  """
  edges: [ProjectEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Project` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: ProjectAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Project` for these aggregates."""
    groupBy: [ProjectGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: ProjectHavingInput
  ): [ProjectAggregates!]
}

"""A `Project` edge in the connection."""
type ProjectEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Project` at the end of the edge."""
  node: Project!
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor

  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}

type ProjectAggregates {
  keys: [String]

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: ProjectSumAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: ProjectDistinctCountAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: ProjectMinAggregates

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: ProjectMaxAggregates

  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: ProjectAverageAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: ProjectStddevSampleAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: ProjectStddevPopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: ProjectVarianceSampleAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: ProjectVariancePopulationAggregates
}

type ProjectSumAggregates {
  """Sum of columnIndex across the matching connection"""
  columnIndex: BigInt!

  """Sum of nextTaskNumber across the matching connection"""
  nextTaskNumber: BigInt!
}

"""
A signed eight-byte integer. The upper big integer values are greater than the
max value for a JavaScript number. Therefore all big integers will be output as
strings and not numbers.
"""
scalar BigInt

type ProjectDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of name across the matching connection"""
  name: BigInt

  """Distinct count of description across the matching connection"""
  description: BigInt

  """Distinct count of prefix across the matching connection"""
  prefix: BigInt

  """Distinct count of organizationId across the matching connection"""
  organizationId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt

  """Distinct count of projectColumnId across the matching connection"""
  projectColumnId: BigInt

  """Distinct count of slug across the matching connection"""
  slug: BigInt

  """Distinct count of columnIndex across the matching connection"""
  columnIndex: BigInt

  """Distinct count of isPublic across the matching connection"""
  isPublic: BigInt

  """Distinct count of nextTaskNumber across the matching connection"""
  nextTaskNumber: BigInt
}

type ProjectMinAggregates {
  """Minimum of columnIndex across the matching connection"""
  columnIndex: Int

  """Minimum of nextTaskNumber across the matching connection"""
  nextTaskNumber: Int
}

type ProjectMaxAggregates {
  """Maximum of columnIndex across the matching connection"""
  columnIndex: Int

  """Maximum of nextTaskNumber across the matching connection"""
  nextTaskNumber: Int
}

type ProjectAverageAggregates {
  """Mean average of columnIndex across the matching connection"""
  columnIndex: BigFloat

  """Mean average of nextTaskNumber across the matching connection"""
  nextTaskNumber: BigFloat
}

"""
A floating point number that requires more precision than IEEE 754 binary 64
"""
scalar BigFloat

type ProjectStddevSampleAggregates {
  """
  Sample standard deviation of columnIndex across the matching connection
  """
  columnIndex: BigFloat

  """
  Sample standard deviation of nextTaskNumber across the matching connection
  """
  nextTaskNumber: BigFloat
}

type ProjectStddevPopulationAggregates {
  """
  Population standard deviation of columnIndex across the matching connection
  """
  columnIndex: BigFloat

  """
  Population standard deviation of nextTaskNumber across the matching connection
  """
  nextTaskNumber: BigFloat
}

type ProjectVarianceSampleAggregates {
  """Sample variance of columnIndex across the matching connection"""
  columnIndex: BigFloat

  """Sample variance of nextTaskNumber across the matching connection"""
  nextTaskNumber: BigFloat
}

type ProjectVariancePopulationAggregates {
  """Population variance of columnIndex across the matching connection"""
  columnIndex: BigFloat

  """Population variance of nextTaskNumber across the matching connection"""
  nextTaskNumber: BigFloat
}

"""Grouping methods for `Project` for usage during aggregation."""
enum ProjectGroupBy {
  NAME
  DESCRIPTION
  PREFIX
  ORGANIZATION_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
  PROJECT_COLUMN_ID
  SLUG
  COLUMN_INDEX
  IS_PUBLIC
  NEXT_TASK_NUMBER
}

"""Conditions for `Project` aggregates."""
input ProjectHavingInput {
  AND: [ProjectHavingInput!]
  OR: [ProjectHavingInput!]
  sum: ProjectHavingSumInput
  distinctCount: ProjectHavingDistinctCountInput
  min: ProjectHavingMinInput
  max: ProjectHavingMaxInput
  average: ProjectHavingAverageInput
  stddevSample: ProjectHavingStddevSampleInput
  stddevPopulation: ProjectHavingStddevPopulationInput
  varianceSample: ProjectHavingVarianceSampleInput
  variancePopulation: ProjectHavingVariancePopulationInput
}

input ProjectHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  nextTaskNumber: HavingIntFilter
}

input HavingDatetimeFilter {
  equalTo: Datetime
  notEqualTo: Datetime
  greaterThan: Datetime
  greaterThanOrEqualTo: Datetime
  lessThan: Datetime
  lessThanOrEqualTo: Datetime
}

input HavingIntFilter {
  equalTo: Int
  notEqualTo: Int
  greaterThan: Int
  greaterThanOrEqualTo: Int
  lessThan: Int
  lessThanOrEqualTo: Int
}

input ProjectHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  nextTaskNumber: HavingIntFilter
}

input ProjectHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  nextTaskNumber: HavingIntFilter
}

input ProjectHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  nextTaskNumber: HavingIntFilter
}

input ProjectHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  nextTaskNumber: HavingIntFilter
}

input ProjectHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  nextTaskNumber: HavingIntFilter
}

input ProjectHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  nextTaskNumber: HavingIntFilter
}

input ProjectHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  nextTaskNumber: HavingIntFilter
}

input ProjectHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  nextTaskNumber: HavingIntFilter
}

"""
A condition to be used against `Project` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input ProjectCondition {
  """Checks for equality with the object’s `rowId` field."""
  rowId: UUID

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `prefix` field."""
  prefix: String

  """Checks for equality with the object’s `organizationId` field."""
  organizationId: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `projectColumnId` field."""
  projectColumnId: UUID

  """Checks for equality with the object’s `slug` field."""
  slug: String

  """Checks for equality with the object’s `columnIndex` field."""
  columnIndex: Int

  """Checks for equality with the object’s `isPublic` field."""
  isPublic: Boolean

  """Checks for equality with the object’s `nextTaskNumber` field."""
  nextTaskNumber: Int
}

"""
A filter to be used against `Project` object types. All fields are combined with a logical ‘and.’
"""
input ProjectFilter {
  """Filter by the object’s `rowId` field."""
  rowId: UUIDFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Filter by the object’s `description` field."""
  description: StringFilter

  """Filter by the object’s `prefix` field."""
  prefix: StringFilter

  """Filter by the object’s `organizationId` field."""
  organizationId: StringFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `projectColumnId` field."""
  projectColumnId: UUIDFilter

  """Filter by the object’s `slug` field."""
  slug: StringFilter

  """Filter by the object’s `columnIndex` field."""
  columnIndex: IntFilter

  """Filter by the object’s `isPublic` field."""
  isPublic: BooleanFilter

  """Filter by the object’s `nextTaskNumber` field."""
  nextTaskNumber: IntFilter

  """Filter by the object’s `columns` relation."""
  columns: ProjectToManyColumnFilter

  """Some related `columns` exist."""
  columnsExist: Boolean

  """Filter by the object’s `tasks` relation."""
  tasks: ProjectToManyTaskFilter

  """Some related `tasks` exist."""
  tasksExist: Boolean

  """Filter by the object’s `labels` relation."""
  labels: ProjectToManyLabelFilter

  """Some related `labels` exist."""
  labelsExist: Boolean

  """Filter by the object’s `userPreferences` relation."""
  userPreferences: ProjectToManyUserPreferenceFilter

  """Some related `userPreferences` exist."""
  userPreferencesExist: Boolean

  """Filter by the object’s `projectProjectLabels` relation."""
  projectProjectLabels: ProjectToManyProjectProjectLabelFilter

  """Some related `projectProjectLabels` exist."""
  projectProjectLabelsExist: Boolean

  """Filter by the object’s `projectColumn` relation."""
  projectColumn: ProjectColumnFilter

  """Checks for all expressions in this list."""
  and: [ProjectFilter!]

  """Checks for any expressions in this list."""
  or: [ProjectFilter!]

  """Negates the expression."""
  not: ProjectFilter
}

"""
A filter to be used against UUID fields. All fields are combined with a logical ‘and.’
"""
input UUIDFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: UUID

  """Not equal to the specified value."""
  notEqualTo: UUID

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: UUID

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: UUID

  """Included in the specified list."""
  in: [UUID!]

  """Not included in the specified list."""
  notIn: [UUID!]

  """Less than the specified value."""
  lessThan: UUID

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: UUID

  """Greater than the specified value."""
  greaterThan: UUID

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: UUID
}

"""
A filter to be used against String fields. All fields are combined with a logical ‘and.’
"""
input StringFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: String

  """Not equal to the specified value."""
  notEqualTo: String

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: String

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: String

  """Included in the specified list."""
  in: [String!]

  """Not included in the specified list."""
  notIn: [String!]

  """Less than the specified value."""
  lessThan: String

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: String

  """Greater than the specified value."""
  greaterThan: String

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: String

  """Contains the specified string (case-sensitive)."""
  includes: String

  """Does not contain the specified string (case-sensitive)."""
  notIncludes: String

  """Contains the specified string (case-insensitive)."""
  includesInsensitive: String

  """Does not contain the specified string (case-insensitive)."""
  notIncludesInsensitive: String

  """Starts with the specified string (case-sensitive)."""
  startsWith: String

  """Does not start with the specified string (case-sensitive)."""
  notStartsWith: String

  """Starts with the specified string (case-insensitive)."""
  startsWithInsensitive: String

  """Does not start with the specified string (case-insensitive)."""
  notStartsWithInsensitive: String

  """Ends with the specified string (case-sensitive)."""
  endsWith: String

  """Does not end with the specified string (case-sensitive)."""
  notEndsWith: String

  """Ends with the specified string (case-insensitive)."""
  endsWithInsensitive: String

  """Does not end with the specified string (case-insensitive)."""
  notEndsWithInsensitive: String

  """
  Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  like: String

  """
  Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLike: String

  """
  Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  likeInsensitive: String

  """
  Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLikeInsensitive: String

  """Equal to the specified value (case-insensitive)."""
  equalToInsensitive: String

  """Not equal to the specified value (case-insensitive)."""
  notEqualToInsensitive: String

  """
  Not equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  distinctFromInsensitive: String

  """
  Equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  notDistinctFromInsensitive: String

  """Included in the specified list (case-insensitive)."""
  inInsensitive: [String!]

  """Not included in the specified list (case-insensitive)."""
  notInInsensitive: [String!]

  """Less than the specified value (case-insensitive)."""
  lessThanInsensitive: String

  """Less than or equal to the specified value (case-insensitive)."""
  lessThanOrEqualToInsensitive: String

  """Greater than the specified value (case-insensitive)."""
  greaterThanInsensitive: String

  """Greater than or equal to the specified value (case-insensitive)."""
  greaterThanOrEqualToInsensitive: String
}

"""
A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’
"""
input DatetimeFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Datetime

  """Not equal to the specified value."""
  notEqualTo: Datetime

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Datetime

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Datetime

  """Included in the specified list."""
  in: [Datetime!]

  """Not included in the specified list."""
  notIn: [Datetime!]

  """Less than the specified value."""
  lessThan: Datetime

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Datetime

  """Greater than the specified value."""
  greaterThan: Datetime

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Datetime
}

"""
A filter to be used against Int fields. All fields are combined with a logical ‘and.’
"""
input IntFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Int

  """Not equal to the specified value."""
  notEqualTo: Int

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Int

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Int

  """Included in the specified list."""
  in: [Int!]

  """Not included in the specified list."""
  notIn: [Int!]

  """Less than the specified value."""
  lessThan: Int

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Int

  """Greater than the specified value."""
  greaterThan: Int

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Int
}

"""
A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’
"""
input BooleanFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Boolean

  """Not equal to the specified value."""
  notEqualTo: Boolean

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Boolean

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Boolean

  """Included in the specified list."""
  in: [Boolean!]

  """Not included in the specified list."""
  notIn: [Boolean!]

  """Less than the specified value."""
  lessThan: Boolean

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Boolean

  """Greater than the specified value."""
  greaterThan: Boolean

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Boolean
}

"""
A filter to be used against many `Column` object types. All fields are combined with a logical ‘and.’
"""
input ProjectToManyColumnFilter {
  """
  Every related `Column` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: ColumnFilter

  """
  Some related `Column` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: ColumnFilter

  """
  No related `Column` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: ColumnFilter

  """Aggregates across related `Column` match the filter criteria."""
  aggregates: ColumnAggregatesFilter
}

"""
A filter to be used against `Column` object types. All fields are combined with a logical ‘and.’
"""
input ColumnFilter {
  """Filter by the object’s `rowId` field."""
  rowId: UUIDFilter

  """Filter by the object’s `title` field."""
  title: StringFilter

  """Filter by the object’s `projectId` field."""
  projectId: UUIDFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `index` field."""
  index: IntFilter

  """Filter by the object’s `icon` field."""
  icon: StringFilter

  """Filter by the object’s `tasks` relation."""
  tasks: ColumnToManyTaskFilter

  """Some related `tasks` exist."""
  tasksExist: Boolean

  """Filter by the object’s `project` relation."""
  project: ProjectFilter

  """Checks for all expressions in this list."""
  and: [ColumnFilter!]

  """Checks for any expressions in this list."""
  or: [ColumnFilter!]

  """Negates the expression."""
  not: ColumnFilter
}

"""
A filter to be used against many `Task` object types. All fields are combined with a logical ‘and.’
"""
input ColumnToManyTaskFilter {
  """
  Every related `Task` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TaskFilter

  """
  Some related `Task` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TaskFilter

  """
  No related `Task` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TaskFilter

  """Aggregates across related `Task` match the filter criteria."""
  aggregates: TaskAggregatesFilter
}

"""
A filter to be used against `Task` object types. All fields are combined with a logical ‘and.’
"""
input TaskFilter {
  """Filter by the object’s `rowId` field."""
  rowId: UUIDFilter

  """Filter by the object’s `content` field."""
  content: StringFilter

  """Filter by the object’s `description` field."""
  description: StringFilter

  """Filter by the object’s `priority` field."""
  priority: StringFilter

  """Filter by the object’s `authorId` field."""
  authorId: UUIDFilter

  """Filter by the object’s `columnId` field."""
  columnId: UUIDFilter

  """Filter by the object’s `dueDate` field."""
  dueDate: DatetimeFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `columnIndex` field."""
  columnIndex: IntFilter

  """Filter by the object’s `projectId` field."""
  projectId: UUIDFilter

  """Filter by the object’s `number` field."""
  number: IntFilter

  """Filter by the object’s `assignees` relation."""
  assignees: TaskToManyAssigneeFilter

  """Some related `assignees` exist."""
  assigneesExist: Boolean

  """Filter by the object’s `posts` relation."""
  posts: TaskToManyPostFilter

  """Some related `posts` exist."""
  postsExist: Boolean

  """Filter by the object’s `taskLabels` relation."""
  taskLabels: TaskToManyTaskLabelFilter

  """Some related `taskLabels` exist."""
  taskLabelsExist: Boolean

  """Filter by the object’s `author` relation."""
  author: UserFilter

  """A related `author` exists."""
  authorExists: Boolean

  """Filter by the object’s `column` relation."""
  column: ColumnFilter

  """Filter by the object’s `project` relation."""
  project: ProjectFilter

  """Checks for all expressions in this list."""
  and: [TaskFilter!]

  """Checks for any expressions in this list."""
  or: [TaskFilter!]

  """Negates the expression."""
  not: TaskFilter
}

"""
A filter to be used against many `Assignee` object types. All fields are combined with a logical ‘and.’
"""
input TaskToManyAssigneeFilter {
  """
  Every related `Assignee` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: AssigneeFilter

  """
  Some related `Assignee` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: AssigneeFilter

  """
  No related `Assignee` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: AssigneeFilter

  """Aggregates across related `Assignee` match the filter criteria."""
  aggregates: AssigneeAggregatesFilter
}

"""
A filter to be used against `Assignee` object types. All fields are combined with a logical ‘and.’
"""
input AssigneeFilter {
  """Filter by the object’s `userId` field."""
  userId: UUIDFilter

  """Filter by the object’s `taskId` field."""
  taskId: UUIDFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `deletedAt` field."""
  deletedAt: DatetimeFilter

  """Filter by the object’s `task` relation."""
  task: TaskFilter

  """Filter by the object’s `user` relation."""
  user: UserFilter

  """Checks for all expressions in this list."""
  and: [AssigneeFilter!]

  """Checks for any expressions in this list."""
  or: [AssigneeFilter!]

  """Negates the expression."""
  not: AssigneeFilter
}

"""
A filter to be used against `User` object types. All fields are combined with a logical ‘and.’
"""
input UserFilter {
  """Filter by the object’s `rowId` field."""
  rowId: UUIDFilter

  """Filter by the object’s `identityProviderId` field."""
  identityProviderId: UUIDFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Filter by the object’s `avatarUrl` field."""
  avatarUrl: StringFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `email` field."""
  email: StringFilter

  """Filter by the object’s `assignees` relation."""
  assignees: UserToManyAssigneeFilter

  """Some related `assignees` exist."""
  assigneesExist: Boolean

  """Filter by the object’s `authoredPosts` relation."""
  authoredPosts: UserToManyPostFilter

  """Some related `authoredPosts` exist."""
  authoredPostsExist: Boolean

  """Filter by the object’s `authoredTasks` relation."""
  authoredTasks: UserToManyTaskFilter

  """Some related `authoredTasks` exist."""
  authoredTasksExist: Boolean

  """Filter by the object’s `userPreferences` relation."""
  userPreferences: UserToManyUserPreferenceFilter

  """Some related `userPreferences` exist."""
  userPreferencesExist: Boolean

  """Filter by the object’s `emojis` relation."""
  emojis: UserToManyEmojiFilter

  """Some related `emojis` exist."""
  emojisExist: Boolean

  """Checks for all expressions in this list."""
  and: [UserFilter!]

  """Checks for any expressions in this list."""
  or: [UserFilter!]

  """Negates the expression."""
  not: UserFilter
}

"""
A filter to be used against many `Assignee` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyAssigneeFilter {
  """
  Every related `Assignee` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: AssigneeFilter

  """
  Some related `Assignee` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: AssigneeFilter

  """
  No related `Assignee` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: AssigneeFilter

  """Aggregates across related `Assignee` match the filter criteria."""
  aggregates: AssigneeAggregatesFilter
}

"""A filter to be used against aggregates of `Assignee` object types."""
input AssigneeAggregatesFilter {
  """
  A filter that must pass for the relevant `Assignee` object to be included within the aggregate.
  """
  filter: AssigneeFilter

  """Distinct count aggregate over matching `Assignee` objects."""
  distinctCount: AssigneeDistinctCountAggregateFilter
}

input AssigneeDistinctCountAggregateFilter {
  userId: BigIntFilter
  taskId: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
  deletedAt: BigIntFilter
}

"""
A filter to be used against BigInt fields. All fields are combined with a logical ‘and.’
"""
input BigIntFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: BigInt

  """Not equal to the specified value."""
  notEqualTo: BigInt

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: BigInt

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: BigInt

  """Included in the specified list."""
  in: [BigInt!]

  """Not included in the specified list."""
  notIn: [BigInt!]

  """Less than the specified value."""
  lessThan: BigInt

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: BigInt

  """Greater than the specified value."""
  greaterThan: BigInt

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: BigInt
}

"""
A filter to be used against many `Post` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyPostFilter {
  """
  Every related `Post` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: PostFilter

  """
  Some related `Post` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: PostFilter

  """
  No related `Post` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: PostFilter

  """Aggregates across related `Post` match the filter criteria."""
  aggregates: PostAggregatesFilter
}

"""
A filter to be used against `Post` object types. All fields are combined with a logical ‘and.’
"""
input PostFilter {
  """Filter by the object’s `rowId` field."""
  rowId: UUIDFilter

  """Filter by the object’s `title` field."""
  title: StringFilter

  """Filter by the object’s `description` field."""
  description: StringFilter

  """Filter by the object’s `authorId` field."""
  authorId: UUIDFilter

  """Filter by the object’s `taskId` field."""
  taskId: UUIDFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `emojis` relation."""
  emojis: PostToManyEmojiFilter

  """Some related `emojis` exist."""
  emojisExist: Boolean

  """Filter by the object’s `author` relation."""
  author: UserFilter

  """A related `author` exists."""
  authorExists: Boolean

  """Filter by the object’s `task` relation."""
  task: TaskFilter

  """Checks for all expressions in this list."""
  and: [PostFilter!]

  """Checks for any expressions in this list."""
  or: [PostFilter!]

  """Negates the expression."""
  not: PostFilter
}

"""
A filter to be used against many `Emoji` object types. All fields are combined with a logical ‘and.’
"""
input PostToManyEmojiFilter {
  """
  Every related `Emoji` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: EmojiFilter

  """
  Some related `Emoji` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: EmojiFilter

  """
  No related `Emoji` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: EmojiFilter

  """Aggregates across related `Emoji` match the filter criteria."""
  aggregates: EmojiAggregatesFilter
}

"""
A filter to be used against `Emoji` object types. All fields are combined with a logical ‘and.’
"""
input EmojiFilter {
  """Filter by the object’s `rowId` field."""
  rowId: UUIDFilter

  """Filter by the object’s `emoji` field."""
  emoji: StringFilter

  """Filter by the object’s `postId` field."""
  postId: UUIDFilter

  """Filter by the object’s `userId` field."""
  userId: UUIDFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `post` relation."""
  post: PostFilter

  """Filter by the object’s `user` relation."""
  user: UserFilter

  """Checks for all expressions in this list."""
  and: [EmojiFilter!]

  """Checks for any expressions in this list."""
  or: [EmojiFilter!]

  """Negates the expression."""
  not: EmojiFilter
}

"""A filter to be used against aggregates of `Emoji` object types."""
input EmojiAggregatesFilter {
  """
  A filter that must pass for the relevant `Emoji` object to be included within the aggregate.
  """
  filter: EmojiFilter

  """Distinct count aggregate over matching `Emoji` objects."""
  distinctCount: EmojiDistinctCountAggregateFilter
}

input EmojiDistinctCountAggregateFilter {
  rowId: BigIntFilter
  emoji: BigIntFilter
  postId: BigIntFilter
  userId: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
}

"""A filter to be used against aggregates of `Post` object types."""
input PostAggregatesFilter {
  """
  A filter that must pass for the relevant `Post` object to be included within the aggregate.
  """
  filter: PostFilter

  """Distinct count aggregate over matching `Post` objects."""
  distinctCount: PostDistinctCountAggregateFilter
}

input PostDistinctCountAggregateFilter {
  rowId: BigIntFilter
  title: BigIntFilter
  description: BigIntFilter
  authorId: BigIntFilter
  taskId: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
}

"""
A filter to be used against many `Task` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyTaskFilter {
  """
  Every related `Task` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TaskFilter

  """
  Some related `Task` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TaskFilter

  """
  No related `Task` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TaskFilter

  """Aggregates across related `Task` match the filter criteria."""
  aggregates: TaskAggregatesFilter
}

"""A filter to be used against aggregates of `Task` object types."""
input TaskAggregatesFilter {
  """
  A filter that must pass for the relevant `Task` object to be included within the aggregate.
  """
  filter: TaskFilter

  """Sum aggregate over matching `Task` objects."""
  sum: TaskSumAggregateFilter

  """Distinct count aggregate over matching `Task` objects."""
  distinctCount: TaskDistinctCountAggregateFilter

  """Minimum aggregate over matching `Task` objects."""
  min: TaskMinAggregateFilter

  """Maximum aggregate over matching `Task` objects."""
  max: TaskMaxAggregateFilter

  """Mean average aggregate over matching `Task` objects."""
  average: TaskAverageAggregateFilter

  """Sample standard deviation aggregate over matching `Task` objects."""
  stddevSample: TaskStddevSampleAggregateFilter

  """Population standard deviation aggregate over matching `Task` objects."""
  stddevPopulation: TaskStddevPopulationAggregateFilter

  """Sample variance aggregate over matching `Task` objects."""
  varianceSample: TaskVarianceSampleAggregateFilter

  """Population variance aggregate over matching `Task` objects."""
  variancePopulation: TaskVariancePopulationAggregateFilter
}

input TaskSumAggregateFilter {
  columnIndex: BigIntFilter
  number: BigIntFilter
}

input TaskDistinctCountAggregateFilter {
  rowId: BigIntFilter
  content: BigIntFilter
  description: BigIntFilter
  priority: BigIntFilter
  authorId: BigIntFilter
  columnId: BigIntFilter
  dueDate: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
  columnIndex: BigIntFilter
  projectId: BigIntFilter
  number: BigIntFilter
}

input TaskMinAggregateFilter {
  columnIndex: IntFilter
  number: IntFilter
}

input TaskMaxAggregateFilter {
  columnIndex: IntFilter
  number: IntFilter
}

input TaskAverageAggregateFilter {
  columnIndex: BigFloatFilter
  number: BigFloatFilter
}

"""
A filter to be used against BigFloat fields. All fields are combined with a logical ‘and.’
"""
input BigFloatFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: BigFloat

  """Not equal to the specified value."""
  notEqualTo: BigFloat

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: BigFloat

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: BigFloat

  """Included in the specified list."""
  in: [BigFloat!]

  """Not included in the specified list."""
  notIn: [BigFloat!]

  """Less than the specified value."""
  lessThan: BigFloat

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: BigFloat

  """Greater than the specified value."""
  greaterThan: BigFloat

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: BigFloat
}

input TaskStddevSampleAggregateFilter {
  columnIndex: BigFloatFilter
  number: BigFloatFilter
}

input TaskStddevPopulationAggregateFilter {
  columnIndex: BigFloatFilter
  number: BigFloatFilter
}

input TaskVarianceSampleAggregateFilter {
  columnIndex: BigFloatFilter
  number: BigFloatFilter
}

input TaskVariancePopulationAggregateFilter {
  columnIndex: BigFloatFilter
  number: BigFloatFilter
}

"""
A filter to be used against many `UserPreference` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyUserPreferenceFilter {
  """
  Every related `UserPreference` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: UserPreferenceFilter

  """
  Some related `UserPreference` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: UserPreferenceFilter

  """
  No related `UserPreference` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: UserPreferenceFilter

  """Aggregates across related `UserPreference` match the filter criteria."""
  aggregates: UserPreferenceAggregatesFilter
}

"""
A filter to be used against `UserPreference` object types. All fields are combined with a logical ‘and.’
"""
input UserPreferenceFilter {
  """Filter by the object’s `rowId` field."""
  rowId: UUIDFilter

  """Filter by the object’s `userId` field."""
  userId: UUIDFilter

  """Filter by the object’s `projectId` field."""
  projectId: UUIDFilter

  """Filter by the object’s `hiddenColumnIds` field."""
  hiddenColumnIds: StringListFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `viewMode` field."""
  viewMode: StringFilter

  """Filter by the object’s `color` field."""
  color: StringFilter

  """Filter by the object’s `project` relation."""
  project: ProjectFilter

  """Filter by the object’s `user` relation."""
  user: UserFilter

  """Checks for all expressions in this list."""
  and: [UserPreferenceFilter!]

  """Checks for any expressions in this list."""
  or: [UserPreferenceFilter!]

  """Negates the expression."""
  not: UserPreferenceFilter
}

"""
A filter to be used against String List fields. All fields are combined with a logical ‘and.’
"""
input StringListFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: [String]

  """Not equal to the specified value."""
  notEqualTo: [String]

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: [String]

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: [String]

  """Less than the specified value."""
  lessThan: [String]

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: [String]

  """Greater than the specified value."""
  greaterThan: [String]

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: [String]

  """Contains the specified list of values."""
  contains: [String]

  """Contained by the specified list of values."""
  containedBy: [String]

  """Overlaps the specified list of values."""
  overlaps: [String]

  """Any array item is equal to the specified value."""
  anyEqualTo: String

  """Any array item is not equal to the specified value."""
  anyNotEqualTo: String

  """Any array item is less than the specified value."""
  anyLessThan: String

  """Any array item is less than or equal to the specified value."""
  anyLessThanOrEqualTo: String

  """Any array item is greater than the specified value."""
  anyGreaterThan: String

  """Any array item is greater than or equal to the specified value."""
  anyGreaterThanOrEqualTo: String
}

"""
A filter to be used against aggregates of `UserPreference` object types.
"""
input UserPreferenceAggregatesFilter {
  """
  A filter that must pass for the relevant `UserPreference` object to be included within the aggregate.
  """
  filter: UserPreferenceFilter

  """Distinct count aggregate over matching `UserPreference` objects."""
  distinctCount: UserPreferenceDistinctCountAggregateFilter
}

input UserPreferenceDistinctCountAggregateFilter {
  rowId: BigIntFilter
  userId: BigIntFilter
  projectId: BigIntFilter
  hiddenColumnIds: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
  viewMode: BigIntFilter
  color: BigIntFilter
}

"""
A filter to be used against many `Emoji` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyEmojiFilter {
  """
  Every related `Emoji` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: EmojiFilter

  """
  Some related `Emoji` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: EmojiFilter

  """
  No related `Emoji` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: EmojiFilter

  """Aggregates across related `Emoji` match the filter criteria."""
  aggregates: EmojiAggregatesFilter
}

"""
A filter to be used against many `Post` object types. All fields are combined with a logical ‘and.’
"""
input TaskToManyPostFilter {
  """
  Every related `Post` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: PostFilter

  """
  Some related `Post` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: PostFilter

  """
  No related `Post` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: PostFilter

  """Aggregates across related `Post` match the filter criteria."""
  aggregates: PostAggregatesFilter
}

"""
A filter to be used against many `TaskLabel` object types. All fields are combined with a logical ‘and.’
"""
input TaskToManyTaskLabelFilter {
  """
  Every related `TaskLabel` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TaskLabelFilter

  """
  Some related `TaskLabel` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TaskLabelFilter

  """
  No related `TaskLabel` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TaskLabelFilter

  """Aggregates across related `TaskLabel` match the filter criteria."""
  aggregates: TaskLabelAggregatesFilter
}

"""
A filter to be used against `TaskLabel` object types. All fields are combined with a logical ‘and.’
"""
input TaskLabelFilter {
  """Filter by the object’s `taskId` field."""
  taskId: UUIDFilter

  """Filter by the object’s `labelId` field."""
  labelId: UUIDFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `label` relation."""
  label: LabelFilter

  """Filter by the object’s `task` relation."""
  task: TaskFilter

  """Checks for all expressions in this list."""
  and: [TaskLabelFilter!]

  """Checks for any expressions in this list."""
  or: [TaskLabelFilter!]

  """Negates the expression."""
  not: TaskLabelFilter
}

"""
A filter to be used against `Label` object types. All fields are combined with a logical ‘and.’
"""
input LabelFilter {
  """Filter by the object’s `rowId` field."""
  rowId: UUIDFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Filter by the object’s `color` field."""
  color: StringFilter

  """Filter by the object’s `projectId` field."""
  projectId: UUIDFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `icon` field."""
  icon: StringFilter

  """Filter by the object’s `organizationId` field."""
  organizationId: StringFilter

  """Filter by the object’s `taskLabels` relation."""
  taskLabels: LabelToManyTaskLabelFilter

  """Some related `taskLabels` exist."""
  taskLabelsExist: Boolean

  """Filter by the object’s `project` relation."""
  project: ProjectFilter

  """A related `project` exists."""
  projectExists: Boolean

  """Checks for all expressions in this list."""
  and: [LabelFilter!]

  """Checks for any expressions in this list."""
  or: [LabelFilter!]

  """Negates the expression."""
  not: LabelFilter
}

"""
A filter to be used against many `TaskLabel` object types. All fields are combined with a logical ‘and.’
"""
input LabelToManyTaskLabelFilter {
  """
  Every related `TaskLabel` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TaskLabelFilter

  """
  Some related `TaskLabel` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TaskLabelFilter

  """
  No related `TaskLabel` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TaskLabelFilter

  """Aggregates across related `TaskLabel` match the filter criteria."""
  aggregates: TaskLabelAggregatesFilter
}

"""A filter to be used against aggregates of `TaskLabel` object types."""
input TaskLabelAggregatesFilter {
  """
  A filter that must pass for the relevant `TaskLabel` object to be included within the aggregate.
  """
  filter: TaskLabelFilter

  """Distinct count aggregate over matching `TaskLabel` objects."""
  distinctCount: TaskLabelDistinctCountAggregateFilter
}

input TaskLabelDistinctCountAggregateFilter {
  taskId: BigIntFilter
  labelId: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
}

"""A filter to be used against aggregates of `Column` object types."""
input ColumnAggregatesFilter {
  """
  A filter that must pass for the relevant `Column` object to be included within the aggregate.
  """
  filter: ColumnFilter

  """Sum aggregate over matching `Column` objects."""
  sum: ColumnSumAggregateFilter

  """Distinct count aggregate over matching `Column` objects."""
  distinctCount: ColumnDistinctCountAggregateFilter

  """Minimum aggregate over matching `Column` objects."""
  min: ColumnMinAggregateFilter

  """Maximum aggregate over matching `Column` objects."""
  max: ColumnMaxAggregateFilter

  """Mean average aggregate over matching `Column` objects."""
  average: ColumnAverageAggregateFilter

  """Sample standard deviation aggregate over matching `Column` objects."""
  stddevSample: ColumnStddevSampleAggregateFilter

  """
  Population standard deviation aggregate over matching `Column` objects.
  """
  stddevPopulation: ColumnStddevPopulationAggregateFilter

  """Sample variance aggregate over matching `Column` objects."""
  varianceSample: ColumnVarianceSampleAggregateFilter

  """Population variance aggregate over matching `Column` objects."""
  variancePopulation: ColumnVariancePopulationAggregateFilter
}

input ColumnSumAggregateFilter {
  index: BigIntFilter
}

input ColumnDistinctCountAggregateFilter {
  rowId: BigIntFilter
  title: BigIntFilter
  projectId: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
  index: BigIntFilter
  icon: BigIntFilter
}

input ColumnMinAggregateFilter {
  index: IntFilter
}

input ColumnMaxAggregateFilter {
  index: IntFilter
}

input ColumnAverageAggregateFilter {
  index: BigFloatFilter
}

input ColumnStddevSampleAggregateFilter {
  index: BigFloatFilter
}

input ColumnStddevPopulationAggregateFilter {
  index: BigFloatFilter
}

input ColumnVarianceSampleAggregateFilter {
  index: BigFloatFilter
}

input ColumnVariancePopulationAggregateFilter {
  index: BigFloatFilter
}

"""
A filter to be used against many `Task` object types. All fields are combined with a logical ‘and.’
"""
input ProjectToManyTaskFilter {
  """
  Every related `Task` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TaskFilter

  """
  Some related `Task` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TaskFilter

  """
  No related `Task` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TaskFilter

  """Aggregates across related `Task` match the filter criteria."""
  aggregates: TaskAggregatesFilter
}

"""
A filter to be used against many `Label` object types. All fields are combined with a logical ‘and.’
"""
input ProjectToManyLabelFilter {
  """
  Every related `Label` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: LabelFilter

  """
  Some related `Label` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: LabelFilter

  """
  No related `Label` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: LabelFilter

  """Aggregates across related `Label` match the filter criteria."""
  aggregates: LabelAggregatesFilter
}

"""A filter to be used against aggregates of `Label` object types."""
input LabelAggregatesFilter {
  """
  A filter that must pass for the relevant `Label` object to be included within the aggregate.
  """
  filter: LabelFilter

  """Distinct count aggregate over matching `Label` objects."""
  distinctCount: LabelDistinctCountAggregateFilter
}

input LabelDistinctCountAggregateFilter {
  rowId: BigIntFilter
  name: BigIntFilter
  color: BigIntFilter
  projectId: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
  icon: BigIntFilter
  organizationId: BigIntFilter
}

"""
A filter to be used against many `UserPreference` object types. All fields are combined with a logical ‘and.’
"""
input ProjectToManyUserPreferenceFilter {
  """
  Every related `UserPreference` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: UserPreferenceFilter

  """
  Some related `UserPreference` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: UserPreferenceFilter

  """
  No related `UserPreference` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: UserPreferenceFilter

  """Aggregates across related `UserPreference` match the filter criteria."""
  aggregates: UserPreferenceAggregatesFilter
}

"""
A filter to be used against many `ProjectProjectLabel` object types. All fields are combined with a logical ‘and.’
"""
input ProjectToManyProjectProjectLabelFilter {
  """
  Every related `ProjectProjectLabel` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: ProjectProjectLabelFilter

  """
  Some related `ProjectProjectLabel` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: ProjectProjectLabelFilter

  """
  No related `ProjectProjectLabel` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: ProjectProjectLabelFilter

  """
  Aggregates across related `ProjectProjectLabel` match the filter criteria.
  """
  aggregates: ProjectProjectLabelAggregatesFilter
}

"""
A filter to be used against `ProjectProjectLabel` object types. All fields are combined with a logical ‘and.’
"""
input ProjectProjectLabelFilter {
  """Filter by the object’s `projectId` field."""
  projectId: UUIDFilter

  """Filter by the object’s `projectLabelId` field."""
  projectLabelId: UUIDFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `project` relation."""
  project: ProjectFilter

  """Filter by the object’s `projectLabel` relation."""
  projectLabel: ProjectLabelFilter

  """Checks for all expressions in this list."""
  and: [ProjectProjectLabelFilter!]

  """Checks for any expressions in this list."""
  or: [ProjectProjectLabelFilter!]

  """Negates the expression."""
  not: ProjectProjectLabelFilter
}

"""
A filter to be used against `ProjectLabel` object types. All fields are combined with a logical ‘and.’
"""
input ProjectLabelFilter {
  """Filter by the object’s `rowId` field."""
  rowId: UUIDFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Filter by the object’s `color` field."""
  color: StringFilter

  """Filter by the object’s `icon` field."""
  icon: StringFilter

  """Filter by the object’s `organizationId` field."""
  organizationId: StringFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `projectProjectLabels` relation."""
  projectProjectLabels: ProjectLabelToManyProjectProjectLabelFilter

  """Some related `projectProjectLabels` exist."""
  projectProjectLabelsExist: Boolean

  """Checks for all expressions in this list."""
  and: [ProjectLabelFilter!]

  """Checks for any expressions in this list."""
  or: [ProjectLabelFilter!]

  """Negates the expression."""
  not: ProjectLabelFilter
}

"""
A filter to be used against many `ProjectProjectLabel` object types. All fields are combined with a logical ‘and.’
"""
input ProjectLabelToManyProjectProjectLabelFilter {
  """
  Every related `ProjectProjectLabel` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: ProjectProjectLabelFilter

  """
  Some related `ProjectProjectLabel` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: ProjectProjectLabelFilter

  """
  No related `ProjectProjectLabel` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: ProjectProjectLabelFilter

  """
  Aggregates across related `ProjectProjectLabel` match the filter criteria.
  """
  aggregates: ProjectProjectLabelAggregatesFilter
}

"""
A filter to be used against aggregates of `ProjectProjectLabel` object types.
"""
input ProjectProjectLabelAggregatesFilter {
  """
  A filter that must pass for the relevant `ProjectProjectLabel` object to be included within the aggregate.
  """
  filter: ProjectProjectLabelFilter

  """Distinct count aggregate over matching `ProjectProjectLabel` objects."""
  distinctCount: ProjectProjectLabelDistinctCountAggregateFilter
}

input ProjectProjectLabelDistinctCountAggregateFilter {
  projectId: BigIntFilter
  projectLabelId: BigIntFilter
  createdAt: BigIntFilter
}

"""
A filter to be used against `ProjectColumn` object types. All fields are combined with a logical ‘and.’
"""
input ProjectColumnFilter {
  """Filter by the object’s `rowId` field."""
  rowId: UUIDFilter

  """Filter by the object’s `icon` field."""
  icon: StringFilter

  """Filter by the object’s `title` field."""
  title: StringFilter

  """Filter by the object’s `organizationId` field."""
  organizationId: StringFilter

  """Filter by the object’s `index` field."""
  index: IntFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `projects` relation."""
  projects: ProjectColumnToManyProjectFilter

  """Some related `projects` exist."""
  projectsExist: Boolean

  """Checks for all expressions in this list."""
  and: [ProjectColumnFilter!]

  """Checks for any expressions in this list."""
  or: [ProjectColumnFilter!]

  """Negates the expression."""
  not: ProjectColumnFilter
}

"""
A filter to be used against many `Project` object types. All fields are combined with a logical ‘and.’
"""
input ProjectColumnToManyProjectFilter {
  """
  Every related `Project` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: ProjectFilter

  """
  Some related `Project` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: ProjectFilter

  """
  No related `Project` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: ProjectFilter

  """Aggregates across related `Project` match the filter criteria."""
  aggregates: ProjectAggregatesFilter
}

"""A filter to be used against aggregates of `Project` object types."""
input ProjectAggregatesFilter {
  """
  A filter that must pass for the relevant `Project` object to be included within the aggregate.
  """
  filter: ProjectFilter

  """Sum aggregate over matching `Project` objects."""
  sum: ProjectSumAggregateFilter

  """Distinct count aggregate over matching `Project` objects."""
  distinctCount: ProjectDistinctCountAggregateFilter

  """Minimum aggregate over matching `Project` objects."""
  min: ProjectMinAggregateFilter

  """Maximum aggregate over matching `Project` objects."""
  max: ProjectMaxAggregateFilter

  """Mean average aggregate over matching `Project` objects."""
  average: ProjectAverageAggregateFilter

  """Sample standard deviation aggregate over matching `Project` objects."""
  stddevSample: ProjectStddevSampleAggregateFilter

  """
  Population standard deviation aggregate over matching `Project` objects.
  """
  stddevPopulation: ProjectStddevPopulationAggregateFilter

  """Sample variance aggregate over matching `Project` objects."""
  varianceSample: ProjectVarianceSampleAggregateFilter

  """Population variance aggregate over matching `Project` objects."""
  variancePopulation: ProjectVariancePopulationAggregateFilter
}

input ProjectSumAggregateFilter {
  columnIndex: BigIntFilter
  nextTaskNumber: BigIntFilter
}

input ProjectDistinctCountAggregateFilter {
  rowId: BigIntFilter
  name: BigIntFilter
  description: BigIntFilter
  prefix: BigIntFilter
  organizationId: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
  projectColumnId: BigIntFilter
  slug: BigIntFilter
  columnIndex: BigIntFilter
  isPublic: BigIntFilter
  nextTaskNumber: BigIntFilter
}

input ProjectMinAggregateFilter {
  columnIndex: IntFilter
  nextTaskNumber: IntFilter
}

input ProjectMaxAggregateFilter {
  columnIndex: IntFilter
  nextTaskNumber: IntFilter
}

input ProjectAverageAggregateFilter {
  columnIndex: BigFloatFilter
  nextTaskNumber: BigFloatFilter
}

input ProjectStddevSampleAggregateFilter {
  columnIndex: BigFloatFilter
  nextTaskNumber: BigFloatFilter
}

input ProjectStddevPopulationAggregateFilter {
  columnIndex: BigFloatFilter
  nextTaskNumber: BigFloatFilter
}

input ProjectVarianceSampleAggregateFilter {
  columnIndex: BigFloatFilter
  nextTaskNumber: BigFloatFilter
}

input ProjectVariancePopulationAggregateFilter {
  columnIndex: BigFloatFilter
  nextTaskNumber: BigFloatFilter
}

"""Methods to use when ordering `Project`."""
enum ProjectOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  PREFIX_ASC
  PREFIX_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PROJECT_COLUMN_ID_ASC
  PROJECT_COLUMN_ID_DESC
  SLUG_ASC
  SLUG_DESC
  COLUMN_INDEX_ASC
  COLUMN_INDEX_DESC
  IS_PUBLIC_ASC
  IS_PUBLIC_DESC
  NEXT_TASK_NUMBER_ASC
  NEXT_TASK_NUMBER_DESC
  COLUMNS_COUNT_ASC
  COLUMNS_COUNT_DESC
  COLUMNS_SUM_INDEX_ASC
  COLUMNS_SUM_INDEX_DESC
  COLUMNS_DISTINCT_COUNT_ROW_ID_ASC
  COLUMNS_DISTINCT_COUNT_ROW_ID_DESC
  COLUMNS_DISTINCT_COUNT_TITLE_ASC
  COLUMNS_DISTINCT_COUNT_TITLE_DESC
  COLUMNS_DISTINCT_COUNT_PROJECT_ID_ASC
  COLUMNS_DISTINCT_COUNT_PROJECT_ID_DESC
  COLUMNS_DISTINCT_COUNT_CREATED_AT_ASC
  COLUMNS_DISTINCT_COUNT_CREATED_AT_DESC
  COLUMNS_DISTINCT_COUNT_UPDATED_AT_ASC
  COLUMNS_DISTINCT_COUNT_UPDATED_AT_DESC
  COLUMNS_DISTINCT_COUNT_INDEX_ASC
  COLUMNS_DISTINCT_COUNT_INDEX_DESC
  COLUMNS_DISTINCT_COUNT_ICON_ASC
  COLUMNS_DISTINCT_COUNT_ICON_DESC
  COLUMNS_MIN_INDEX_ASC
  COLUMNS_MIN_INDEX_DESC
  COLUMNS_MAX_INDEX_ASC
  COLUMNS_MAX_INDEX_DESC
  COLUMNS_AVERAGE_INDEX_ASC
  COLUMNS_AVERAGE_INDEX_DESC
  COLUMNS_STDDEV_SAMPLE_INDEX_ASC
  COLUMNS_STDDEV_SAMPLE_INDEX_DESC
  COLUMNS_STDDEV_POPULATION_INDEX_ASC
  COLUMNS_STDDEV_POPULATION_INDEX_DESC
  COLUMNS_VARIANCE_SAMPLE_INDEX_ASC
  COLUMNS_VARIANCE_SAMPLE_INDEX_DESC
  COLUMNS_VARIANCE_POPULATION_INDEX_ASC
  COLUMNS_VARIANCE_POPULATION_INDEX_DESC
  TASKS_COUNT_ASC
  TASKS_COUNT_DESC
  TASKS_SUM_COLUMN_INDEX_ASC
  TASKS_SUM_COLUMN_INDEX_DESC
  TASKS_SUM_NUMBER_ASC
  TASKS_SUM_NUMBER_DESC
  TASKS_DISTINCT_COUNT_ROW_ID_ASC
  TASKS_DISTINCT_COUNT_ROW_ID_DESC
  TASKS_DISTINCT_COUNT_CONTENT_ASC
  TASKS_DISTINCT_COUNT_CONTENT_DESC
  TASKS_DISTINCT_COUNT_DESCRIPTION_ASC
  TASKS_DISTINCT_COUNT_DESCRIPTION_DESC
  TASKS_DISTINCT_COUNT_PRIORITY_ASC
  TASKS_DISTINCT_COUNT_PRIORITY_DESC
  TASKS_DISTINCT_COUNT_AUTHOR_ID_ASC
  TASKS_DISTINCT_COUNT_AUTHOR_ID_DESC
  TASKS_DISTINCT_COUNT_COLUMN_ID_ASC
  TASKS_DISTINCT_COUNT_COLUMN_ID_DESC
  TASKS_DISTINCT_COUNT_DUE_DATE_ASC
  TASKS_DISTINCT_COUNT_DUE_DATE_DESC
  TASKS_DISTINCT_COUNT_CREATED_AT_ASC
  TASKS_DISTINCT_COUNT_CREATED_AT_DESC
  TASKS_DISTINCT_COUNT_UPDATED_AT_ASC
  TASKS_DISTINCT_COUNT_UPDATED_AT_DESC
  TASKS_DISTINCT_COUNT_COLUMN_INDEX_ASC
  TASKS_DISTINCT_COUNT_COLUMN_INDEX_DESC
  TASKS_DISTINCT_COUNT_PROJECT_ID_ASC
  TASKS_DISTINCT_COUNT_PROJECT_ID_DESC
  TASKS_DISTINCT_COUNT_NUMBER_ASC
  TASKS_DISTINCT_COUNT_NUMBER_DESC
  TASKS_MIN_COLUMN_INDEX_ASC
  TASKS_MIN_COLUMN_INDEX_DESC
  TASKS_MIN_NUMBER_ASC
  TASKS_MIN_NUMBER_DESC
  TASKS_MAX_COLUMN_INDEX_ASC
  TASKS_MAX_COLUMN_INDEX_DESC
  TASKS_MAX_NUMBER_ASC
  TASKS_MAX_NUMBER_DESC
  TASKS_AVERAGE_COLUMN_INDEX_ASC
  TASKS_AVERAGE_COLUMN_INDEX_DESC
  TASKS_AVERAGE_NUMBER_ASC
  TASKS_AVERAGE_NUMBER_DESC
  TASKS_STDDEV_SAMPLE_COLUMN_INDEX_ASC
  TASKS_STDDEV_SAMPLE_COLUMN_INDEX_DESC
  TASKS_STDDEV_SAMPLE_NUMBER_ASC
  TASKS_STDDEV_SAMPLE_NUMBER_DESC
  TASKS_STDDEV_POPULATION_COLUMN_INDEX_ASC
  TASKS_STDDEV_POPULATION_COLUMN_INDEX_DESC
  TASKS_STDDEV_POPULATION_NUMBER_ASC
  TASKS_STDDEV_POPULATION_NUMBER_DESC
  TASKS_VARIANCE_SAMPLE_COLUMN_INDEX_ASC
  TASKS_VARIANCE_SAMPLE_COLUMN_INDEX_DESC
  TASKS_VARIANCE_SAMPLE_NUMBER_ASC
  TASKS_VARIANCE_SAMPLE_NUMBER_DESC
  TASKS_VARIANCE_POPULATION_COLUMN_INDEX_ASC
  TASKS_VARIANCE_POPULATION_COLUMN_INDEX_DESC
  TASKS_VARIANCE_POPULATION_NUMBER_ASC
  TASKS_VARIANCE_POPULATION_NUMBER_DESC
  LABELS_COUNT_ASC
  LABELS_COUNT_DESC
  LABELS_DISTINCT_COUNT_ROW_ID_ASC
  LABELS_DISTINCT_COUNT_ROW_ID_DESC
  LABELS_DISTINCT_COUNT_NAME_ASC
  LABELS_DISTINCT_COUNT_NAME_DESC
  LABELS_DISTINCT_COUNT_COLOR_ASC
  LABELS_DISTINCT_COUNT_COLOR_DESC
  LABELS_DISTINCT_COUNT_PROJECT_ID_ASC
  LABELS_DISTINCT_COUNT_PROJECT_ID_DESC
  LABELS_DISTINCT_COUNT_CREATED_AT_ASC
  LABELS_DISTINCT_COUNT_CREATED_AT_DESC
  LABELS_DISTINCT_COUNT_UPDATED_AT_ASC
  LABELS_DISTINCT_COUNT_UPDATED_AT_DESC
  LABELS_DISTINCT_COUNT_ICON_ASC
  LABELS_DISTINCT_COUNT_ICON_DESC
  LABELS_DISTINCT_COUNT_ORGANIZATION_ID_ASC
  LABELS_DISTINCT_COUNT_ORGANIZATION_ID_DESC
  USER_PREFERENCES_COUNT_ASC
  USER_PREFERENCES_COUNT_DESC
  USER_PREFERENCES_DISTINCT_COUNT_ROW_ID_ASC
  USER_PREFERENCES_DISTINCT_COUNT_ROW_ID_DESC
  USER_PREFERENCES_DISTINCT_COUNT_USER_ID_ASC
  USER_PREFERENCES_DISTINCT_COUNT_USER_ID_DESC
  USER_PREFERENCES_DISTINCT_COUNT_PROJECT_ID_ASC
  USER_PREFERENCES_DISTINCT_COUNT_PROJECT_ID_DESC
  USER_PREFERENCES_DISTINCT_COUNT_HIDDEN_COLUMN_IDS_ASC
  USER_PREFERENCES_DISTINCT_COUNT_HIDDEN_COLUMN_IDS_DESC
  USER_PREFERENCES_DISTINCT_COUNT_CREATED_AT_ASC
  USER_PREFERENCES_DISTINCT_COUNT_CREATED_AT_DESC
  USER_PREFERENCES_DISTINCT_COUNT_UPDATED_AT_ASC
  USER_PREFERENCES_DISTINCT_COUNT_UPDATED_AT_DESC
  USER_PREFERENCES_DISTINCT_COUNT_VIEW_MODE_ASC
  USER_PREFERENCES_DISTINCT_COUNT_VIEW_MODE_DESC
  USER_PREFERENCES_DISTINCT_COUNT_COLOR_ASC
  USER_PREFERENCES_DISTINCT_COUNT_COLOR_DESC
  PROJECT_PROJECT_LABELS_COUNT_ASC
  PROJECT_PROJECT_LABELS_COUNT_DESC
  PROJECT_PROJECT_LABELS_DISTINCT_COUNT_PROJECT_ID_ASC
  PROJECT_PROJECT_LABELS_DISTINCT_COUNT_PROJECT_ID_DESC
  PROJECT_PROJECT_LABELS_DISTINCT_COUNT_PROJECT_LABEL_ID_ASC
  PROJECT_PROJECT_LABELS_DISTINCT_COUNT_PROJECT_LABEL_ID_DESC
  PROJECT_PROJECT_LABELS_DISTINCT_COUNT_CREATED_AT_ASC
  PROJECT_PROJECT_LABELS_DISTINCT_COUNT_CREATED_AT_DESC
}

"""A connection to a list of `Column` values."""
type ColumnConnection {
  """A list of `Column` objects."""
  nodes: [Column!]!

  """
  A list of edges which contains the `Column` and cursor to aid in pagination.
  """
  edges: [ColumnEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Column` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: ColumnAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Column` for these aggregates."""
    groupBy: [ColumnGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: ColumnHavingInput
  ): [ColumnAggregates!]
}

type Column implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  title: String!
  projectId: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!
  index: Int!
  icon: String

  """Reads a single `Project` that is related to this `Column`."""
  project: Project

  """Reads and enables pagination through a set of `Task`."""
  tasks(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TaskCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TaskFilter

    """The method to use when ordering `Task`."""
    orderBy: [TaskOrderBy!] = [PRIMARY_KEY_ASC]
  ): TaskConnection!
}

"""A connection to a list of `Task` values."""
type TaskConnection {
  """A list of `Task` objects."""
  nodes: [Task!]!

  """
  A list of edges which contains the `Task` and cursor to aid in pagination.
  """
  edges: [TaskEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Task` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: TaskAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Task` for these aggregates."""
    groupBy: [TaskGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: TaskHavingInput
  ): [TaskAggregates!]
}

type Task implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  content: String!
  description: String!
  priority: String!
  authorId: UUID
  columnId: UUID!
  dueDate: Datetime
  createdAt: Datetime!
  updatedAt: Datetime!
  columnIndex: Int!
  projectId: UUID!
  number: Int

  """Reads a single `User` that is related to this `Task`."""
  author: User

  """Reads a single `Column` that is related to this `Task`."""
  column: Column

  """Reads a single `Project` that is related to this `Task`."""
  project: Project

  """Reads and enables pagination through a set of `Assignee`."""
  assignees(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AssigneeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AssigneeFilter

    """The method to use when ordering `Assignee`."""
    orderBy: [AssigneeOrderBy!] = [PRIMARY_KEY_ASC]
  ): AssigneeConnection!

  """Reads and enables pagination through a set of `Post`."""
  posts(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PostCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PostFilter

    """The method to use when ordering `Post`."""
    orderBy: [PostOrderBy!] = [PRIMARY_KEY_ASC]
  ): PostConnection!

  """Reads and enables pagination through a set of `TaskLabel`."""
  taskLabels(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TaskLabelCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TaskLabelFilter

    """The method to use when ordering `TaskLabel`."""
    orderBy: [TaskLabelOrderBy!] = [PRIMARY_KEY_ASC]
  ): TaskLabelConnection!
}

type User implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  identityProviderId: UUID!
  name: String!
  avatarUrl: String
  createdAt: Datetime!
  updatedAt: Datetime!
  email: String!

  """Reads and enables pagination through a set of `Assignee`."""
  assignees(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AssigneeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AssigneeFilter

    """The method to use when ordering `Assignee`."""
    orderBy: [AssigneeOrderBy!] = [PRIMARY_KEY_ASC]
  ): AssigneeConnection!

  """Reads and enables pagination through a set of `Post`."""
  authoredPosts(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PostCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PostFilter

    """The method to use when ordering `Post`."""
    orderBy: [PostOrderBy!] = [PRIMARY_KEY_ASC]
  ): PostConnection!

  """Reads and enables pagination through a set of `Task`."""
  authoredTasks(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TaskCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TaskFilter

    """The method to use when ordering `Task`."""
    orderBy: [TaskOrderBy!] = [PRIMARY_KEY_ASC]
  ): TaskConnection!

  """Reads and enables pagination through a set of `UserPreference`."""
  userPreferences(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserPreferenceCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserPreferenceFilter

    """The method to use when ordering `UserPreference`."""
    orderBy: [UserPreferenceOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserPreferenceConnection!

  """Reads and enables pagination through a set of `Emoji`."""
  emojis(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EmojiCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EmojiFilter

    """The method to use when ordering `Emoji`."""
    orderBy: [EmojiOrderBy!] = [PRIMARY_KEY_ASC]
  ): EmojiConnection!
}

"""A connection to a list of `Assignee` values."""
type AssigneeConnection {
  """A list of `Assignee` objects."""
  nodes: [Assignee!]!

  """
  A list of edges which contains the `Assignee` and cursor to aid in pagination.
  """
  edges: [AssigneeEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Assignee` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: AssigneeAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Assignee` for these aggregates."""
    groupBy: [AssigneeGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: AssigneeHavingInput
  ): [AssigneeAggregates!]
}

type Assignee implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  userId: UUID!
  taskId: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!
  deletedAt: Datetime

  """Reads a single `Task` that is related to this `Assignee`."""
  task: Task

  """Reads a single `User` that is related to this `Assignee`."""
  user: User
}

"""A `Assignee` edge in the connection."""
type AssigneeEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Assignee` at the end of the edge."""
  node: Assignee!
}

type AssigneeAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: AssigneeDistinctCountAggregates
}

type AssigneeDistinctCountAggregates {
  """Distinct count of userId across the matching connection"""
  userId: BigInt

  """Distinct count of taskId across the matching connection"""
  taskId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt

  """Distinct count of deletedAt across the matching connection"""
  deletedAt: BigInt
}

"""Grouping methods for `Assignee` for usage during aggregation."""
enum AssigneeGroupBy {
  USER_ID
  TASK_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
  DELETED_AT
  DELETED_AT_TRUNCATED_TO_HOUR
  DELETED_AT_TRUNCATED_TO_DAY
}

"""Conditions for `Assignee` aggregates."""
input AssigneeHavingInput {
  AND: [AssigneeHavingInput!]
  OR: [AssigneeHavingInput!]
  sum: AssigneeHavingSumInput
  distinctCount: AssigneeHavingDistinctCountInput
  min: AssigneeHavingMinInput
  max: AssigneeHavingMaxInput
  average: AssigneeHavingAverageInput
  stddevSample: AssigneeHavingStddevSampleInput
  stddevPopulation: AssigneeHavingStddevPopulationInput
  varianceSample: AssigneeHavingVarianceSampleInput
  variancePopulation: AssigneeHavingVariancePopulationInput
}

input AssigneeHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

input AssigneeHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

input AssigneeHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

input AssigneeHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

input AssigneeHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

input AssigneeHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

input AssigneeHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

input AssigneeHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

input AssigneeHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

"""
A condition to be used against `Assignee` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input AssigneeCondition {
  """Checks for equality with the object’s `userId` field."""
  userId: UUID

  """Checks for equality with the object’s `taskId` field."""
  taskId: UUID

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `deletedAt` field."""
  deletedAt: Datetime
}

"""Methods to use when ordering `Assignee`."""
enum AssigneeOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  USER_ID_ASC
  USER_ID_DESC
  TASK_ID_ASC
  TASK_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  DELETED_AT_ASC
  DELETED_AT_DESC
}

"""A connection to a list of `Post` values."""
type PostConnection {
  """A list of `Post` objects."""
  nodes: [Post!]!

  """
  A list of edges which contains the `Post` and cursor to aid in pagination.
  """
  edges: [PostEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Post` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: PostAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Post` for these aggregates."""
    groupBy: [PostGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: PostHavingInput
  ): [PostAggregates!]
}

type Post implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  title: String
  description: String
  authorId: UUID
  taskId: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!

  """Reads a single `User` that is related to this `Post`."""
  author: User

  """Reads a single `Task` that is related to this `Post`."""
  task: Task

  """Reads and enables pagination through a set of `Emoji`."""
  emojis(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EmojiCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EmojiFilter

    """The method to use when ordering `Emoji`."""
    orderBy: [EmojiOrderBy!] = [PRIMARY_KEY_ASC]
  ): EmojiConnection!
}

"""A connection to a list of `Emoji` values."""
type EmojiConnection {
  """A list of `Emoji` objects."""
  nodes: [Emoji!]!

  """
  A list of edges which contains the `Emoji` and cursor to aid in pagination.
  """
  edges: [EmojiEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Emoji` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: EmojiAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Emoji` for these aggregates."""
    groupBy: [EmojiGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: EmojiHavingInput
  ): [EmojiAggregates!]
}

type Emoji implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  emoji: String
  postId: UUID!
  userId: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!

  """Reads a single `Post` that is related to this `Emoji`."""
  post: Post

  """Reads a single `User` that is related to this `Emoji`."""
  user: User
}

"""A `Emoji` edge in the connection."""
type EmojiEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Emoji` at the end of the edge."""
  node: Emoji!
}

type EmojiAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: EmojiDistinctCountAggregates
}

type EmojiDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of emoji across the matching connection"""
  emoji: BigInt

  """Distinct count of postId across the matching connection"""
  postId: BigInt

  """Distinct count of userId across the matching connection"""
  userId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

"""Grouping methods for `Emoji` for usage during aggregation."""
enum EmojiGroupBy {
  EMOJI
  POST_ID
  USER_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for `Emoji` aggregates."""
input EmojiHavingInput {
  AND: [EmojiHavingInput!]
  OR: [EmojiHavingInput!]
  sum: EmojiHavingSumInput
  distinctCount: EmojiHavingDistinctCountInput
  min: EmojiHavingMinInput
  max: EmojiHavingMaxInput
  average: EmojiHavingAverageInput
  stddevSample: EmojiHavingStddevSampleInput
  stddevPopulation: EmojiHavingStddevPopulationInput
  varianceSample: EmojiHavingVarianceSampleInput
  variancePopulation: EmojiHavingVariancePopulationInput
}

input EmojiHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input EmojiHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input EmojiHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input EmojiHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input EmojiHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input EmojiHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input EmojiHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input EmojiHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input EmojiHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""
A condition to be used against `Emoji` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input EmojiCondition {
  """Checks for equality with the object’s `rowId` field."""
  rowId: UUID

  """Checks for equality with the object’s `emoji` field."""
  emoji: String

  """Checks for equality with the object’s `postId` field."""
  postId: UUID

  """Checks for equality with the object’s `userId` field."""
  userId: UUID

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""Methods to use when ordering `Emoji`."""
enum EmojiOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  EMOJI_ASC
  EMOJI_DESC
  POST_ID_ASC
  POST_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

"""A `Post` edge in the connection."""
type PostEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Post` at the end of the edge."""
  node: Post!
}

type PostAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: PostDistinctCountAggregates
}

type PostDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of title across the matching connection"""
  title: BigInt

  """Distinct count of description across the matching connection"""
  description: BigInt

  """Distinct count of authorId across the matching connection"""
  authorId: BigInt

  """Distinct count of taskId across the matching connection"""
  taskId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

"""Grouping methods for `Post` for usage during aggregation."""
enum PostGroupBy {
  TITLE
  DESCRIPTION
  AUTHOR_ID
  TASK_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for `Post` aggregates."""
input PostHavingInput {
  AND: [PostHavingInput!]
  OR: [PostHavingInput!]
  sum: PostHavingSumInput
  distinctCount: PostHavingDistinctCountInput
  min: PostHavingMinInput
  max: PostHavingMaxInput
  average: PostHavingAverageInput
  stddevSample: PostHavingStddevSampleInput
  stddevPopulation: PostHavingStddevPopulationInput
  varianceSample: PostHavingVarianceSampleInput
  variancePopulation: PostHavingVariancePopulationInput
}

input PostHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input PostHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input PostHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input PostHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input PostHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input PostHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input PostHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input PostHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input PostHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""
A condition to be used against `Post` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input PostCondition {
  """Checks for equality with the object’s `rowId` field."""
  rowId: UUID

  """Checks for equality with the object’s `title` field."""
  title: String

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `authorId` field."""
  authorId: UUID

  """Checks for equality with the object’s `taskId` field."""
  taskId: UUID

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""Methods to use when ordering `Post`."""
enum PostOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  TITLE_ASC
  TITLE_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  AUTHOR_ID_ASC
  AUTHOR_ID_DESC
  TASK_ID_ASC
  TASK_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  EMOJIS_COUNT_ASC
  EMOJIS_COUNT_DESC
  EMOJIS_DISTINCT_COUNT_ROW_ID_ASC
  EMOJIS_DISTINCT_COUNT_ROW_ID_DESC
  EMOJIS_DISTINCT_COUNT_EMOJI_ASC
  EMOJIS_DISTINCT_COUNT_EMOJI_DESC
  EMOJIS_DISTINCT_COUNT_POST_ID_ASC
  EMOJIS_DISTINCT_COUNT_POST_ID_DESC
  EMOJIS_DISTINCT_COUNT_USER_ID_ASC
  EMOJIS_DISTINCT_COUNT_USER_ID_DESC
  EMOJIS_DISTINCT_COUNT_CREATED_AT_ASC
  EMOJIS_DISTINCT_COUNT_CREATED_AT_DESC
  EMOJIS_DISTINCT_COUNT_UPDATED_AT_ASC
  EMOJIS_DISTINCT_COUNT_UPDATED_AT_DESC
}

"""
A condition to be used against `Task` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input TaskCondition {
  """Checks for equality with the object’s `rowId` field."""
  rowId: UUID

  """Checks for equality with the object’s `content` field."""
  content: String

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `priority` field."""
  priority: String

  """Checks for equality with the object’s `authorId` field."""
  authorId: UUID

  """Checks for equality with the object’s `columnId` field."""
  columnId: UUID

  """Checks for equality with the object’s `dueDate` field."""
  dueDate: Datetime

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `columnIndex` field."""
  columnIndex: Int

  """Checks for equality with the object’s `projectId` field."""
  projectId: UUID

  """Checks for equality with the object’s `number` field."""
  number: Int
}

"""Methods to use when ordering `Task`."""
enum TaskOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  CONTENT_ASC
  CONTENT_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  PRIORITY_ASC
  PRIORITY_DESC
  AUTHOR_ID_ASC
  AUTHOR_ID_DESC
  COLUMN_ID_ASC
  COLUMN_ID_DESC
  DUE_DATE_ASC
  DUE_DATE_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  COLUMN_INDEX_ASC
  COLUMN_INDEX_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
  NUMBER_ASC
  NUMBER_DESC
  ASSIGNEES_COUNT_ASC
  ASSIGNEES_COUNT_DESC
  ASSIGNEES_DISTINCT_COUNT_USER_ID_ASC
  ASSIGNEES_DISTINCT_COUNT_USER_ID_DESC
  ASSIGNEES_DISTINCT_COUNT_TASK_ID_ASC
  ASSIGNEES_DISTINCT_COUNT_TASK_ID_DESC
  ASSIGNEES_DISTINCT_COUNT_CREATED_AT_ASC
  ASSIGNEES_DISTINCT_COUNT_CREATED_AT_DESC
  ASSIGNEES_DISTINCT_COUNT_UPDATED_AT_ASC
  ASSIGNEES_DISTINCT_COUNT_UPDATED_AT_DESC
  ASSIGNEES_DISTINCT_COUNT_DELETED_AT_ASC
  ASSIGNEES_DISTINCT_COUNT_DELETED_AT_DESC
  POSTS_COUNT_ASC
  POSTS_COUNT_DESC
  POSTS_DISTINCT_COUNT_ROW_ID_ASC
  POSTS_DISTINCT_COUNT_ROW_ID_DESC
  POSTS_DISTINCT_COUNT_TITLE_ASC
  POSTS_DISTINCT_COUNT_TITLE_DESC
  POSTS_DISTINCT_COUNT_DESCRIPTION_ASC
  POSTS_DISTINCT_COUNT_DESCRIPTION_DESC
  POSTS_DISTINCT_COUNT_AUTHOR_ID_ASC
  POSTS_DISTINCT_COUNT_AUTHOR_ID_DESC
  POSTS_DISTINCT_COUNT_TASK_ID_ASC
  POSTS_DISTINCT_COUNT_TASK_ID_DESC
  POSTS_DISTINCT_COUNT_CREATED_AT_ASC
  POSTS_DISTINCT_COUNT_CREATED_AT_DESC
  POSTS_DISTINCT_COUNT_UPDATED_AT_ASC
  POSTS_DISTINCT_COUNT_UPDATED_AT_DESC
  TASK_LABELS_COUNT_ASC
  TASK_LABELS_COUNT_DESC
  TASK_LABELS_DISTINCT_COUNT_TASK_ID_ASC
  TASK_LABELS_DISTINCT_COUNT_TASK_ID_DESC
  TASK_LABELS_DISTINCT_COUNT_LABEL_ID_ASC
  TASK_LABELS_DISTINCT_COUNT_LABEL_ID_DESC
  TASK_LABELS_DISTINCT_COUNT_CREATED_AT_ASC
  TASK_LABELS_DISTINCT_COUNT_CREATED_AT_DESC
  TASK_LABELS_DISTINCT_COUNT_UPDATED_AT_ASC
  TASK_LABELS_DISTINCT_COUNT_UPDATED_AT_DESC
}

"""A connection to a list of `UserPreference` values."""
type UserPreferenceConnection {
  """A list of `UserPreference` objects."""
  nodes: [UserPreference!]!

  """
  A list of edges which contains the `UserPreference` and cursor to aid in pagination.
  """
  edges: [UserPreferenceEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `UserPreference` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: UserPreferenceAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `UserPreference` for these aggregates."""
    groupBy: [UserPreferenceGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: UserPreferenceHavingInput
  ): [UserPreferenceAggregates!]
}

type UserPreference implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  userId: UUID!
  projectId: UUID!
  hiddenColumnIds: [String]!
  createdAt: Datetime!
  updatedAt: Datetime!
  viewMode: String!
  color: String

  """Reads a single `Project` that is related to this `UserPreference`."""
  project: Project

  """Reads a single `User` that is related to this `UserPreference`."""
  user: User
}

"""A `UserPreference` edge in the connection."""
type UserPreferenceEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `UserPreference` at the end of the edge."""
  node: UserPreference!
}

type UserPreferenceAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: UserPreferenceDistinctCountAggregates
}

type UserPreferenceDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of userId across the matching connection"""
  userId: BigInt

  """Distinct count of projectId across the matching connection"""
  projectId: BigInt

  """Distinct count of hiddenColumnIds across the matching connection"""
  hiddenColumnIds: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt

  """Distinct count of viewMode across the matching connection"""
  viewMode: BigInt

  """Distinct count of color across the matching connection"""
  color: BigInt
}

"""Grouping methods for `UserPreference` for usage during aggregation."""
enum UserPreferenceGroupBy {
  USER_ID
  PROJECT_ID
  HIDDEN_COLUMN_IDS
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
  VIEW_MODE
  COLOR
}

"""Conditions for `UserPreference` aggregates."""
input UserPreferenceHavingInput {
  AND: [UserPreferenceHavingInput!]
  OR: [UserPreferenceHavingInput!]
  sum: UserPreferenceHavingSumInput
  distinctCount: UserPreferenceHavingDistinctCountInput
  min: UserPreferenceHavingMinInput
  max: UserPreferenceHavingMaxInput
  average: UserPreferenceHavingAverageInput
  stddevSample: UserPreferenceHavingStddevSampleInput
  stddevPopulation: UserPreferenceHavingStddevPopulationInput
  varianceSample: UserPreferenceHavingVarianceSampleInput
  variancePopulation: UserPreferenceHavingVariancePopulationInput
}

input UserPreferenceHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserPreferenceHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserPreferenceHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserPreferenceHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserPreferenceHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserPreferenceHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserPreferenceHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserPreferenceHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserPreferenceHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""
A condition to be used against `UserPreference` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input UserPreferenceCondition {
  """Checks for equality with the object’s `rowId` field."""
  rowId: UUID

  """Checks for equality with the object’s `userId` field."""
  userId: UUID

  """Checks for equality with the object’s `projectId` field."""
  projectId: UUID

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `viewMode` field."""
  viewMode: String

  """Checks for equality with the object’s `color` field."""
  color: String
}

"""Methods to use when ordering `UserPreference`."""
enum UserPreferenceOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  VIEW_MODE_ASC
  VIEW_MODE_DESC
  COLOR_ASC
  COLOR_DESC
}

"""A connection to a list of `TaskLabel` values."""
type TaskLabelConnection {
  """A list of `TaskLabel` objects."""
  nodes: [TaskLabel!]!

  """
  A list of edges which contains the `TaskLabel` and cursor to aid in pagination.
  """
  edges: [TaskLabelEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `TaskLabel` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: TaskLabelAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `TaskLabel` for these aggregates."""
    groupBy: [TaskLabelGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: TaskLabelHavingInput
  ): [TaskLabelAggregates!]
}

type TaskLabel implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  taskId: UUID!
  labelId: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!

  """Reads a single `Label` that is related to this `TaskLabel`."""
  label: Label

  """Reads a single `Task` that is related to this `TaskLabel`."""
  task: Task
}

type Label implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  name: String!
  color: String!
  projectId: UUID
  createdAt: Datetime!
  updatedAt: Datetime!
  icon: String
  organizationId: String

  """Reads a single `Project` that is related to this `Label`."""
  project: Project

  """Reads and enables pagination through a set of `TaskLabel`."""
  taskLabels(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TaskLabelCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TaskLabelFilter

    """The method to use when ordering `TaskLabel`."""
    orderBy: [TaskLabelOrderBy!] = [PRIMARY_KEY_ASC]
  ): TaskLabelConnection!
}

"""
A condition to be used against `TaskLabel` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input TaskLabelCondition {
  """Checks for equality with the object’s `taskId` field."""
  taskId: UUID

  """Checks for equality with the object’s `labelId` field."""
  labelId: UUID

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""Methods to use when ordering `TaskLabel`."""
enum TaskLabelOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  TASK_ID_ASC
  TASK_ID_DESC
  LABEL_ID_ASC
  LABEL_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

"""A `TaskLabel` edge in the connection."""
type TaskLabelEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `TaskLabel` at the end of the edge."""
  node: TaskLabel!
}

type TaskLabelAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: TaskLabelDistinctCountAggregates
}

type TaskLabelDistinctCountAggregates {
  """Distinct count of taskId across the matching connection"""
  taskId: BigInt

  """Distinct count of labelId across the matching connection"""
  labelId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

"""Grouping methods for `TaskLabel` for usage during aggregation."""
enum TaskLabelGroupBy {
  TASK_ID
  LABEL_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for `TaskLabel` aggregates."""
input TaskLabelHavingInput {
  AND: [TaskLabelHavingInput!]
  OR: [TaskLabelHavingInput!]
  sum: TaskLabelHavingSumInput
  distinctCount: TaskLabelHavingDistinctCountInput
  min: TaskLabelHavingMinInput
  max: TaskLabelHavingMaxInput
  average: TaskLabelHavingAverageInput
  stddevSample: TaskLabelHavingStddevSampleInput
  stddevPopulation: TaskLabelHavingStddevPopulationInput
  varianceSample: TaskLabelHavingVarianceSampleInput
  variancePopulation: TaskLabelHavingVariancePopulationInput
}

input TaskLabelHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TaskLabelHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TaskLabelHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TaskLabelHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TaskLabelHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TaskLabelHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TaskLabelHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TaskLabelHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TaskLabelHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""A `Task` edge in the connection."""
type TaskEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Task` at the end of the edge."""
  node: Task!
}

type TaskAggregates {
  keys: [String]

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: TaskSumAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: TaskDistinctCountAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: TaskMinAggregates

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: TaskMaxAggregates

  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: TaskAverageAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: TaskStddevSampleAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: TaskStddevPopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: TaskVarianceSampleAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: TaskVariancePopulationAggregates
}

type TaskSumAggregates {
  """Sum of columnIndex across the matching connection"""
  columnIndex: BigInt!

  """Sum of number across the matching connection"""
  number: BigInt!
}

type TaskDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of content across the matching connection"""
  content: BigInt

  """Distinct count of description across the matching connection"""
  description: BigInt

  """Distinct count of priority across the matching connection"""
  priority: BigInt

  """Distinct count of authorId across the matching connection"""
  authorId: BigInt

  """Distinct count of columnId across the matching connection"""
  columnId: BigInt

  """Distinct count of dueDate across the matching connection"""
  dueDate: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt

  """Distinct count of columnIndex across the matching connection"""
  columnIndex: BigInt

  """Distinct count of projectId across the matching connection"""
  projectId: BigInt

  """Distinct count of number across the matching connection"""
  number: BigInt
}

type TaskMinAggregates {
  """Minimum of columnIndex across the matching connection"""
  columnIndex: Int

  """Minimum of number across the matching connection"""
  number: Int
}

type TaskMaxAggregates {
  """Maximum of columnIndex across the matching connection"""
  columnIndex: Int

  """Maximum of number across the matching connection"""
  number: Int
}

type TaskAverageAggregates {
  """Mean average of columnIndex across the matching connection"""
  columnIndex: BigFloat

  """Mean average of number across the matching connection"""
  number: BigFloat
}

type TaskStddevSampleAggregates {
  """
  Sample standard deviation of columnIndex across the matching connection
  """
  columnIndex: BigFloat

  """Sample standard deviation of number across the matching connection"""
  number: BigFloat
}

type TaskStddevPopulationAggregates {
  """
  Population standard deviation of columnIndex across the matching connection
  """
  columnIndex: BigFloat

  """Population standard deviation of number across the matching connection"""
  number: BigFloat
}

type TaskVarianceSampleAggregates {
  """Sample variance of columnIndex across the matching connection"""
  columnIndex: BigFloat

  """Sample variance of number across the matching connection"""
  number: BigFloat
}

type TaskVariancePopulationAggregates {
  """Population variance of columnIndex across the matching connection"""
  columnIndex: BigFloat

  """Population variance of number across the matching connection"""
  number: BigFloat
}

"""Grouping methods for `Task` for usage during aggregation."""
enum TaskGroupBy {
  CONTENT
  DESCRIPTION
  PRIORITY
  AUTHOR_ID
  COLUMN_ID
  DUE_DATE
  DUE_DATE_TRUNCATED_TO_HOUR
  DUE_DATE_TRUNCATED_TO_DAY
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
  COLUMN_INDEX
  PROJECT_ID
  NUMBER
}

"""Conditions for `Task` aggregates."""
input TaskHavingInput {
  AND: [TaskHavingInput!]
  OR: [TaskHavingInput!]
  sum: TaskHavingSumInput
  distinctCount: TaskHavingDistinctCountInput
  min: TaskHavingMinInput
  max: TaskHavingMaxInput
  average: TaskHavingAverageInput
  stddevSample: TaskHavingStddevSampleInput
  stddevPopulation: TaskHavingStddevPopulationInput
  varianceSample: TaskHavingVarianceSampleInput
  variancePopulation: TaskHavingVariancePopulationInput
}

input TaskHavingSumInput {
  dueDate: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  number: HavingIntFilter
}

input TaskHavingDistinctCountInput {
  dueDate: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  number: HavingIntFilter
}

input TaskHavingMinInput {
  dueDate: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  number: HavingIntFilter
}

input TaskHavingMaxInput {
  dueDate: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  number: HavingIntFilter
}

input TaskHavingAverageInput {
  dueDate: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  number: HavingIntFilter
}

input TaskHavingStddevSampleInput {
  dueDate: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  number: HavingIntFilter
}

input TaskHavingStddevPopulationInput {
  dueDate: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  number: HavingIntFilter
}

input TaskHavingVarianceSampleInput {
  dueDate: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  number: HavingIntFilter
}

input TaskHavingVariancePopulationInput {
  dueDate: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  number: HavingIntFilter
}

"""A `Column` edge in the connection."""
type ColumnEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Column` at the end of the edge."""
  node: Column!
}

type ColumnAggregates {
  keys: [String]

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: ColumnSumAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: ColumnDistinctCountAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: ColumnMinAggregates

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: ColumnMaxAggregates

  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: ColumnAverageAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: ColumnStddevSampleAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: ColumnStddevPopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: ColumnVarianceSampleAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: ColumnVariancePopulationAggregates
}

type ColumnSumAggregates {
  """Sum of index across the matching connection"""
  index: BigInt!
}

type ColumnDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of title across the matching connection"""
  title: BigInt

  """Distinct count of projectId across the matching connection"""
  projectId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt

  """Distinct count of index across the matching connection"""
  index: BigInt

  """Distinct count of icon across the matching connection"""
  icon: BigInt
}

type ColumnMinAggregates {
  """Minimum of index across the matching connection"""
  index: Int
}

type ColumnMaxAggregates {
  """Maximum of index across the matching connection"""
  index: Int
}

type ColumnAverageAggregates {
  """Mean average of index across the matching connection"""
  index: BigFloat
}

type ColumnStddevSampleAggregates {
  """Sample standard deviation of index across the matching connection"""
  index: BigFloat
}

type ColumnStddevPopulationAggregates {
  """Population standard deviation of index across the matching connection"""
  index: BigFloat
}

type ColumnVarianceSampleAggregates {
  """Sample variance of index across the matching connection"""
  index: BigFloat
}

type ColumnVariancePopulationAggregates {
  """Population variance of index across the matching connection"""
  index: BigFloat
}

"""Grouping methods for `Column` for usage during aggregation."""
enum ColumnGroupBy {
  TITLE
  PROJECT_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
  INDEX
  ICON
}

"""Conditions for `Column` aggregates."""
input ColumnHavingInput {
  AND: [ColumnHavingInput!]
  OR: [ColumnHavingInput!]
  sum: ColumnHavingSumInput
  distinctCount: ColumnHavingDistinctCountInput
  min: ColumnHavingMinInput
  max: ColumnHavingMaxInput
  average: ColumnHavingAverageInput
  stddevSample: ColumnHavingStddevSampleInput
  stddevPopulation: ColumnHavingStddevPopulationInput
  varianceSample: ColumnHavingVarianceSampleInput
  variancePopulation: ColumnHavingVariancePopulationInput
}

input ColumnHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  index: HavingIntFilter
}

input ColumnHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  index: HavingIntFilter
}

input ColumnHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  index: HavingIntFilter
}

input ColumnHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  index: HavingIntFilter
}

input ColumnHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  index: HavingIntFilter
}

input ColumnHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  index: HavingIntFilter
}

input ColumnHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  index: HavingIntFilter
}

input ColumnHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  index: HavingIntFilter
}

input ColumnHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  index: HavingIntFilter
}

"""
A condition to be used against `Column` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input ColumnCondition {
  """Checks for equality with the object’s `rowId` field."""
  rowId: UUID

  """Checks for equality with the object’s `title` field."""
  title: String

  """Checks for equality with the object’s `projectId` field."""
  projectId: UUID

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `index` field."""
  index: Int

  """Checks for equality with the object’s `icon` field."""
  icon: String
}

"""Methods to use when ordering `Column`."""
enum ColumnOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  TITLE_ASC
  TITLE_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  INDEX_ASC
  INDEX_DESC
  ICON_ASC
  ICON_DESC
  TASKS_COUNT_ASC
  TASKS_COUNT_DESC
  TASKS_SUM_COLUMN_INDEX_ASC
  TASKS_SUM_COLUMN_INDEX_DESC
  TASKS_SUM_NUMBER_ASC
  TASKS_SUM_NUMBER_DESC
  TASKS_DISTINCT_COUNT_ROW_ID_ASC
  TASKS_DISTINCT_COUNT_ROW_ID_DESC
  TASKS_DISTINCT_COUNT_CONTENT_ASC
  TASKS_DISTINCT_COUNT_CONTENT_DESC
  TASKS_DISTINCT_COUNT_DESCRIPTION_ASC
  TASKS_DISTINCT_COUNT_DESCRIPTION_DESC
  TASKS_DISTINCT_COUNT_PRIORITY_ASC
  TASKS_DISTINCT_COUNT_PRIORITY_DESC
  TASKS_DISTINCT_COUNT_AUTHOR_ID_ASC
  TASKS_DISTINCT_COUNT_AUTHOR_ID_DESC
  TASKS_DISTINCT_COUNT_COLUMN_ID_ASC
  TASKS_DISTINCT_COUNT_COLUMN_ID_DESC
  TASKS_DISTINCT_COUNT_DUE_DATE_ASC
  TASKS_DISTINCT_COUNT_DUE_DATE_DESC
  TASKS_DISTINCT_COUNT_CREATED_AT_ASC
  TASKS_DISTINCT_COUNT_CREATED_AT_DESC
  TASKS_DISTINCT_COUNT_UPDATED_AT_ASC
  TASKS_DISTINCT_COUNT_UPDATED_AT_DESC
  TASKS_DISTINCT_COUNT_COLUMN_INDEX_ASC
  TASKS_DISTINCT_COUNT_COLUMN_INDEX_DESC
  TASKS_DISTINCT_COUNT_PROJECT_ID_ASC
  TASKS_DISTINCT_COUNT_PROJECT_ID_DESC
  TASKS_DISTINCT_COUNT_NUMBER_ASC
  TASKS_DISTINCT_COUNT_NUMBER_DESC
  TASKS_MIN_COLUMN_INDEX_ASC
  TASKS_MIN_COLUMN_INDEX_DESC
  TASKS_MIN_NUMBER_ASC
  TASKS_MIN_NUMBER_DESC
  TASKS_MAX_COLUMN_INDEX_ASC
  TASKS_MAX_COLUMN_INDEX_DESC
  TASKS_MAX_NUMBER_ASC
  TASKS_MAX_NUMBER_DESC
  TASKS_AVERAGE_COLUMN_INDEX_ASC
  TASKS_AVERAGE_COLUMN_INDEX_DESC
  TASKS_AVERAGE_NUMBER_ASC
  TASKS_AVERAGE_NUMBER_DESC
  TASKS_STDDEV_SAMPLE_COLUMN_INDEX_ASC
  TASKS_STDDEV_SAMPLE_COLUMN_INDEX_DESC
  TASKS_STDDEV_SAMPLE_NUMBER_ASC
  TASKS_STDDEV_SAMPLE_NUMBER_DESC
  TASKS_STDDEV_POPULATION_COLUMN_INDEX_ASC
  TASKS_STDDEV_POPULATION_COLUMN_INDEX_DESC
  TASKS_STDDEV_POPULATION_NUMBER_ASC
  TASKS_STDDEV_POPULATION_NUMBER_DESC
  TASKS_VARIANCE_SAMPLE_COLUMN_INDEX_ASC
  TASKS_VARIANCE_SAMPLE_COLUMN_INDEX_DESC
  TASKS_VARIANCE_SAMPLE_NUMBER_ASC
  TASKS_VARIANCE_SAMPLE_NUMBER_DESC
  TASKS_VARIANCE_POPULATION_COLUMN_INDEX_ASC
  TASKS_VARIANCE_POPULATION_COLUMN_INDEX_DESC
  TASKS_VARIANCE_POPULATION_NUMBER_ASC
  TASKS_VARIANCE_POPULATION_NUMBER_DESC
}

"""A connection to a list of `Label` values."""
type LabelConnection {
  """A list of `Label` objects."""
  nodes: [Label!]!

  """
  A list of edges which contains the `Label` and cursor to aid in pagination.
  """
  edges: [LabelEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Label` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: LabelAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Label` for these aggregates."""
    groupBy: [LabelGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: LabelHavingInput
  ): [LabelAggregates!]
}

"""A `Label` edge in the connection."""
type LabelEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Label` at the end of the edge."""
  node: Label!
}

type LabelAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: LabelDistinctCountAggregates
}

type LabelDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of name across the matching connection"""
  name: BigInt

  """Distinct count of color across the matching connection"""
  color: BigInt

  """Distinct count of projectId across the matching connection"""
  projectId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt

  """Distinct count of icon across the matching connection"""
  icon: BigInt

  """Distinct count of organizationId across the matching connection"""
  organizationId: BigInt
}

"""Grouping methods for `Label` for usage during aggregation."""
enum LabelGroupBy {
  NAME
  COLOR
  PROJECT_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
  ICON
  ORGANIZATION_ID
}

"""Conditions for `Label` aggregates."""
input LabelHavingInput {
  AND: [LabelHavingInput!]
  OR: [LabelHavingInput!]
  sum: LabelHavingSumInput
  distinctCount: LabelHavingDistinctCountInput
  min: LabelHavingMinInput
  max: LabelHavingMaxInput
  average: LabelHavingAverageInput
  stddevSample: LabelHavingStddevSampleInput
  stddevPopulation: LabelHavingStddevPopulationInput
  varianceSample: LabelHavingVarianceSampleInput
  variancePopulation: LabelHavingVariancePopulationInput
}

input LabelHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input LabelHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input LabelHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input LabelHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input LabelHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input LabelHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input LabelHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input LabelHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input LabelHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""
A condition to be used against `Label` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input LabelCondition {
  """Checks for equality with the object’s `rowId` field."""
  rowId: UUID

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `color` field."""
  color: String

  """Checks for equality with the object’s `projectId` field."""
  projectId: UUID

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `icon` field."""
  icon: String

  """Checks for equality with the object’s `organizationId` field."""
  organizationId: String
}

"""Methods to use when ordering `Label`."""
enum LabelOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  NAME_ASC
  NAME_DESC
  COLOR_ASC
  COLOR_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  ICON_ASC
  ICON_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  TASK_LABELS_COUNT_ASC
  TASK_LABELS_COUNT_DESC
  TASK_LABELS_DISTINCT_COUNT_TASK_ID_ASC
  TASK_LABELS_DISTINCT_COUNT_TASK_ID_DESC
  TASK_LABELS_DISTINCT_COUNT_LABEL_ID_ASC
  TASK_LABELS_DISTINCT_COUNT_LABEL_ID_DESC
  TASK_LABELS_DISTINCT_COUNT_CREATED_AT_ASC
  TASK_LABELS_DISTINCT_COUNT_CREATED_AT_DESC
  TASK_LABELS_DISTINCT_COUNT_UPDATED_AT_ASC
  TASK_LABELS_DISTINCT_COUNT_UPDATED_AT_DESC
}

"""A connection to a list of `ProjectProjectLabel` values."""
type ProjectProjectLabelConnection {
  """A list of `ProjectProjectLabel` objects."""
  nodes: [ProjectProjectLabel!]!

  """
  A list of edges which contains the `ProjectProjectLabel` and cursor to aid in pagination.
  """
  edges: [ProjectProjectLabelEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `ProjectProjectLabel` you could get from the connection.
  """
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: ProjectProjectLabelAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """
    The method to use when grouping `ProjectProjectLabel` for these aggregates.
    """
    groupBy: [ProjectProjectLabelGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: ProjectProjectLabelHavingInput
  ): [ProjectProjectLabelAggregates!]
}

"""A `ProjectProjectLabel` edge in the connection."""
type ProjectProjectLabelEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ProjectProjectLabel` at the end of the edge."""
  node: ProjectProjectLabel!
}

type ProjectProjectLabelAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: ProjectProjectLabelDistinctCountAggregates
}

type ProjectProjectLabelDistinctCountAggregates {
  """Distinct count of projectId across the matching connection"""
  projectId: BigInt

  """Distinct count of projectLabelId across the matching connection"""
  projectLabelId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt
}

"""
Grouping methods for `ProjectProjectLabel` for usage during aggregation.
"""
enum ProjectProjectLabelGroupBy {
  PROJECT_ID
  PROJECT_LABEL_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for `ProjectProjectLabel` aggregates."""
input ProjectProjectLabelHavingInput {
  AND: [ProjectProjectLabelHavingInput!]
  OR: [ProjectProjectLabelHavingInput!]
  sum: ProjectProjectLabelHavingSumInput
  distinctCount: ProjectProjectLabelHavingDistinctCountInput
  min: ProjectProjectLabelHavingMinInput
  max: ProjectProjectLabelHavingMaxInput
  average: ProjectProjectLabelHavingAverageInput
  stddevSample: ProjectProjectLabelHavingStddevSampleInput
  stddevPopulation: ProjectProjectLabelHavingStddevPopulationInput
  varianceSample: ProjectProjectLabelHavingVarianceSampleInput
  variancePopulation: ProjectProjectLabelHavingVariancePopulationInput
}

input ProjectProjectLabelHavingSumInput {
  createdAt: HavingDatetimeFilter
}

input ProjectProjectLabelHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
}

input ProjectProjectLabelHavingMinInput {
  createdAt: HavingDatetimeFilter
}

input ProjectProjectLabelHavingMaxInput {
  createdAt: HavingDatetimeFilter
}

input ProjectProjectLabelHavingAverageInput {
  createdAt: HavingDatetimeFilter
}

input ProjectProjectLabelHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
}

input ProjectProjectLabelHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
}

input ProjectProjectLabelHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
}

input ProjectProjectLabelHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
}

"""
A condition to be used against `ProjectProjectLabel` object types. All fields
are tested for equality and combined with a logical ‘and.’
"""
input ProjectProjectLabelCondition {
  """Checks for equality with the object’s `projectId` field."""
  projectId: UUID

  """Checks for equality with the object’s `projectLabelId` field."""
  projectLabelId: UUID

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime
}

"""Methods to use when ordering `ProjectProjectLabel`."""
enum ProjectProjectLabelOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
  PROJECT_LABEL_ID_ASC
  PROJECT_LABEL_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
}

type ProjectLabel implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  name: String!
  color: String!
  icon: String
  organizationId: String!
  createdAt: Datetime!
  updatedAt: Datetime!

  """Reads and enables pagination through a set of `ProjectProjectLabel`."""
  projectProjectLabels(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectProjectLabelCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectProjectLabelFilter

    """The method to use when ordering `ProjectProjectLabel`."""
    orderBy: [ProjectProjectLabelOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectProjectLabelConnection!
}

type Setting implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!
  viewMode: String!
  billingAccountId: String
  organizationId: String!
  subscriptionId: String
  deletedAt: Datetime
  deletionReason: String
}

"""A connection to a list of `User` values."""
type UserConnection {
  """A list of `User` objects."""
  nodes: [User!]!

  """
  A list of edges which contains the `User` and cursor to aid in pagination.
  """
  edges: [UserEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: UserAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `User` for these aggregates."""
    groupBy: [UserGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: UserHavingInput
  ): [UserAggregates!]
}

"""A `User` edge in the connection."""
type UserEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `User` at the end of the edge."""
  node: User!
}

type UserAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: UserDistinctCountAggregates
}

type UserDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of identityProviderId across the matching connection"""
  identityProviderId: BigInt

  """Distinct count of name across the matching connection"""
  name: BigInt

  """Distinct count of avatarUrl across the matching connection"""
  avatarUrl: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt

  """Distinct count of email across the matching connection"""
  email: BigInt
}

"""Grouping methods for `User` for usage during aggregation."""
enum UserGroupBy {
  NAME
  AVATAR_URL
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for `User` aggregates."""
input UserHavingInput {
  AND: [UserHavingInput!]
  OR: [UserHavingInput!]
  sum: UserHavingSumInput
  distinctCount: UserHavingDistinctCountInput
  min: UserHavingMinInput
  max: UserHavingMaxInput
  average: UserHavingAverageInput
  stddevSample: UserHavingStddevSampleInput
  stddevPopulation: UserHavingStddevPopulationInput
  varianceSample: UserHavingVarianceSampleInput
  variancePopulation: UserHavingVariancePopulationInput
}

input UserHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""
A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input UserCondition {
  """Checks for equality with the object’s `rowId` field."""
  rowId: UUID

  """Checks for equality with the object’s `identityProviderId` field."""
  identityProviderId: UUID

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `avatarUrl` field."""
  avatarUrl: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `email` field."""
  email: String
}

"""Methods to use when ordering `User`."""
enum UserOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  IDENTITY_PROVIDER_ID_ASC
  IDENTITY_PROVIDER_ID_DESC
  NAME_ASC
  NAME_DESC
  AVATAR_URL_ASC
  AVATAR_URL_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  EMAIL_ASC
  EMAIL_DESC
  ASSIGNEES_COUNT_ASC
  ASSIGNEES_COUNT_DESC
  ASSIGNEES_DISTINCT_COUNT_USER_ID_ASC
  ASSIGNEES_DISTINCT_COUNT_USER_ID_DESC
  ASSIGNEES_DISTINCT_COUNT_TASK_ID_ASC
  ASSIGNEES_DISTINCT_COUNT_TASK_ID_DESC
  ASSIGNEES_DISTINCT_COUNT_CREATED_AT_ASC
  ASSIGNEES_DISTINCT_COUNT_CREATED_AT_DESC
  ASSIGNEES_DISTINCT_COUNT_UPDATED_AT_ASC
  ASSIGNEES_DISTINCT_COUNT_UPDATED_AT_DESC
  ASSIGNEES_DISTINCT_COUNT_DELETED_AT_ASC
  ASSIGNEES_DISTINCT_COUNT_DELETED_AT_DESC
  AUTHORED_POSTS_COUNT_ASC
  AUTHORED_POSTS_COUNT_DESC
  AUTHORED_POSTS_DISTINCT_COUNT_ROW_ID_ASC
  AUTHORED_POSTS_DISTINCT_COUNT_ROW_ID_DESC
  AUTHORED_POSTS_DISTINCT_COUNT_TITLE_ASC
  AUTHORED_POSTS_DISTINCT_COUNT_TITLE_DESC
  AUTHORED_POSTS_DISTINCT_COUNT_DESCRIPTION_ASC
  AUTHORED_POSTS_DISTINCT_COUNT_DESCRIPTION_DESC
  AUTHORED_POSTS_DISTINCT_COUNT_AUTHOR_ID_ASC
  AUTHORED_POSTS_DISTINCT_COUNT_AUTHOR_ID_DESC
  AUTHORED_POSTS_DISTINCT_COUNT_TASK_ID_ASC
  AUTHORED_POSTS_DISTINCT_COUNT_TASK_ID_DESC
  AUTHORED_POSTS_DISTINCT_COUNT_CREATED_AT_ASC
  AUTHORED_POSTS_DISTINCT_COUNT_CREATED_AT_DESC
  AUTHORED_POSTS_DISTINCT_COUNT_UPDATED_AT_ASC
  AUTHORED_POSTS_DISTINCT_COUNT_UPDATED_AT_DESC
  AUTHORED_TASKS_COUNT_ASC
  AUTHORED_TASKS_COUNT_DESC
  AUTHORED_TASKS_SUM_COLUMN_INDEX_ASC
  AUTHORED_TASKS_SUM_COLUMN_INDEX_DESC
  AUTHORED_TASKS_SUM_NUMBER_ASC
  AUTHORED_TASKS_SUM_NUMBER_DESC
  AUTHORED_TASKS_DISTINCT_COUNT_ROW_ID_ASC
  AUTHORED_TASKS_DISTINCT_COUNT_ROW_ID_DESC
  AUTHORED_TASKS_DISTINCT_COUNT_CONTENT_ASC
  AUTHORED_TASKS_DISTINCT_COUNT_CONTENT_DESC
  AUTHORED_TASKS_DISTINCT_COUNT_DESCRIPTION_ASC
  AUTHORED_TASKS_DISTINCT_COUNT_DESCRIPTION_DESC
  AUTHORED_TASKS_DISTINCT_COUNT_PRIORITY_ASC
  AUTHORED_TASKS_DISTINCT_COUNT_PRIORITY_DESC
  AUTHORED_TASKS_DISTINCT_COUNT_AUTHOR_ID_ASC
  AUTHORED_TASKS_DISTINCT_COUNT_AUTHOR_ID_DESC
  AUTHORED_TASKS_DISTINCT_COUNT_COLUMN_ID_ASC
  AUTHORED_TASKS_DISTINCT_COUNT_COLUMN_ID_DESC
  AUTHORED_TASKS_DISTINCT_COUNT_DUE_DATE_ASC
  AUTHORED_TASKS_DISTINCT_COUNT_DUE_DATE_DESC
  AUTHORED_TASKS_DISTINCT_COUNT_CREATED_AT_ASC
  AUTHORED_TASKS_DISTINCT_COUNT_CREATED_AT_DESC
  AUTHORED_TASKS_DISTINCT_COUNT_UPDATED_AT_ASC
  AUTHORED_TASKS_DISTINCT_COUNT_UPDATED_AT_DESC
  AUTHORED_TASKS_DISTINCT_COUNT_COLUMN_INDEX_ASC
  AUTHORED_TASKS_DISTINCT_COUNT_COLUMN_INDEX_DESC
  AUTHORED_TASKS_DISTINCT_COUNT_PROJECT_ID_ASC
  AUTHORED_TASKS_DISTINCT_COUNT_PROJECT_ID_DESC
  AUTHORED_TASKS_DISTINCT_COUNT_NUMBER_ASC
  AUTHORED_TASKS_DISTINCT_COUNT_NUMBER_DESC
  AUTHORED_TASKS_MIN_COLUMN_INDEX_ASC
  AUTHORED_TASKS_MIN_COLUMN_INDEX_DESC
  AUTHORED_TASKS_MIN_NUMBER_ASC
  AUTHORED_TASKS_MIN_NUMBER_DESC
  AUTHORED_TASKS_MAX_COLUMN_INDEX_ASC
  AUTHORED_TASKS_MAX_COLUMN_INDEX_DESC
  AUTHORED_TASKS_MAX_NUMBER_ASC
  AUTHORED_TASKS_MAX_NUMBER_DESC
  AUTHORED_TASKS_AVERAGE_COLUMN_INDEX_ASC
  AUTHORED_TASKS_AVERAGE_COLUMN_INDEX_DESC
  AUTHORED_TASKS_AVERAGE_NUMBER_ASC
  AUTHORED_TASKS_AVERAGE_NUMBER_DESC
  AUTHORED_TASKS_STDDEV_SAMPLE_COLUMN_INDEX_ASC
  AUTHORED_TASKS_STDDEV_SAMPLE_COLUMN_INDEX_DESC
  AUTHORED_TASKS_STDDEV_SAMPLE_NUMBER_ASC
  AUTHORED_TASKS_STDDEV_SAMPLE_NUMBER_DESC
  AUTHORED_TASKS_STDDEV_POPULATION_COLUMN_INDEX_ASC
  AUTHORED_TASKS_STDDEV_POPULATION_COLUMN_INDEX_DESC
  AUTHORED_TASKS_STDDEV_POPULATION_NUMBER_ASC
  AUTHORED_TASKS_STDDEV_POPULATION_NUMBER_DESC
  AUTHORED_TASKS_VARIANCE_SAMPLE_COLUMN_INDEX_ASC
  AUTHORED_TASKS_VARIANCE_SAMPLE_COLUMN_INDEX_DESC
  AUTHORED_TASKS_VARIANCE_SAMPLE_NUMBER_ASC
  AUTHORED_TASKS_VARIANCE_SAMPLE_NUMBER_DESC
  AUTHORED_TASKS_VARIANCE_POPULATION_COLUMN_INDEX_ASC
  AUTHORED_TASKS_VARIANCE_POPULATION_COLUMN_INDEX_DESC
  AUTHORED_TASKS_VARIANCE_POPULATION_NUMBER_ASC
  AUTHORED_TASKS_VARIANCE_POPULATION_NUMBER_DESC
  USER_PREFERENCES_COUNT_ASC
  USER_PREFERENCES_COUNT_DESC
  USER_PREFERENCES_DISTINCT_COUNT_ROW_ID_ASC
  USER_PREFERENCES_DISTINCT_COUNT_ROW_ID_DESC
  USER_PREFERENCES_DISTINCT_COUNT_USER_ID_ASC
  USER_PREFERENCES_DISTINCT_COUNT_USER_ID_DESC
  USER_PREFERENCES_DISTINCT_COUNT_PROJECT_ID_ASC
  USER_PREFERENCES_DISTINCT_COUNT_PROJECT_ID_DESC
  USER_PREFERENCES_DISTINCT_COUNT_HIDDEN_COLUMN_IDS_ASC
  USER_PREFERENCES_DISTINCT_COUNT_HIDDEN_COLUMN_IDS_DESC
  USER_PREFERENCES_DISTINCT_COUNT_CREATED_AT_ASC
  USER_PREFERENCES_DISTINCT_COUNT_CREATED_AT_DESC
  USER_PREFERENCES_DISTINCT_COUNT_UPDATED_AT_ASC
  USER_PREFERENCES_DISTINCT_COUNT_UPDATED_AT_DESC
  USER_PREFERENCES_DISTINCT_COUNT_VIEW_MODE_ASC
  USER_PREFERENCES_DISTINCT_COUNT_VIEW_MODE_DESC
  USER_PREFERENCES_DISTINCT_COUNT_COLOR_ASC
  USER_PREFERENCES_DISTINCT_COUNT_COLOR_DESC
  EMOJIS_COUNT_ASC
  EMOJIS_COUNT_DESC
  EMOJIS_DISTINCT_COUNT_ROW_ID_ASC
  EMOJIS_DISTINCT_COUNT_ROW_ID_DESC
  EMOJIS_DISTINCT_COUNT_EMOJI_ASC
  EMOJIS_DISTINCT_COUNT_EMOJI_DESC
  EMOJIS_DISTINCT_COUNT_POST_ID_ASC
  EMOJIS_DISTINCT_COUNT_POST_ID_DESC
  EMOJIS_DISTINCT_COUNT_USER_ID_ASC
  EMOJIS_DISTINCT_COUNT_USER_ID_DESC
  EMOJIS_DISTINCT_COUNT_CREATED_AT_ASC
  EMOJIS_DISTINCT_COUNT_CREATED_AT_DESC
  EMOJIS_DISTINCT_COUNT_UPDATED_AT_ASC
  EMOJIS_DISTINCT_COUNT_UPDATED_AT_DESC
}

"""A connection to a list of `ProjectLabel` values."""
type ProjectLabelConnection {
  """A list of `ProjectLabel` objects."""
  nodes: [ProjectLabel!]!

  """
  A list of edges which contains the `ProjectLabel` and cursor to aid in pagination.
  """
  edges: [ProjectLabelEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `ProjectLabel` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: ProjectLabelAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `ProjectLabel` for these aggregates."""
    groupBy: [ProjectLabelGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: ProjectLabelHavingInput
  ): [ProjectLabelAggregates!]
}

"""A `ProjectLabel` edge in the connection."""
type ProjectLabelEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ProjectLabel` at the end of the edge."""
  node: ProjectLabel!
}

type ProjectLabelAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: ProjectLabelDistinctCountAggregates
}

type ProjectLabelDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of name across the matching connection"""
  name: BigInt

  """Distinct count of color across the matching connection"""
  color: BigInt

  """Distinct count of icon across the matching connection"""
  icon: BigInt

  """Distinct count of organizationId across the matching connection"""
  organizationId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

"""Grouping methods for `ProjectLabel` for usage during aggregation."""
enum ProjectLabelGroupBy {
  NAME
  COLOR
  ICON
  ORGANIZATION_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for `ProjectLabel` aggregates."""
input ProjectLabelHavingInput {
  AND: [ProjectLabelHavingInput!]
  OR: [ProjectLabelHavingInput!]
  sum: ProjectLabelHavingSumInput
  distinctCount: ProjectLabelHavingDistinctCountInput
  min: ProjectLabelHavingMinInput
  max: ProjectLabelHavingMaxInput
  average: ProjectLabelHavingAverageInput
  stddevSample: ProjectLabelHavingStddevSampleInput
  stddevPopulation: ProjectLabelHavingStddevPopulationInput
  varianceSample: ProjectLabelHavingVarianceSampleInput
  variancePopulation: ProjectLabelHavingVariancePopulationInput
}

input ProjectLabelHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectLabelHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectLabelHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectLabelHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectLabelHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectLabelHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectLabelHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectLabelHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectLabelHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""
A condition to be used against `ProjectLabel` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input ProjectLabelCondition {
  """Checks for equality with the object’s `rowId` field."""
  rowId: UUID

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `color` field."""
  color: String

  """Checks for equality with the object’s `icon` field."""
  icon: String

  """Checks for equality with the object’s `organizationId` field."""
  organizationId: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""Methods to use when ordering `ProjectLabel`."""
enum ProjectLabelOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  NAME_ASC
  NAME_DESC
  COLOR_ASC
  COLOR_DESC
  ICON_ASC
  ICON_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PROJECT_PROJECT_LABELS_COUNT_ASC
  PROJECT_PROJECT_LABELS_COUNT_DESC
  PROJECT_PROJECT_LABELS_DISTINCT_COUNT_PROJECT_ID_ASC
  PROJECT_PROJECT_LABELS_DISTINCT_COUNT_PROJECT_ID_DESC
  PROJECT_PROJECT_LABELS_DISTINCT_COUNT_PROJECT_LABEL_ID_ASC
  PROJECT_PROJECT_LABELS_DISTINCT_COUNT_PROJECT_LABEL_ID_DESC
  PROJECT_PROJECT_LABELS_DISTINCT_COUNT_CREATED_AT_ASC
  PROJECT_PROJECT_LABELS_DISTINCT_COUNT_CREATED_AT_DESC
}

"""A connection to a list of `ProjectColumn` values."""
type ProjectColumnConnection {
  """A list of `ProjectColumn` objects."""
  nodes: [ProjectColumn!]!

  """
  A list of edges which contains the `ProjectColumn` and cursor to aid in pagination.
  """
  edges: [ProjectColumnEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `ProjectColumn` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: ProjectColumnAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `ProjectColumn` for these aggregates."""
    groupBy: [ProjectColumnGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: ProjectColumnHavingInput
  ): [ProjectColumnAggregates!]
}

"""A `ProjectColumn` edge in the connection."""
type ProjectColumnEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ProjectColumn` at the end of the edge."""
  node: ProjectColumn!
}

type ProjectColumnAggregates {
  keys: [String]

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: ProjectColumnSumAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: ProjectColumnDistinctCountAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: ProjectColumnMinAggregates

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: ProjectColumnMaxAggregates

  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: ProjectColumnAverageAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: ProjectColumnStddevSampleAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: ProjectColumnStddevPopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: ProjectColumnVarianceSampleAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: ProjectColumnVariancePopulationAggregates
}

type ProjectColumnSumAggregates {
  """Sum of index across the matching connection"""
  index: BigInt!
}

type ProjectColumnDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of icon across the matching connection"""
  icon: BigInt

  """Distinct count of title across the matching connection"""
  title: BigInt

  """Distinct count of organizationId across the matching connection"""
  organizationId: BigInt

  """Distinct count of index across the matching connection"""
  index: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

type ProjectColumnMinAggregates {
  """Minimum of index across the matching connection"""
  index: Int
}

type ProjectColumnMaxAggregates {
  """Maximum of index across the matching connection"""
  index: Int
}

type ProjectColumnAverageAggregates {
  """Mean average of index across the matching connection"""
  index: BigFloat
}

type ProjectColumnStddevSampleAggregates {
  """Sample standard deviation of index across the matching connection"""
  index: BigFloat
}

type ProjectColumnStddevPopulationAggregates {
  """Population standard deviation of index across the matching connection"""
  index: BigFloat
}

type ProjectColumnVarianceSampleAggregates {
  """Sample variance of index across the matching connection"""
  index: BigFloat
}

type ProjectColumnVariancePopulationAggregates {
  """Population variance of index across the matching connection"""
  index: BigFloat
}

"""Grouping methods for `ProjectColumn` for usage during aggregation."""
enum ProjectColumnGroupBy {
  ICON
  TITLE
  ORGANIZATION_ID
  INDEX
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for `ProjectColumn` aggregates."""
input ProjectColumnHavingInput {
  AND: [ProjectColumnHavingInput!]
  OR: [ProjectColumnHavingInput!]
  sum: ProjectColumnHavingSumInput
  distinctCount: ProjectColumnHavingDistinctCountInput
  min: ProjectColumnHavingMinInput
  max: ProjectColumnHavingMaxInput
  average: ProjectColumnHavingAverageInput
  stddevSample: ProjectColumnHavingStddevSampleInput
  stddevPopulation: ProjectColumnHavingStddevPopulationInput
  varianceSample: ProjectColumnHavingVarianceSampleInput
  variancePopulation: ProjectColumnHavingVariancePopulationInput
}

input ProjectColumnHavingSumInput {
  index: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectColumnHavingDistinctCountInput {
  index: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectColumnHavingMinInput {
  index: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectColumnHavingMaxInput {
  index: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectColumnHavingAverageInput {
  index: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectColumnHavingStddevSampleInput {
  index: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectColumnHavingStddevPopulationInput {
  index: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectColumnHavingVarianceSampleInput {
  index: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectColumnHavingVariancePopulationInput {
  index: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""
A condition to be used against `ProjectColumn` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input ProjectColumnCondition {
  """Checks for equality with the object’s `rowId` field."""
  rowId: UUID

  """Checks for equality with the object’s `icon` field."""
  icon: String

  """Checks for equality with the object’s `title` field."""
  title: String

  """Checks for equality with the object’s `organizationId` field."""
  organizationId: String

  """Checks for equality with the object’s `index` field."""
  index: Int

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""Methods to use when ordering `ProjectColumn`."""
enum ProjectColumnOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  ICON_ASC
  ICON_DESC
  TITLE_ASC
  TITLE_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  INDEX_ASC
  INDEX_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PROJECTS_COUNT_ASC
  PROJECTS_COUNT_DESC
  PROJECTS_SUM_COLUMN_INDEX_ASC
  PROJECTS_SUM_COLUMN_INDEX_DESC
  PROJECTS_SUM_NEXT_TASK_NUMBER_ASC
  PROJECTS_SUM_NEXT_TASK_NUMBER_DESC
  PROJECTS_DISTINCT_COUNT_ROW_ID_ASC
  PROJECTS_DISTINCT_COUNT_ROW_ID_DESC
  PROJECTS_DISTINCT_COUNT_NAME_ASC
  PROJECTS_DISTINCT_COUNT_NAME_DESC
  PROJECTS_DISTINCT_COUNT_DESCRIPTION_ASC
  PROJECTS_DISTINCT_COUNT_DESCRIPTION_DESC
  PROJECTS_DISTINCT_COUNT_PREFIX_ASC
  PROJECTS_DISTINCT_COUNT_PREFIX_DESC
  PROJECTS_DISTINCT_COUNT_ORGANIZATION_ID_ASC
  PROJECTS_DISTINCT_COUNT_ORGANIZATION_ID_DESC
  PROJECTS_DISTINCT_COUNT_CREATED_AT_ASC
  PROJECTS_DISTINCT_COUNT_CREATED_AT_DESC
  PROJECTS_DISTINCT_COUNT_UPDATED_AT_ASC
  PROJECTS_DISTINCT_COUNT_UPDATED_AT_DESC
  PROJECTS_DISTINCT_COUNT_PROJECT_COLUMN_ID_ASC
  PROJECTS_DISTINCT_COUNT_PROJECT_COLUMN_ID_DESC
  PROJECTS_DISTINCT_COUNT_SLUG_ASC
  PROJECTS_DISTINCT_COUNT_SLUG_DESC
  PROJECTS_DISTINCT_COUNT_COLUMN_INDEX_ASC
  PROJECTS_DISTINCT_COUNT_COLUMN_INDEX_DESC
  PROJECTS_DISTINCT_COUNT_IS_PUBLIC_ASC
  PROJECTS_DISTINCT_COUNT_IS_PUBLIC_DESC
  PROJECTS_DISTINCT_COUNT_NEXT_TASK_NUMBER_ASC
  PROJECTS_DISTINCT_COUNT_NEXT_TASK_NUMBER_DESC
  PROJECTS_MIN_COLUMN_INDEX_ASC
  PROJECTS_MIN_COLUMN_INDEX_DESC
  PROJECTS_MIN_NEXT_TASK_NUMBER_ASC
  PROJECTS_MIN_NEXT_TASK_NUMBER_DESC
  PROJECTS_MAX_COLUMN_INDEX_ASC
  PROJECTS_MAX_COLUMN_INDEX_DESC
  PROJECTS_MAX_NEXT_TASK_NUMBER_ASC
  PROJECTS_MAX_NEXT_TASK_NUMBER_DESC
  PROJECTS_AVERAGE_COLUMN_INDEX_ASC
  PROJECTS_AVERAGE_COLUMN_INDEX_DESC
  PROJECTS_AVERAGE_NEXT_TASK_NUMBER_ASC
  PROJECTS_AVERAGE_NEXT_TASK_NUMBER_DESC
  PROJECTS_STDDEV_SAMPLE_COLUMN_INDEX_ASC
  PROJECTS_STDDEV_SAMPLE_COLUMN_INDEX_DESC
  PROJECTS_STDDEV_SAMPLE_NEXT_TASK_NUMBER_ASC
  PROJECTS_STDDEV_SAMPLE_NEXT_TASK_NUMBER_DESC
  PROJECTS_STDDEV_POPULATION_COLUMN_INDEX_ASC
  PROJECTS_STDDEV_POPULATION_COLUMN_INDEX_DESC
  PROJECTS_STDDEV_POPULATION_NEXT_TASK_NUMBER_ASC
  PROJECTS_STDDEV_POPULATION_NEXT_TASK_NUMBER_DESC
  PROJECTS_VARIANCE_SAMPLE_COLUMN_INDEX_ASC
  PROJECTS_VARIANCE_SAMPLE_COLUMN_INDEX_DESC
  PROJECTS_VARIANCE_SAMPLE_NEXT_TASK_NUMBER_ASC
  PROJECTS_VARIANCE_SAMPLE_NEXT_TASK_NUMBER_DESC
  PROJECTS_VARIANCE_POPULATION_COLUMN_INDEX_ASC
  PROJECTS_VARIANCE_POPULATION_COLUMN_INDEX_DESC
  PROJECTS_VARIANCE_POPULATION_NEXT_TASK_NUMBER_ASC
  PROJECTS_VARIANCE_POPULATION_NEXT_TASK_NUMBER_DESC
}

"""A connection to a list of `Setting` values."""
type SettingConnection {
  """A list of `Setting` objects."""
  nodes: [Setting!]!

  """
  A list of edges which contains the `Setting` and cursor to aid in pagination.
  """
  edges: [SettingEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Setting` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: SettingAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Setting` for these aggregates."""
    groupBy: [SettingGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: SettingHavingInput
  ): [SettingAggregates!]
}

"""A `Setting` edge in the connection."""
type SettingEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Setting` at the end of the edge."""
  node: Setting!
}

type SettingAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: SettingDistinctCountAggregates
}

type SettingDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt

  """Distinct count of viewMode across the matching connection"""
  viewMode: BigInt

  """Distinct count of billingAccountId across the matching connection"""
  billingAccountId: BigInt

  """Distinct count of organizationId across the matching connection"""
  organizationId: BigInt

  """Distinct count of subscriptionId across the matching connection"""
  subscriptionId: BigInt

  """Distinct count of deletedAt across the matching connection"""
  deletedAt: BigInt

  """Distinct count of deletionReason across the matching connection"""
  deletionReason: BigInt
}

"""Grouping methods for `Setting` for usage during aggregation."""
enum SettingGroupBy {
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
  VIEW_MODE
  BILLING_ACCOUNT_ID
  SUBSCRIPTION_ID
  DELETED_AT
  DELETED_AT_TRUNCATED_TO_HOUR
  DELETED_AT_TRUNCATED_TO_DAY
  DELETION_REASON
}

"""Conditions for `Setting` aggregates."""
input SettingHavingInput {
  AND: [SettingHavingInput!]
  OR: [SettingHavingInput!]
  sum: SettingHavingSumInput
  distinctCount: SettingHavingDistinctCountInput
  min: SettingHavingMinInput
  max: SettingHavingMaxInput
  average: SettingHavingAverageInput
  stddevSample: SettingHavingStddevSampleInput
  stddevPopulation: SettingHavingStddevPopulationInput
  varianceSample: SettingHavingVarianceSampleInput
  variancePopulation: SettingHavingVariancePopulationInput
}

input SettingHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

input SettingHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

input SettingHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

input SettingHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

input SettingHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

input SettingHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

input SettingHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

input SettingHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

input SettingHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

"""
A condition to be used against `Setting` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input SettingCondition {
  """Checks for equality with the object’s `rowId` field."""
  rowId: UUID

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `viewMode` field."""
  viewMode: String

  """Checks for equality with the object’s `billingAccountId` field."""
  billingAccountId: String

  """Checks for equality with the object’s `organizationId` field."""
  organizationId: String

  """Checks for equality with the object’s `subscriptionId` field."""
  subscriptionId: String

  """Checks for equality with the object’s `deletedAt` field."""
  deletedAt: Datetime

  """Checks for equality with the object’s `deletionReason` field."""
  deletionReason: String
}

"""
A filter to be used against `Setting` object types. All fields are combined with a logical ‘and.’
"""
input SettingFilter {
  """Filter by the object’s `rowId` field."""
  rowId: UUIDFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `viewMode` field."""
  viewMode: StringFilter

  """Filter by the object’s `billingAccountId` field."""
  billingAccountId: StringFilter

  """Filter by the object’s `organizationId` field."""
  organizationId: StringFilter

  """Filter by the object’s `subscriptionId` field."""
  subscriptionId: StringFilter

  """Filter by the object’s `deletedAt` field."""
  deletedAt: DatetimeFilter

  """Filter by the object’s `deletionReason` field."""
  deletionReason: StringFilter

  """Checks for all expressions in this list."""
  and: [SettingFilter!]

  """Checks for any expressions in this list."""
  or: [SettingFilter!]

  """Negates the expression."""
  not: SettingFilter
}

"""Methods to use when ordering `Setting`."""
enum SettingOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  VIEW_MODE_ASC
  VIEW_MODE_DESC
  BILLING_ACCOUNT_ID_ASC
  BILLING_ACCOUNT_ID_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  SUBSCRIPTION_ID_ASC
  SUBSCRIPTION_ID_DESC
  DELETED_AT_ASC
  DELETED_AT_DESC
  DELETION_REASON_ASC
  DELETION_REASON_DESC
}

"""
The root mutation type which contains root level fields which mutate data.
"""
type Mutation {
  """Creates a single `ProjectProjectLabel`."""
  createProjectProjectLabel(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateProjectProjectLabelInput!
  ): CreateProjectProjectLabelPayload

  """Creates a single `TaskLabel`."""
  createTaskLabel(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTaskLabelInput!
  ): CreateTaskLabelPayload

  """Creates a single `Assignee`."""
  createAssignee(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateAssigneeInput!
  ): CreateAssigneePayload

  """Creates a single `Emoji`."""
  createEmoji(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateEmojiInput!
  ): CreateEmojiPayload

  """Creates a single `User`."""
  createUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateUserInput!
  ): CreateUserPayload

  """Creates a single `Post`."""
  createPost(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePostInput!
  ): CreatePostPayload

  """Creates a single `ProjectLabel`."""
  createProjectLabel(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateProjectLabelInput!
  ): CreateProjectLabelPayload

  """Creates a single `Label`."""
  createLabel(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateLabelInput!
  ): CreateLabelPayload

  """Creates a single `Column`."""
  createColumn(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateColumnInput!
  ): CreateColumnPayload

  """Creates a single `ProjectColumn`."""
  createProjectColumn(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateProjectColumnInput!
  ): CreateProjectColumnPayload

  """Creates a single `UserPreference`."""
  createUserPreference(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateUserPreferenceInput!
  ): CreateUserPreferencePayload

  """Creates a single `Setting`."""
  createSetting(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateSettingInput!
  ): CreateSettingPayload

  """Creates a single `Task`."""
  createTask(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTaskInput!
  ): CreateTaskPayload

  """Creates a single `Project`."""
  createProject(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateProjectInput!
  ): CreateProjectPayload

  """
  Updates a single `ProjectProjectLabel` using its globally unique id and a patch.
  """
  updateProjectProjectLabelById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProjectProjectLabelByIdInput!
  ): UpdateProjectProjectLabelPayload

  """Updates a single `ProjectProjectLabel` using a unique key and a patch."""
  updateProjectProjectLabel(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProjectProjectLabelInput!
  ): UpdateProjectProjectLabelPayload

  """Updates a single `TaskLabel` using its globally unique id and a patch."""
  updateTaskLabelById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTaskLabelByIdInput!
  ): UpdateTaskLabelPayload

  """Updates a single `TaskLabel` using a unique key and a patch."""
  updateTaskLabel(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTaskLabelInput!
  ): UpdateTaskLabelPayload

  """Updates a single `Assignee` using its globally unique id and a patch."""
  updateAssigneeById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAssigneeByIdInput!
  ): UpdateAssigneePayload

  """Updates a single `Assignee` using a unique key and a patch."""
  updateAssignee(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAssigneeInput!
  ): UpdateAssigneePayload

  """Updates a single `Emoji` using its globally unique id and a patch."""
  updateEmojiById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateEmojiByIdInput!
  ): UpdateEmojiPayload

  """Updates a single `Emoji` using a unique key and a patch."""
  updateEmoji(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateEmojiInput!
  ): UpdateEmojiPayload

  """Updates a single `User` using its globally unique id and a patch."""
  updateUserById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserByIdInput!
  ): UpdateUserPayload

  """Updates a single `User` using a unique key and a patch."""
  updateUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserInput!
  ): UpdateUserPayload

  """Updates a single `Post` using its globally unique id and a patch."""
  updatePostById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePostByIdInput!
  ): UpdatePostPayload

  """Updates a single `Post` using a unique key and a patch."""
  updatePost(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePostInput!
  ): UpdatePostPayload

  """
  Updates a single `ProjectLabel` using its globally unique id and a patch.
  """
  updateProjectLabelById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProjectLabelByIdInput!
  ): UpdateProjectLabelPayload

  """Updates a single `ProjectLabel` using a unique key and a patch."""
  updateProjectLabel(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProjectLabelInput!
  ): UpdateProjectLabelPayload

  """Updates a single `Label` using its globally unique id and a patch."""
  updateLabelById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLabelByIdInput!
  ): UpdateLabelPayload

  """Updates a single `Label` using a unique key and a patch."""
  updateLabel(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLabelInput!
  ): UpdateLabelPayload

  """Updates a single `Column` using its globally unique id and a patch."""
  updateColumnById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateColumnByIdInput!
  ): UpdateColumnPayload

  """Updates a single `Column` using a unique key and a patch."""
  updateColumn(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateColumnInput!
  ): UpdateColumnPayload

  """
  Updates a single `ProjectColumn` using its globally unique id and a patch.
  """
  updateProjectColumnById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProjectColumnByIdInput!
  ): UpdateProjectColumnPayload

  """Updates a single `ProjectColumn` using a unique key and a patch."""
  updateProjectColumn(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProjectColumnInput!
  ): UpdateProjectColumnPayload

  """
  Updates a single `UserPreference` using its globally unique id and a patch.
  """
  updateUserPreferenceById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserPreferenceByIdInput!
  ): UpdateUserPreferencePayload

  """Updates a single `UserPreference` using a unique key and a patch."""
  updateUserPreference(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserPreferenceInput!
  ): UpdateUserPreferencePayload

  """Updates a single `Setting` using its globally unique id and a patch."""
  updateSettingById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSettingByIdInput!
  ): UpdateSettingPayload

  """Updates a single `Setting` using a unique key and a patch."""
  updateSetting(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSettingInput!
  ): UpdateSettingPayload

  """Updates a single `Task` using its globally unique id and a patch."""
  updateTaskById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTaskByIdInput!
  ): UpdateTaskPayload

  """Updates a single `Task` using a unique key and a patch."""
  updateTask(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTaskInput!
  ): UpdateTaskPayload

  """Updates a single `Project` using its globally unique id and a patch."""
  updateProjectById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProjectByIdInput!
  ): UpdateProjectPayload

  """Updates a single `Project` using a unique key and a patch."""
  updateProject(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProjectInput!
  ): UpdateProjectPayload

  """Deletes a single `ProjectProjectLabel` using its globally unique id."""
  deleteProjectProjectLabelById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProjectProjectLabelByIdInput!
  ): DeleteProjectProjectLabelPayload

  """Deletes a single `ProjectProjectLabel` using a unique key."""
  deleteProjectProjectLabel(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProjectProjectLabelInput!
  ): DeleteProjectProjectLabelPayload

  """Deletes a single `TaskLabel` using its globally unique id."""
  deleteTaskLabelById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTaskLabelByIdInput!
  ): DeleteTaskLabelPayload

  """Deletes a single `TaskLabel` using a unique key."""
  deleteTaskLabel(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTaskLabelInput!
  ): DeleteTaskLabelPayload

  """Deletes a single `Assignee` using its globally unique id."""
  deleteAssigneeById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAssigneeByIdInput!
  ): DeleteAssigneePayload

  """Deletes a single `Assignee` using a unique key."""
  deleteAssignee(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAssigneeInput!
  ): DeleteAssigneePayload

  """Deletes a single `Emoji` using its globally unique id."""
  deleteEmojiById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteEmojiByIdInput!
  ): DeleteEmojiPayload

  """Deletes a single `Emoji` using a unique key."""
  deleteEmoji(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteEmojiInput!
  ): DeleteEmojiPayload

  """Deletes a single `User` using its globally unique id."""
  deleteUserById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserByIdInput!
  ): DeleteUserPayload

  """Deletes a single `User` using a unique key."""
  deleteUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserInput!
  ): DeleteUserPayload

  """Deletes a single `Post` using its globally unique id."""
  deletePostById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePostByIdInput!
  ): DeletePostPayload

  """Deletes a single `Post` using a unique key."""
  deletePost(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePostInput!
  ): DeletePostPayload

  """Deletes a single `ProjectLabel` using its globally unique id."""
  deleteProjectLabelById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProjectLabelByIdInput!
  ): DeleteProjectLabelPayload

  """Deletes a single `ProjectLabel` using a unique key."""
  deleteProjectLabel(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProjectLabelInput!
  ): DeleteProjectLabelPayload

  """Deletes a single `Label` using its globally unique id."""
  deleteLabelById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLabelByIdInput!
  ): DeleteLabelPayload

  """Deletes a single `Label` using a unique key."""
  deleteLabel(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLabelInput!
  ): DeleteLabelPayload

  """Deletes a single `Column` using its globally unique id."""
  deleteColumnById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteColumnByIdInput!
  ): DeleteColumnPayload

  """Deletes a single `Column` using a unique key."""
  deleteColumn(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteColumnInput!
  ): DeleteColumnPayload

  """Deletes a single `ProjectColumn` using its globally unique id."""
  deleteProjectColumnById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProjectColumnByIdInput!
  ): DeleteProjectColumnPayload

  """Deletes a single `ProjectColumn` using a unique key."""
  deleteProjectColumn(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProjectColumnInput!
  ): DeleteProjectColumnPayload

  """Deletes a single `UserPreference` using its globally unique id."""
  deleteUserPreferenceById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserPreferenceByIdInput!
  ): DeleteUserPreferencePayload

  """Deletes a single `UserPreference` using a unique key."""
  deleteUserPreference(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserPreferenceInput!
  ): DeleteUserPreferencePayload

  """Deletes a single `Setting` using its globally unique id."""
  deleteSettingById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSettingByIdInput!
  ): DeleteSettingPayload

  """Deletes a single `Setting` using a unique key."""
  deleteSetting(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSettingInput!
  ): DeleteSettingPayload

  """Deletes a single `Task` using its globally unique id."""
  deleteTaskById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTaskByIdInput!
  ): DeleteTaskPayload

  """Deletes a single `Task` using a unique key."""
  deleteTask(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTaskInput!
  ): DeleteTaskPayload

  """Deletes a single `Project` using its globally unique id."""
  deleteProjectById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProjectByIdInput!
  ): DeleteProjectPayload

  """Deletes a single `Project` using a unique key."""
  deleteProject(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProjectInput!
  ): DeleteProjectPayload
}

"""The output of our create `ProjectProjectLabel` mutation."""
type CreateProjectProjectLabelPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ProjectProjectLabel` that was created by this mutation."""
  projectProjectLabel: ProjectProjectLabel

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `ProjectProjectLabel`. May be used by Relay 1."""
  projectProjectLabelEdge(
    """The method to use when ordering `ProjectProjectLabel`."""
    orderBy: [ProjectProjectLabelOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ProjectProjectLabelEdge
}

"""All input for the create `ProjectProjectLabel` mutation."""
input CreateProjectProjectLabelInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `ProjectProjectLabel` to be created by this mutation."""
  projectProjectLabel: ProjectProjectLabelInput!
}

"""An input for mutations affecting `ProjectProjectLabel`"""
input ProjectProjectLabelInput {
  projectId: UUID!
  projectLabelId: UUID!
  createdAt: Datetime
}

"""The output of our create `TaskLabel` mutation."""
type CreateTaskLabelPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TaskLabel` that was created by this mutation."""
  taskLabel: TaskLabel

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `TaskLabel`. May be used by Relay 1."""
  taskLabelEdge(
    """The method to use when ordering `TaskLabel`."""
    orderBy: [TaskLabelOrderBy!]! = [PRIMARY_KEY_ASC]
  ): TaskLabelEdge
}

"""All input for the create `TaskLabel` mutation."""
input CreateTaskLabelInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `TaskLabel` to be created by this mutation."""
  taskLabel: TaskLabelInput!
}

"""An input for mutations affecting `TaskLabel`"""
input TaskLabelInput {
  taskId: UUID!
  labelId: UUID!
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create `Assignee` mutation."""
type CreateAssigneePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Assignee` that was created by this mutation."""
  assignee: Assignee

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Assignee`. May be used by Relay 1."""
  assigneeEdge(
    """The method to use when ordering `Assignee`."""
    orderBy: [AssigneeOrderBy!]! = [PRIMARY_KEY_ASC]
  ): AssigneeEdge
}

"""All input for the create `Assignee` mutation."""
input CreateAssigneeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Assignee` to be created by this mutation."""
  assignee: AssigneeInput!
}

"""An input for mutations affecting `Assignee`"""
input AssigneeInput {
  userId: UUID!
  taskId: UUID!
  createdAt: Datetime
  updatedAt: Datetime
  deletedAt: Datetime
}

"""The output of our create `Emoji` mutation."""
type CreateEmojiPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Emoji` that was created by this mutation."""
  emoji: Emoji

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Emoji`. May be used by Relay 1."""
  emojiEdge(
    """The method to use when ordering `Emoji`."""
    orderBy: [EmojiOrderBy!]! = [PRIMARY_KEY_ASC]
  ): EmojiEdge
}

"""All input for the create `Emoji` mutation."""
input CreateEmojiInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Emoji` to be created by this mutation."""
  emoji: EmojiInput!
}

"""An input for mutations affecting `Emoji`"""
input EmojiInput {
  rowId: UUID
  emoji: String
  postId: UUID!
  userId: UUID!
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create `User` mutation."""
type CreateUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was created by this mutation."""
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UserOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UserEdge
}

"""All input for the create `User` mutation."""
input CreateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `User` to be created by this mutation."""
  user: UserInput!
}

"""An input for mutations affecting `User`"""
input UserInput {
  rowId: UUID
  identityProviderId: UUID!
  name: String!
  avatarUrl: String
  createdAt: Datetime
  updatedAt: Datetime
  email: String!
}

"""The output of our create `Post` mutation."""
type CreatePostPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Post` that was created by this mutation."""
  post: Post

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Post`. May be used by Relay 1."""
  postEdge(
    """The method to use when ordering `Post`."""
    orderBy: [PostOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PostEdge
}

"""All input for the create `Post` mutation."""
input CreatePostInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Post` to be created by this mutation."""
  post: PostInput!
}

"""An input for mutations affecting `Post`"""
input PostInput {
  rowId: UUID
  title: String
  description: String
  authorId: UUID
  taskId: UUID!
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create `ProjectLabel` mutation."""
type CreateProjectLabelPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ProjectLabel` that was created by this mutation."""
  projectLabel: ProjectLabel

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `ProjectLabel`. May be used by Relay 1."""
  projectLabelEdge(
    """The method to use when ordering `ProjectLabel`."""
    orderBy: [ProjectLabelOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ProjectLabelEdge
}

"""All input for the create `ProjectLabel` mutation."""
input CreateProjectLabelInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `ProjectLabel` to be created by this mutation."""
  projectLabel: ProjectLabelInput!
}

"""An input for mutations affecting `ProjectLabel`"""
input ProjectLabelInput {
  rowId: UUID
  name: String!
  color: String!
  icon: String
  organizationId: String!
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create `Label` mutation."""
type CreateLabelPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Label` that was created by this mutation."""
  label: Label

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Label`. May be used by Relay 1."""
  labelEdge(
    """The method to use when ordering `Label`."""
    orderBy: [LabelOrderBy!]! = [PRIMARY_KEY_ASC]
  ): LabelEdge
}

"""All input for the create `Label` mutation."""
input CreateLabelInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Label` to be created by this mutation."""
  label: LabelInput!
}

"""An input for mutations affecting `Label`"""
input LabelInput {
  rowId: UUID
  name: String!
  color: String!
  projectId: UUID
  createdAt: Datetime
  updatedAt: Datetime
  icon: String
  organizationId: String
}

"""The output of our create `Column` mutation."""
type CreateColumnPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Column` that was created by this mutation."""
  column: Column

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Column`. May be used by Relay 1."""
  columnEdge(
    """The method to use when ordering `Column`."""
    orderBy: [ColumnOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ColumnEdge
}

"""All input for the create `Column` mutation."""
input CreateColumnInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Column` to be created by this mutation."""
  column: ColumnInput!
}

"""An input for mutations affecting `Column`"""
input ColumnInput {
  rowId: UUID
  title: String!
  projectId: UUID!
  createdAt: Datetime
  updatedAt: Datetime
  index: Int
  icon: String
}

"""The output of our create `ProjectColumn` mutation."""
type CreateProjectColumnPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ProjectColumn` that was created by this mutation."""
  projectColumn: ProjectColumn

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `ProjectColumn`. May be used by Relay 1."""
  projectColumnEdge(
    """The method to use when ordering `ProjectColumn`."""
    orderBy: [ProjectColumnOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ProjectColumnEdge
}

"""All input for the create `ProjectColumn` mutation."""
input CreateProjectColumnInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `ProjectColumn` to be created by this mutation."""
  projectColumn: ProjectColumnInput!
}

"""An input for mutations affecting `ProjectColumn`"""
input ProjectColumnInput {
  rowId: UUID
  icon: String
  title: String!
  organizationId: String!
  index: Int
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create `UserPreference` mutation."""
type CreateUserPreferencePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserPreference` that was created by this mutation."""
  userPreference: UserPreference

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `UserPreference`. May be used by Relay 1."""
  userPreferenceEdge(
    """The method to use when ordering `UserPreference`."""
    orderBy: [UserPreferenceOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UserPreferenceEdge
}

"""All input for the create `UserPreference` mutation."""
input CreateUserPreferenceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `UserPreference` to be created by this mutation."""
  userPreference: UserPreferenceInput!
}

"""An input for mutations affecting `UserPreference`"""
input UserPreferenceInput {
  rowId: UUID
  userId: UUID!
  projectId: UUID!
  hiddenColumnIds: [String]
  createdAt: Datetime
  updatedAt: Datetime
  viewMode: String
  color: String
}

"""The output of our create `Setting` mutation."""
type CreateSettingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Setting` that was created by this mutation."""
  setting: Setting

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Setting`. May be used by Relay 1."""
  settingEdge(
    """The method to use when ordering `Setting`."""
    orderBy: [SettingOrderBy!]! = [PRIMARY_KEY_ASC]
  ): SettingEdge
}

"""All input for the create `Setting` mutation."""
input CreateSettingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Setting` to be created by this mutation."""
  setting: SettingInput!
}

"""An input for mutations affecting `Setting`"""
input SettingInput {
  rowId: UUID
  createdAt: Datetime
  updatedAt: Datetime
  viewMode: String
  billingAccountId: String
  organizationId: String!
  subscriptionId: String
  deletedAt: Datetime
  deletionReason: String
}

"""The output of our create `Task` mutation."""
type CreateTaskPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Task` that was created by this mutation."""
  task: Task

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Task`. May be used by Relay 1."""
  taskEdge(
    """The method to use when ordering `Task`."""
    orderBy: [TaskOrderBy!]! = [PRIMARY_KEY_ASC]
  ): TaskEdge
}

"""All input for the create `Task` mutation."""
input CreateTaskInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Task` to be created by this mutation."""
  task: TaskInput!
}

"""An input for mutations affecting `Task`"""
input TaskInput {
  rowId: UUID
  content: String!
  description: String!
  priority: String
  authorId: UUID
  columnId: UUID!
  dueDate: Datetime
  createdAt: Datetime
  updatedAt: Datetime
  columnIndex: Int
  projectId: UUID!
  number: Int
}

"""The output of our create `Project` mutation."""
type CreateProjectPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Project` that was created by this mutation."""
  project: Project

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Project`. May be used by Relay 1."""
  projectEdge(
    """The method to use when ordering `Project`."""
    orderBy: [ProjectOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ProjectEdge
}

"""All input for the create `Project` mutation."""
input CreateProjectInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Project` to be created by this mutation."""
  project: ProjectInput!
}

"""An input for mutations affecting `Project`"""
input ProjectInput {
  rowId: UUID
  name: String!
  description: String
  prefix: String
  organizationId: String!
  createdAt: Datetime
  updatedAt: Datetime
  projectColumnId: UUID!
  slug: String!
  columnIndex: Int
  isPublic: Boolean
  nextTaskNumber: Int
}

"""The output of our update `ProjectProjectLabel` mutation."""
type UpdateProjectProjectLabelPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ProjectProjectLabel` that was updated by this mutation."""
  projectProjectLabel: ProjectProjectLabel

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `ProjectProjectLabel`. May be used by Relay 1."""
  projectProjectLabelEdge(
    """The method to use when ordering `ProjectProjectLabel`."""
    orderBy: [ProjectProjectLabelOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ProjectProjectLabelEdge
}

"""All input for the `updateProjectProjectLabelById` mutation."""
input UpdateProjectProjectLabelByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ProjectProjectLabel` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `ProjectProjectLabel` being updated.
  """
  patch: ProjectProjectLabelPatch!
}

"""
Represents an update to a `ProjectProjectLabel`. Fields that are set will be updated.
"""
input ProjectProjectLabelPatch {
  projectId: UUID
  projectLabelId: UUID
  createdAt: Datetime
}

"""All input for the `updateProjectProjectLabel` mutation."""
input UpdateProjectProjectLabelInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  projectId: UUID!
  projectLabelId: UUID!

  """
  An object where the defined keys will be set on the `ProjectProjectLabel` being updated.
  """
  patch: ProjectProjectLabelPatch!
}

"""The output of our update `TaskLabel` mutation."""
type UpdateTaskLabelPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TaskLabel` that was updated by this mutation."""
  taskLabel: TaskLabel

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `TaskLabel`. May be used by Relay 1."""
  taskLabelEdge(
    """The method to use when ordering `TaskLabel`."""
    orderBy: [TaskLabelOrderBy!]! = [PRIMARY_KEY_ASC]
  ): TaskLabelEdge
}

"""All input for the `updateTaskLabelById` mutation."""
input UpdateTaskLabelByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `TaskLabel` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `TaskLabel` being updated.
  """
  patch: TaskLabelPatch!
}

"""
Represents an update to a `TaskLabel`. Fields that are set will be updated.
"""
input TaskLabelPatch {
  taskId: UUID
  labelId: UUID
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updateTaskLabel` mutation."""
input UpdateTaskLabelInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  taskId: UUID!
  labelId: UUID!

  """
  An object where the defined keys will be set on the `TaskLabel` being updated.
  """
  patch: TaskLabelPatch!
}

"""The output of our update `Assignee` mutation."""
type UpdateAssigneePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Assignee` that was updated by this mutation."""
  assignee: Assignee

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Assignee`. May be used by Relay 1."""
  assigneeEdge(
    """The method to use when ordering `Assignee`."""
    orderBy: [AssigneeOrderBy!]! = [PRIMARY_KEY_ASC]
  ): AssigneeEdge
}

"""All input for the `updateAssigneeById` mutation."""
input UpdateAssigneeByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Assignee` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `Assignee` being updated.
  """
  patch: AssigneePatch!
}

"""
Represents an update to a `Assignee`. Fields that are set will be updated.
"""
input AssigneePatch {
  userId: UUID
  taskId: UUID
  createdAt: Datetime
  updatedAt: Datetime
  deletedAt: Datetime
}

"""All input for the `updateAssignee` mutation."""
input UpdateAssigneeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  taskId: UUID!
  userId: UUID!

  """
  An object where the defined keys will be set on the `Assignee` being updated.
  """
  patch: AssigneePatch!
}

"""The output of our update `Emoji` mutation."""
type UpdateEmojiPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Emoji` that was updated by this mutation."""
  emoji: Emoji

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Emoji`. May be used by Relay 1."""
  emojiEdge(
    """The method to use when ordering `Emoji`."""
    orderBy: [EmojiOrderBy!]! = [PRIMARY_KEY_ASC]
  ): EmojiEdge
}

"""All input for the `updateEmojiById` mutation."""
input UpdateEmojiByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Emoji` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `Emoji` being updated.
  """
  patch: EmojiPatch!
}

"""
Represents an update to a `Emoji`. Fields that are set will be updated.
"""
input EmojiPatch {
  rowId: UUID
  emoji: String
  postId: UUID
  userId: UUID
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updateEmoji` mutation."""
input UpdateEmojiInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the `Emoji` being updated.
  """
  patch: EmojiPatch!
}

"""The output of our update `User` mutation."""
type UpdateUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was updated by this mutation."""
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UserOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UserEdge
}

"""All input for the `updateUserById` mutation."""
input UpdateUserByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `User` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `User` being updated.
  """
  patch: UserPatch!
}

"""Represents an update to a `User`. Fields that are set will be updated."""
input UserPatch {
  rowId: UUID
  identityProviderId: UUID
  name: String
  avatarUrl: String
  createdAt: Datetime
  updatedAt: Datetime
  email: String
}

"""All input for the `updateUser` mutation."""
input UpdateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the `User` being updated.
  """
  patch: UserPatch!
}

"""The output of our update `Post` mutation."""
type UpdatePostPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Post` that was updated by this mutation."""
  post: Post

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Post`. May be used by Relay 1."""
  postEdge(
    """The method to use when ordering `Post`."""
    orderBy: [PostOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PostEdge
}

"""All input for the `updatePostById` mutation."""
input UpdatePostByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Post` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `Post` being updated.
  """
  patch: PostPatch!
}

"""Represents an update to a `Post`. Fields that are set will be updated."""
input PostPatch {
  rowId: UUID
  title: String
  description: String
  authorId: UUID
  taskId: UUID
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updatePost` mutation."""
input UpdatePostInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the `Post` being updated.
  """
  patch: PostPatch!
}

"""The output of our update `ProjectLabel` mutation."""
type UpdateProjectLabelPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ProjectLabel` that was updated by this mutation."""
  projectLabel: ProjectLabel

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `ProjectLabel`. May be used by Relay 1."""
  projectLabelEdge(
    """The method to use when ordering `ProjectLabel`."""
    orderBy: [ProjectLabelOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ProjectLabelEdge
}

"""All input for the `updateProjectLabelById` mutation."""
input UpdateProjectLabelByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ProjectLabel` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `ProjectLabel` being updated.
  """
  patch: ProjectLabelPatch!
}

"""
Represents an update to a `ProjectLabel`. Fields that are set will be updated.
"""
input ProjectLabelPatch {
  rowId: UUID
  name: String
  color: String
  icon: String
  organizationId: String
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updateProjectLabel` mutation."""
input UpdateProjectLabelInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the `ProjectLabel` being updated.
  """
  patch: ProjectLabelPatch!
}

"""The output of our update `Label` mutation."""
type UpdateLabelPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Label` that was updated by this mutation."""
  label: Label

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Label`. May be used by Relay 1."""
  labelEdge(
    """The method to use when ordering `Label`."""
    orderBy: [LabelOrderBy!]! = [PRIMARY_KEY_ASC]
  ): LabelEdge
}

"""All input for the `updateLabelById` mutation."""
input UpdateLabelByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Label` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `Label` being updated.
  """
  patch: LabelPatch!
}

"""
Represents an update to a `Label`. Fields that are set will be updated.
"""
input LabelPatch {
  rowId: UUID
  name: String
  color: String
  projectId: UUID
  createdAt: Datetime
  updatedAt: Datetime
  icon: String
  organizationId: String
}

"""All input for the `updateLabel` mutation."""
input UpdateLabelInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the `Label` being updated.
  """
  patch: LabelPatch!
}

"""The output of our update `Column` mutation."""
type UpdateColumnPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Column` that was updated by this mutation."""
  column: Column

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Column`. May be used by Relay 1."""
  columnEdge(
    """The method to use when ordering `Column`."""
    orderBy: [ColumnOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ColumnEdge
}

"""All input for the `updateColumnById` mutation."""
input UpdateColumnByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Column` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `Column` being updated.
  """
  patch: ColumnPatch!
}

"""
Represents an update to a `Column`. Fields that are set will be updated.
"""
input ColumnPatch {
  rowId: UUID
  title: String
  projectId: UUID
  createdAt: Datetime
  updatedAt: Datetime
  index: Int
  icon: String
}

"""All input for the `updateColumn` mutation."""
input UpdateColumnInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the `Column` being updated.
  """
  patch: ColumnPatch!
}

"""The output of our update `ProjectColumn` mutation."""
type UpdateProjectColumnPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ProjectColumn` that was updated by this mutation."""
  projectColumn: ProjectColumn

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `ProjectColumn`. May be used by Relay 1."""
  projectColumnEdge(
    """The method to use when ordering `ProjectColumn`."""
    orderBy: [ProjectColumnOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ProjectColumnEdge
}

"""All input for the `updateProjectColumnById` mutation."""
input UpdateProjectColumnByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ProjectColumn` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `ProjectColumn` being updated.
  """
  patch: ProjectColumnPatch!
}

"""
Represents an update to a `ProjectColumn`. Fields that are set will be updated.
"""
input ProjectColumnPatch {
  rowId: UUID
  icon: String
  title: String
  organizationId: String
  index: Int
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updateProjectColumn` mutation."""
input UpdateProjectColumnInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the `ProjectColumn` being updated.
  """
  patch: ProjectColumnPatch!
}

"""The output of our update `UserPreference` mutation."""
type UpdateUserPreferencePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserPreference` that was updated by this mutation."""
  userPreference: UserPreference

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `UserPreference`. May be used by Relay 1."""
  userPreferenceEdge(
    """The method to use when ordering `UserPreference`."""
    orderBy: [UserPreferenceOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UserPreferenceEdge
}

"""All input for the `updateUserPreferenceById` mutation."""
input UpdateUserPreferenceByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `UserPreference` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `UserPreference` being updated.
  """
  patch: UserPreferencePatch!
}

"""
Represents an update to a `UserPreference`. Fields that are set will be updated.
"""
input UserPreferencePatch {
  rowId: UUID
  userId: UUID
  projectId: UUID
  hiddenColumnIds: [String]
  createdAt: Datetime
  updatedAt: Datetime
  viewMode: String
  color: String
}

"""All input for the `updateUserPreference` mutation."""
input UpdateUserPreferenceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the `UserPreference` being updated.
  """
  patch: UserPreferencePatch!
}

"""The output of our update `Setting` mutation."""
type UpdateSettingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Setting` that was updated by this mutation."""
  setting: Setting

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Setting`. May be used by Relay 1."""
  settingEdge(
    """The method to use when ordering `Setting`."""
    orderBy: [SettingOrderBy!]! = [PRIMARY_KEY_ASC]
  ): SettingEdge
}

"""All input for the `updateSettingById` mutation."""
input UpdateSettingByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Setting` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `Setting` being updated.
  """
  patch: SettingPatch!
}

"""
Represents an update to a `Setting`. Fields that are set will be updated.
"""
input SettingPatch {
  rowId: UUID
  createdAt: Datetime
  updatedAt: Datetime
  viewMode: String
  billingAccountId: String
  organizationId: String
  subscriptionId: String
  deletedAt: Datetime
  deletionReason: String
}

"""All input for the `updateSetting` mutation."""
input UpdateSettingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the `Setting` being updated.
  """
  patch: SettingPatch!
}

"""The output of our update `Task` mutation."""
type UpdateTaskPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Task` that was updated by this mutation."""
  task: Task

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Task`. May be used by Relay 1."""
  taskEdge(
    """The method to use when ordering `Task`."""
    orderBy: [TaskOrderBy!]! = [PRIMARY_KEY_ASC]
  ): TaskEdge
}

"""All input for the `updateTaskById` mutation."""
input UpdateTaskByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Task` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `Task` being updated.
  """
  patch: TaskPatch!
}

"""Represents an update to a `Task`. Fields that are set will be updated."""
input TaskPatch {
  rowId: UUID
  content: String
  description: String
  priority: String
  authorId: UUID
  columnId: UUID
  dueDate: Datetime
  createdAt: Datetime
  updatedAt: Datetime
  columnIndex: Int
  projectId: UUID
  number: Int
}

"""All input for the `updateTask` mutation."""
input UpdateTaskInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the `Task` being updated.
  """
  patch: TaskPatch!
}

"""The output of our update `Project` mutation."""
type UpdateProjectPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Project` that was updated by this mutation."""
  project: Project

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Project`. May be used by Relay 1."""
  projectEdge(
    """The method to use when ordering `Project`."""
    orderBy: [ProjectOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ProjectEdge
}

"""All input for the `updateProjectById` mutation."""
input UpdateProjectByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Project` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `Project` being updated.
  """
  patch: ProjectPatch!
}

"""
Represents an update to a `Project`. Fields that are set will be updated.
"""
input ProjectPatch {
  rowId: UUID
  name: String
  description: String
  prefix: String
  organizationId: String
  createdAt: Datetime
  updatedAt: Datetime
  projectColumnId: UUID
  slug: String
  columnIndex: Int
  isPublic: Boolean
  nextTaskNumber: Int
}

"""All input for the `updateProject` mutation."""
input UpdateProjectInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the `Project` being updated.
  """
  patch: ProjectPatch!
}

"""The output of our delete `ProjectProjectLabel` mutation."""
type DeleteProjectProjectLabelPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ProjectProjectLabel` that was deleted by this mutation."""
  projectProjectLabel: ProjectProjectLabel
  deletedProjectProjectLabelId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `ProjectProjectLabel`. May be used by Relay 1."""
  projectProjectLabelEdge(
    """The method to use when ordering `ProjectProjectLabel`."""
    orderBy: [ProjectProjectLabelOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ProjectProjectLabelEdge
}

"""All input for the `deleteProjectProjectLabelById` mutation."""
input DeleteProjectProjectLabelByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ProjectProjectLabel` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteProjectProjectLabel` mutation."""
input DeleteProjectProjectLabelInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  projectId: UUID!
  projectLabelId: UUID!
}

"""The output of our delete `TaskLabel` mutation."""
type DeleteTaskLabelPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TaskLabel` that was deleted by this mutation."""
  taskLabel: TaskLabel
  deletedTaskLabelId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `TaskLabel`. May be used by Relay 1."""
  taskLabelEdge(
    """The method to use when ordering `TaskLabel`."""
    orderBy: [TaskLabelOrderBy!]! = [PRIMARY_KEY_ASC]
  ): TaskLabelEdge
}

"""All input for the `deleteTaskLabelById` mutation."""
input DeleteTaskLabelByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `TaskLabel` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteTaskLabel` mutation."""
input DeleteTaskLabelInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  taskId: UUID!
  labelId: UUID!
}

"""The output of our delete `Assignee` mutation."""
type DeleteAssigneePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Assignee` that was deleted by this mutation."""
  assignee: Assignee
  deletedAssigneeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Assignee`. May be used by Relay 1."""
  assigneeEdge(
    """The method to use when ordering `Assignee`."""
    orderBy: [AssigneeOrderBy!]! = [PRIMARY_KEY_ASC]
  ): AssigneeEdge
}

"""All input for the `deleteAssigneeById` mutation."""
input DeleteAssigneeByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Assignee` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteAssignee` mutation."""
input DeleteAssigneeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  taskId: UUID!
  userId: UUID!
}

"""The output of our delete `Emoji` mutation."""
type DeleteEmojiPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Emoji` that was deleted by this mutation."""
  emoji: Emoji
  deletedEmojiId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Emoji`. May be used by Relay 1."""
  emojiEdge(
    """The method to use when ordering `Emoji`."""
    orderBy: [EmojiOrderBy!]! = [PRIMARY_KEY_ASC]
  ): EmojiEdge
}

"""All input for the `deleteEmojiById` mutation."""
input DeleteEmojiByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Emoji` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteEmoji` mutation."""
input DeleteEmojiInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete `User` mutation."""
type DeleteUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was deleted by this mutation."""
  user: User
  deletedUserId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UserOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UserEdge
}

"""All input for the `deleteUserById` mutation."""
input DeleteUserByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `User` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteUser` mutation."""
input DeleteUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete `Post` mutation."""
type DeletePostPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Post` that was deleted by this mutation."""
  post: Post
  deletedPostId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Post`. May be used by Relay 1."""
  postEdge(
    """The method to use when ordering `Post`."""
    orderBy: [PostOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PostEdge
}

"""All input for the `deletePostById` mutation."""
input DeletePostByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Post` to be deleted.
  """
  id: ID!
}

"""All input for the `deletePost` mutation."""
input DeletePostInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete `ProjectLabel` mutation."""
type DeleteProjectLabelPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ProjectLabel` that was deleted by this mutation."""
  projectLabel: ProjectLabel
  deletedProjectLabelId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `ProjectLabel`. May be used by Relay 1."""
  projectLabelEdge(
    """The method to use when ordering `ProjectLabel`."""
    orderBy: [ProjectLabelOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ProjectLabelEdge
}

"""All input for the `deleteProjectLabelById` mutation."""
input DeleteProjectLabelByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ProjectLabel` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteProjectLabel` mutation."""
input DeleteProjectLabelInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete `Label` mutation."""
type DeleteLabelPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Label` that was deleted by this mutation."""
  label: Label
  deletedLabelId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Label`. May be used by Relay 1."""
  labelEdge(
    """The method to use when ordering `Label`."""
    orderBy: [LabelOrderBy!]! = [PRIMARY_KEY_ASC]
  ): LabelEdge
}

"""All input for the `deleteLabelById` mutation."""
input DeleteLabelByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Label` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteLabel` mutation."""
input DeleteLabelInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete `Column` mutation."""
type DeleteColumnPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Column` that was deleted by this mutation."""
  column: Column
  deletedColumnId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Column`. May be used by Relay 1."""
  columnEdge(
    """The method to use when ordering `Column`."""
    orderBy: [ColumnOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ColumnEdge
}

"""All input for the `deleteColumnById` mutation."""
input DeleteColumnByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Column` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteColumn` mutation."""
input DeleteColumnInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete `ProjectColumn` mutation."""
type DeleteProjectColumnPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ProjectColumn` that was deleted by this mutation."""
  projectColumn: ProjectColumn
  deletedProjectColumnId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `ProjectColumn`. May be used by Relay 1."""
  projectColumnEdge(
    """The method to use when ordering `ProjectColumn`."""
    orderBy: [ProjectColumnOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ProjectColumnEdge
}

"""All input for the `deleteProjectColumnById` mutation."""
input DeleteProjectColumnByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ProjectColumn` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteProjectColumn` mutation."""
input DeleteProjectColumnInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete `UserPreference` mutation."""
type DeleteUserPreferencePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserPreference` that was deleted by this mutation."""
  userPreference: UserPreference
  deletedUserPreferenceId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `UserPreference`. May be used by Relay 1."""
  userPreferenceEdge(
    """The method to use when ordering `UserPreference`."""
    orderBy: [UserPreferenceOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UserPreferenceEdge
}

"""All input for the `deleteUserPreferenceById` mutation."""
input DeleteUserPreferenceByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `UserPreference` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteUserPreference` mutation."""
input DeleteUserPreferenceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete `Setting` mutation."""
type DeleteSettingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Setting` that was deleted by this mutation."""
  setting: Setting
  deletedSettingId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Setting`. May be used by Relay 1."""
  settingEdge(
    """The method to use when ordering `Setting`."""
    orderBy: [SettingOrderBy!]! = [PRIMARY_KEY_ASC]
  ): SettingEdge
}

"""All input for the `deleteSettingById` mutation."""
input DeleteSettingByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Setting` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteSetting` mutation."""
input DeleteSettingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete `Task` mutation."""
type DeleteTaskPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Task` that was deleted by this mutation."""
  task: Task
  deletedTaskId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Task`. May be used by Relay 1."""
  taskEdge(
    """The method to use when ordering `Task`."""
    orderBy: [TaskOrderBy!]! = [PRIMARY_KEY_ASC]
  ): TaskEdge
}

"""All input for the `deleteTaskById` mutation."""
input DeleteTaskByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Task` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteTask` mutation."""
input DeleteTaskInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete `Project` mutation."""
type DeleteProjectPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Project` that was deleted by this mutation."""
  project: Project
  deletedProjectId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Project`. May be used by Relay 1."""
  projectEdge(
    """The method to use when ordering `Project`."""
    orderBy: [ProjectOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ProjectEdge
}

"""All input for the `deleteProjectById` mutation."""
input DeleteProjectByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Project` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteProject` mutation."""
input DeleteProjectInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The currently authenticated user."""
type Observer {
  rowId: UUID!
  identityProviderId: UUID!
  name: String!
  email: String!
}