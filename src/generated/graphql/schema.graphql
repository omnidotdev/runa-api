"""The root query type which gives access points into the data universe."""
type Query implements Node {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  """
  id: ID!

  """Fetches an object given its globally unique `ID`."""
  node(
    """The globally unique `ID`."""
    id: ID!
  ): Node

  """Get a single `ProjectProjectLabel`."""
  projectProjectLabel(projectId: UUID!, projectLabelId: UUID!): ProjectProjectLabel

  """Get a single `TaskLabel`."""
  taskLabel(taskId: UUID!, labelId: UUID!): TaskLabel

  """Get a single `TaskLabel`."""
  taskLabelByTaskIdAndLabelId(taskId: UUID!, labelId: UUID!): TaskLabel

  """Get a single `Assignee`."""
  assignee(taskId: UUID!, userId: UUID!): Assignee

  """Get a single `Assignee`."""
  assigneeByTaskIdAndUserId(taskId: UUID!, userId: UUID!): Assignee

  """Get a single `Emoji`."""
  emoji(rowId: UUID!): Emoji

  """Get a single `User`."""
  user(rowId: UUID!): User

  """Get a single `User`."""
  userByEmail(email: String!): User

  """Get a single `User`."""
  userByIdentityProviderId(identityProviderId: UUID!): User

  """Get a single `Post`."""
  post(rowId: UUID!): Post

  """Get a single `ProjectLabel`."""
  projectLabel(rowId: UUID!): ProjectLabel

  """Get a single `Label`."""
  label(rowId: UUID!): Label

  """Get a single `Column`."""
  column(rowId: UUID!): Column

  """Get a single `AgentPersona`."""
  agentPersona(rowId: UUID!): AgentPersona

  """Get a single `ProjectColumn`."""
  projectColumn(rowId: UUID!): ProjectColumn

  """Get a single `UserPreference`."""
  userPreference(rowId: UUID!): UserPreference

  """Get a single `UserPreference`."""
  userPreferenceByUserIdAndProjectId(userId: UUID!, projectId: UUID!): UserPreference

  """Get a single `AgentMarketplaceListing`."""
  agentMarketplaceListing(rowId: UUID!): AgentMarketplaceListing

  """Get a single `AgentWebhook`."""
  agentWebhook(rowId: UUID!): AgentWebhook

  """Get a single `AgentSchedule`."""
  agentSchedule(rowId: UUID!): AgentSchedule

  """Get a single `AgentSession`."""
  agentSession(rowId: UUID!): AgentSession

  """Get a single `Setting`."""
  setting(rowId: UUID!): Setting

  """Get a single `Setting`."""
  settingByOrganizationId(organizationId: String!): Setting

  """Get a single `Project`."""
  project(rowId: UUID!): Project

  """Get a single `Project`."""
  projectBySlugAndOrganizationId(slug: String!, organizationId: String!): Project

  """Get a single `Task`."""
  task(rowId: UUID!): Task

  """Get a single `Task`."""
  taskByProjectIdAndNumber(projectId: UUID!, number: Int!): Task

  """Get a single `AgentConfig`."""
  agentConfig(rowId: UUID!): AgentConfig

  """Get a single `AgentConfig`."""
  agentConfigByOrganizationId(organizationId: String!): AgentConfig

  """Get a single `AgentActivity`."""
  agentActivity(rowId: UUID!): AgentActivity

  """Get a single `UserOrganization`."""
  userOrganization(rowId: UUID!): UserOrganization

  """Get a single `UserOrganization`."""
  userOrganizationByUserIdAndOrganizationId(userId: UUID!, organizationId: String!): UserOrganization

  """Reads a single `ProjectProjectLabel` using its globally unique `ID`."""
  projectProjectLabelById(
    """
    The globally unique `ID` to be used in selecting a single `ProjectProjectLabel`.
    """
    id: ID!
  ): ProjectProjectLabel

  """Reads a single `TaskLabel` using its globally unique `ID`."""
  taskLabelById(
    """The globally unique `ID` to be used in selecting a single `TaskLabel`."""
    id: ID!
  ): TaskLabel

  """Reads a single `Assignee` using its globally unique `ID`."""
  assigneeById(
    """The globally unique `ID` to be used in selecting a single `Assignee`."""
    id: ID!
  ): Assignee

  """Reads a single `Emoji` using its globally unique `ID`."""
  emojiById(
    """The globally unique `ID` to be used in selecting a single `Emoji`."""
    id: ID!
  ): Emoji

  """Reads a single `User` using its globally unique `ID`."""
  userById(
    """The globally unique `ID` to be used in selecting a single `User`."""
    id: ID!
  ): User

  """Reads a single `Post` using its globally unique `ID`."""
  postById(
    """The globally unique `ID` to be used in selecting a single `Post`."""
    id: ID!
  ): Post

  """Reads a single `ProjectLabel` using its globally unique `ID`."""
  projectLabelById(
    """
    The globally unique `ID` to be used in selecting a single `ProjectLabel`.
    """
    id: ID!
  ): ProjectLabel

  """Reads a single `Label` using its globally unique `ID`."""
  labelById(
    """The globally unique `ID` to be used in selecting a single `Label`."""
    id: ID!
  ): Label

  """Reads a single `Column` using its globally unique `ID`."""
  columnById(
    """The globally unique `ID` to be used in selecting a single `Column`."""
    id: ID!
  ): Column

  """Reads a single `AgentPersona` using its globally unique `ID`."""
  agentPersonaById(
    """
    The globally unique `ID` to be used in selecting a single `AgentPersona`.
    """
    id: ID!
  ): AgentPersona

  """Reads a single `ProjectColumn` using its globally unique `ID`."""
  projectColumnById(
    """
    The globally unique `ID` to be used in selecting a single `ProjectColumn`.
    """
    id: ID!
  ): ProjectColumn

  """Reads a single `UserPreference` using its globally unique `ID`."""
  userPreferenceById(
    """
    The globally unique `ID` to be used in selecting a single `UserPreference`.
    """
    id: ID!
  ): UserPreference

  """
  Reads a single `AgentMarketplaceListing` using its globally unique `ID`.
  """
  agentMarketplaceListingById(
    """
    The globally unique `ID` to be used in selecting a single `AgentMarketplaceListing`.
    """
    id: ID!
  ): AgentMarketplaceListing

  """Reads a single `AgentWebhook` using its globally unique `ID`."""
  agentWebhookById(
    """
    The globally unique `ID` to be used in selecting a single `AgentWebhook`.
    """
    id: ID!
  ): AgentWebhook

  """Reads a single `AgentSchedule` using its globally unique `ID`."""
  agentScheduleById(
    """
    The globally unique `ID` to be used in selecting a single `AgentSchedule`.
    """
    id: ID!
  ): AgentSchedule

  """Reads a single `AgentSession` using its globally unique `ID`."""
  agentSessionById(
    """
    The globally unique `ID` to be used in selecting a single `AgentSession`.
    """
    id: ID!
  ): AgentSession

  """Reads a single `Setting` using its globally unique `ID`."""
  settingById(
    """The globally unique `ID` to be used in selecting a single `Setting`."""
    id: ID!
  ): Setting

  """Reads a single `Project` using its globally unique `ID`."""
  projectById(
    """The globally unique `ID` to be used in selecting a single `Project`."""
    id: ID!
  ): Project

  """Reads a single `Task` using its globally unique `ID`."""
  taskById(
    """The globally unique `ID` to be used in selecting a single `Task`."""
    id: ID!
  ): Task

  """Reads a single `AgentConfig` using its globally unique `ID`."""
  agentConfigById(
    """
    The globally unique `ID` to be used in selecting a single `AgentConfig`.
    """
    id: ID!
  ): AgentConfig

  """Reads a single `AgentActivity` using its globally unique `ID`."""
  agentActivityById(
    """
    The globally unique `ID` to be used in selecting a single `AgentActivity`.
    """
    id: ID!
  ): AgentActivity

  """Reads a single `UserOrganization` using its globally unique `ID`."""
  userOrganizationById(
    """
    The globally unique `ID` to be used in selecting a single `UserOrganization`.
    """
    id: ID!
  ): UserOrganization

  """Reads and enables pagination through a set of `ProjectProjectLabel`."""
  projectProjectLabels(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectProjectLabelCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectProjectLabelFilter

    """The method to use when ordering `ProjectProjectLabel`."""
    orderBy: [ProjectProjectLabelOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectProjectLabelConnection

  """Reads and enables pagination through a set of `TaskLabel`."""
  taskLabels(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TaskLabelCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TaskLabelFilter

    """The method to use when ordering `TaskLabel`."""
    orderBy: [TaskLabelOrderBy!] = [PRIMARY_KEY_ASC]
  ): TaskLabelConnection

  """Reads and enables pagination through a set of `Assignee`."""
  assignees(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AssigneeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AssigneeFilter

    """The method to use when ordering `Assignee`."""
    orderBy: [AssigneeOrderBy!] = [PRIMARY_KEY_ASC]
  ): AssigneeConnection

  """Reads and enables pagination through a set of `Emoji`."""
  emojis(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EmojiCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EmojiFilter

    """The method to use when ordering `Emoji`."""
    orderBy: [EmojiOrderBy!] = [PRIMARY_KEY_ASC]
  ): EmojiConnection

  """Reads and enables pagination through a set of `User`."""
  users(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter

    """The method to use when ordering `User`."""
    orderBy: [UserOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserConnection

  """Reads and enables pagination through a set of `Post`."""
  posts(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PostCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PostFilter

    """The method to use when ordering `Post`."""
    orderBy: [PostOrderBy!] = [PRIMARY_KEY_ASC]
  ): PostConnection

  """Reads and enables pagination through a set of `ProjectLabel`."""
  projectLabels(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectLabelCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectLabelFilter

    """The method to use when ordering `ProjectLabel`."""
    orderBy: [ProjectLabelOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectLabelConnection

  """Reads and enables pagination through a set of `Label`."""
  labels(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LabelCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: LabelFilter

    """The method to use when ordering `Label`."""
    orderBy: [LabelOrderBy!] = [PRIMARY_KEY_ASC]
  ): LabelConnection

  """Reads and enables pagination through a set of `Column`."""
  columns(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ColumnCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ColumnFilter

    """The method to use when ordering `Column`."""
    orderBy: [ColumnOrderBy!] = [PRIMARY_KEY_ASC]
  ): ColumnConnection

  """Reads and enables pagination through a set of `AgentPersona`."""
  agentPersonas(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AgentPersonaCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AgentPersonaFilter

    """The method to use when ordering `AgentPersona`."""
    orderBy: [AgentPersonaOrderBy!] = [PRIMARY_KEY_ASC]
  ): AgentPersonaConnection

  """Reads and enables pagination through a set of `ProjectColumn`."""
  projectColumns(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectColumnCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectColumnFilter

    """The method to use when ordering `ProjectColumn`."""
    orderBy: [ProjectColumnOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectColumnConnection

  """Reads and enables pagination through a set of `UserPreference`."""
  userPreferences(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserPreferenceCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserPreferenceFilter

    """The method to use when ordering `UserPreference`."""
    orderBy: [UserPreferenceOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserPreferenceConnection

  """
  Reads and enables pagination through a set of `AgentMarketplaceListing`.
  """
  agentMarketplaceListings(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AgentMarketplaceListingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AgentMarketplaceListingFilter

    """The method to use when ordering `AgentMarketplaceListing`."""
    orderBy: [AgentMarketplaceListingOrderBy!] = [PRIMARY_KEY_ASC]
  ): AgentMarketplaceListingConnection

  """Reads and enables pagination through a set of `AgentWebhook`."""
  agentWebhooks(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AgentWebhookCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AgentWebhookFilter

    """The method to use when ordering `AgentWebhook`."""
    orderBy: [AgentWebhookOrderBy!] = [PRIMARY_KEY_ASC]
  ): AgentWebhookConnection

  """Reads and enables pagination through a set of `AgentSchedule`."""
  agentSchedules(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AgentScheduleCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AgentScheduleFilter

    """The method to use when ordering `AgentSchedule`."""
    orderBy: [AgentScheduleOrderBy!] = [PRIMARY_KEY_ASC]
  ): AgentScheduleConnection

  """Reads and enables pagination through a set of `AgentSession`."""
  agentSessions(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AgentSessionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AgentSessionFilter

    """The method to use when ordering `AgentSession`."""
    orderBy: [AgentSessionOrderBy!] = [PRIMARY_KEY_ASC]
  ): AgentSessionConnection

  """Reads and enables pagination through a set of `Setting`."""
  settings(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SettingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SettingFilter

    """The method to use when ordering `Setting`."""
    orderBy: [SettingOrderBy!] = [PRIMARY_KEY_ASC]
  ): SettingConnection

  """Reads and enables pagination through a set of `Project`."""
  projects(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectFilter

    """The method to use when ordering `Project`."""
    orderBy: [ProjectOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectConnection

  """Reads and enables pagination through a set of `Task`."""
  tasks(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TaskCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TaskFilter

    """The method to use when ordering `Task`."""
    orderBy: [TaskOrderBy!] = [PRIMARY_KEY_ASC]
  ): TaskConnection

  """Reads and enables pagination through a set of `AgentConfig`."""
  agentConfigs(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AgentConfigCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AgentConfigFilter

    """The method to use when ordering `AgentConfig`."""
    orderBy: [AgentConfigOrderBy!] = [PRIMARY_KEY_ASC]
  ): AgentConfigConnection

  """Reads and enables pagination through a set of `AgentActivity`."""
  agentActivities(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AgentActivityCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AgentActivityFilter

    """The method to use when ordering `AgentActivity`."""
    orderBy: [AgentActivityOrderBy!] = [PRIMARY_KEY_ASC]
  ): AgentActivityConnection

  """Reads and enables pagination through a set of `UserOrganization`."""
  userOrganizations(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserOrganizationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserOrganizationFilter

    """The method to use when ordering `UserOrganization`."""
    orderBy: [UserOrganizationOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserOrganizationConnection

  """
  Returns the currently authenticated user (observer).
  Returns null if not authenticated.
  """
  observer: Observer
}

"""An object with a globally unique `ID`."""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
}

type ProjectProjectLabel implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  projectId: UUID!
  projectLabelId: UUID!
  createdAt: Datetime!

  """
  Reads a single `Project` that is related to this `ProjectProjectLabel`.
  """
  project: Project

  """
  Reads a single `ProjectLabel` that is related to this `ProjectProjectLabel`.
  """
  projectLabel: ProjectLabel
}

"""
A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122).
"""
scalar UUID

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) and, if it has a timezone, [RFC
3339](https://datatracker.ietf.org/doc/html/rfc3339) standards. Input values
that do not conform to both ISO 8601 and RFC 3339 may be coerced, which may lead
to unexpected results.
"""
scalar Datetime

type Project implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  name: String!
  description: String
  prefix: String
  organizationId: String!
  createdAt: Datetime!
  updatedAt: Datetime!
  projectColumnId: UUID!
  slug: String!
  columnIndex: Int!
  isPublic: Boolean!
  nextTaskNumber: Int!

  """Reads a single `ProjectColumn` that is related to this `Project`."""
  projectColumn: ProjectColumn

  """Reads and enables pagination through a set of `Column`."""
  columns(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ColumnCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ColumnFilter

    """The method to use when ordering `Column`."""
    orderBy: [ColumnOrderBy!] = [PRIMARY_KEY_ASC]
  ): ColumnConnection!

  """Reads and enables pagination through a set of `Task`."""
  tasks(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TaskCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TaskFilter

    """The method to use when ordering `Task`."""
    orderBy: [TaskOrderBy!] = [PRIMARY_KEY_ASC]
  ): TaskConnection!

  """Reads and enables pagination through a set of `Label`."""
  labels(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LabelCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: LabelFilter

    """The method to use when ordering `Label`."""
    orderBy: [LabelOrderBy!] = [PRIMARY_KEY_ASC]
  ): LabelConnection!

  """Reads and enables pagination through a set of `UserPreference`."""
  userPreferences(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserPreferenceCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserPreferenceFilter

    """The method to use when ordering `UserPreference`."""
    orderBy: [UserPreferenceOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserPreferenceConnection!

  """Reads and enables pagination through a set of `ProjectProjectLabel`."""
  projectProjectLabels(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectProjectLabelCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectProjectLabelFilter

    """The method to use when ordering `ProjectProjectLabel`."""
    orderBy: [ProjectProjectLabelOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectProjectLabelConnection!

  """Reads and enables pagination through a set of `AgentActivity`."""
  agentActivities(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AgentActivityCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AgentActivityFilter

    """The method to use when ordering `AgentActivity`."""
    orderBy: [AgentActivityOrderBy!] = [PRIMARY_KEY_ASC]
  ): AgentActivityConnection!

  """Reads and enables pagination through a set of `AgentSession`."""
  agentSessions(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AgentSessionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AgentSessionFilter

    """The method to use when ordering `AgentSession`."""
    orderBy: [AgentSessionOrderBy!] = [PRIMARY_KEY_ASC]
  ): AgentSessionConnection!

  """Reads and enables pagination through a set of `AgentSchedule`."""
  agentSchedules(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AgentScheduleCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AgentScheduleFilter

    """The method to use when ordering `AgentSchedule`."""
    orderBy: [AgentScheduleOrderBy!] = [PRIMARY_KEY_ASC]
  ): AgentScheduleConnection!

  """Reads and enables pagination through a set of `AgentWebhook`."""
  agentWebhooks(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AgentWebhookCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AgentWebhookFilter

    """The method to use when ordering `AgentWebhook`."""
    orderBy: [AgentWebhookOrderBy!] = [PRIMARY_KEY_ASC]
  ): AgentWebhookConnection!
}

type ProjectColumn implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  icon: String
  title: String!
  organizationId: String!
  index: Int!
  createdAt: Datetime!
  updatedAt: Datetime!

  """Reads and enables pagination through a set of `Project`."""
  projects(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectFilter

    """The method to use when ordering `Project`."""
    orderBy: [ProjectOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectConnection!
}

"""A connection to a list of `Project` values."""
type ProjectConnection {
  """A list of `Project` objects."""
  nodes: [Project!]!

  """
  A list of edges which contains the `Project` and cursor to aid in pagination.
  """
  edges: [ProjectEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Project` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: ProjectAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Project` for these aggregates."""
    groupBy: [ProjectGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: ProjectHavingInput
  ): [ProjectAggregates!]
}

"""A `Project` edge in the connection."""
type ProjectEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Project` at the end of the edge."""
  node: Project!
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor

  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}

type ProjectAggregates {
  keys: [String]

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: ProjectSumAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: ProjectDistinctCountAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: ProjectMinAggregates

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: ProjectMaxAggregates

  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: ProjectAverageAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: ProjectStddevSampleAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: ProjectStddevPopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: ProjectVarianceSampleAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: ProjectVariancePopulationAggregates
}

type ProjectSumAggregates {
  """Sum of columnIndex across the matching connection"""
  columnIndex: BigInt!

  """Sum of nextTaskNumber across the matching connection"""
  nextTaskNumber: BigInt!
}

"""
A signed eight-byte integer. The upper big integer values are greater than the
max value for a JavaScript number. Therefore all big integers will be output as
strings and not numbers.
"""
scalar BigInt

type ProjectDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of name across the matching connection"""
  name: BigInt

  """Distinct count of description across the matching connection"""
  description: BigInt

  """Distinct count of prefix across the matching connection"""
  prefix: BigInt

  """Distinct count of organizationId across the matching connection"""
  organizationId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt

  """Distinct count of projectColumnId across the matching connection"""
  projectColumnId: BigInt

  """Distinct count of slug across the matching connection"""
  slug: BigInt

  """Distinct count of columnIndex across the matching connection"""
  columnIndex: BigInt

  """Distinct count of isPublic across the matching connection"""
  isPublic: BigInt

  """Distinct count of nextTaskNumber across the matching connection"""
  nextTaskNumber: BigInt
}

type ProjectMinAggregates {
  """Minimum of columnIndex across the matching connection"""
  columnIndex: Int

  """Minimum of nextTaskNumber across the matching connection"""
  nextTaskNumber: Int
}

type ProjectMaxAggregates {
  """Maximum of columnIndex across the matching connection"""
  columnIndex: Int

  """Maximum of nextTaskNumber across the matching connection"""
  nextTaskNumber: Int
}

type ProjectAverageAggregates {
  """Mean average of columnIndex across the matching connection"""
  columnIndex: BigFloat

  """Mean average of nextTaskNumber across the matching connection"""
  nextTaskNumber: BigFloat
}

"""
A floating point number that requires more precision than IEEE 754 binary 64
"""
scalar BigFloat

type ProjectStddevSampleAggregates {
  """
  Sample standard deviation of columnIndex across the matching connection
  """
  columnIndex: BigFloat

  """
  Sample standard deviation of nextTaskNumber across the matching connection
  """
  nextTaskNumber: BigFloat
}

type ProjectStddevPopulationAggregates {
  """
  Population standard deviation of columnIndex across the matching connection
  """
  columnIndex: BigFloat

  """
  Population standard deviation of nextTaskNumber across the matching connection
  """
  nextTaskNumber: BigFloat
}

type ProjectVarianceSampleAggregates {
  """Sample variance of columnIndex across the matching connection"""
  columnIndex: BigFloat

  """Sample variance of nextTaskNumber across the matching connection"""
  nextTaskNumber: BigFloat
}

type ProjectVariancePopulationAggregates {
  """Population variance of columnIndex across the matching connection"""
  columnIndex: BigFloat

  """Population variance of nextTaskNumber across the matching connection"""
  nextTaskNumber: BigFloat
}

"""Grouping methods for `Project` for usage during aggregation."""
enum ProjectGroupBy {
  NAME
  DESCRIPTION
  PREFIX
  ORGANIZATION_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
  PROJECT_COLUMN_ID
  SLUG
  COLUMN_INDEX
  IS_PUBLIC
  NEXT_TASK_NUMBER
}

"""Conditions for `Project` aggregates."""
input ProjectHavingInput {
  AND: [ProjectHavingInput!]
  OR: [ProjectHavingInput!]
  sum: ProjectHavingSumInput
  distinctCount: ProjectHavingDistinctCountInput
  min: ProjectHavingMinInput
  max: ProjectHavingMaxInput
  average: ProjectHavingAverageInput
  stddevSample: ProjectHavingStddevSampleInput
  stddevPopulation: ProjectHavingStddevPopulationInput
  varianceSample: ProjectHavingVarianceSampleInput
  variancePopulation: ProjectHavingVariancePopulationInput
}

input ProjectHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  nextTaskNumber: HavingIntFilter
}

input HavingDatetimeFilter {
  equalTo: Datetime
  notEqualTo: Datetime
  greaterThan: Datetime
  greaterThanOrEqualTo: Datetime
  lessThan: Datetime
  lessThanOrEqualTo: Datetime
}

input HavingIntFilter {
  equalTo: Int
  notEqualTo: Int
  greaterThan: Int
  greaterThanOrEqualTo: Int
  lessThan: Int
  lessThanOrEqualTo: Int
}

input ProjectHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  nextTaskNumber: HavingIntFilter
}

input ProjectHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  nextTaskNumber: HavingIntFilter
}

input ProjectHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  nextTaskNumber: HavingIntFilter
}

input ProjectHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  nextTaskNumber: HavingIntFilter
}

input ProjectHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  nextTaskNumber: HavingIntFilter
}

input ProjectHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  nextTaskNumber: HavingIntFilter
}

input ProjectHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  nextTaskNumber: HavingIntFilter
}

input ProjectHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  nextTaskNumber: HavingIntFilter
}

"""
A condition to be used against `Project` object types. All fields are tested for equality and combined with a logical and.
"""
input ProjectCondition {
  """Checks for equality with the objects `rowId` field."""
  rowId: UUID

  """Checks for equality with the objects `name` field."""
  name: String

  """Checks for equality with the objects `description` field."""
  description: String

  """Checks for equality with the objects `prefix` field."""
  prefix: String

  """Checks for equality with the objects `organizationId` field."""
  organizationId: String

  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the objects `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the objects `projectColumnId` field."""
  projectColumnId: UUID

  """Checks for equality with the objects `slug` field."""
  slug: String

  """Checks for equality with the objects `columnIndex` field."""
  columnIndex: Int

  """Checks for equality with the objects `isPublic` field."""
  isPublic: Boolean

  """Checks for equality with the objects `nextTaskNumber` field."""
  nextTaskNumber: Int
}

"""
A filter to be used against `Project` object types. All fields are combined with a logical and.
"""
input ProjectFilter {
  """Filter by the objects `rowId` field."""
  rowId: UUIDFilter

  """Filter by the objects `name` field."""
  name: StringFilter

  """Filter by the objects `description` field."""
  description: StringFilter

  """Filter by the objects `prefix` field."""
  prefix: StringFilter

  """Filter by the objects `organizationId` field."""
  organizationId: StringFilter

  """Filter by the objects `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the objects `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects `projectColumnId` field."""
  projectColumnId: UUIDFilter

  """Filter by the objects `slug` field."""
  slug: StringFilter

  """Filter by the objects `columnIndex` field."""
  columnIndex: IntFilter

  """Filter by the objects `isPublic` field."""
  isPublic: BooleanFilter

  """Filter by the objects `nextTaskNumber` field."""
  nextTaskNumber: IntFilter

  """Filter by the objects `columns` relation."""
  columns: ProjectToManyColumnFilter

  """Some related `columns` exist."""
  columnsExist: Boolean

  """Filter by the objects `tasks` relation."""
  tasks: ProjectToManyTaskFilter

  """Some related `tasks` exist."""
  tasksExist: Boolean

  """Filter by the objects `labels` relation."""
  labels: ProjectToManyLabelFilter

  """Some related `labels` exist."""
  labelsExist: Boolean

  """Filter by the objects `userPreferences` relation."""
  userPreferences: ProjectToManyUserPreferenceFilter

  """Some related `userPreferences` exist."""
  userPreferencesExist: Boolean

  """Filter by the objects `projectProjectLabels` relation."""
  projectProjectLabels: ProjectToManyProjectProjectLabelFilter

  """Some related `projectProjectLabels` exist."""
  projectProjectLabelsExist: Boolean

  """Filter by the objects `agentActivities` relation."""
  agentActivities: ProjectToManyAgentActivityFilter

  """Some related `agentActivities` exist."""
  agentActivitiesExist: Boolean

  """Filter by the objects `agentSessions` relation."""
  agentSessions: ProjectToManyAgentSessionFilter

  """Some related `agentSessions` exist."""
  agentSessionsExist: Boolean

  """Filter by the objects `agentSchedules` relation."""
  agentSchedules: ProjectToManyAgentScheduleFilter

  """Some related `agentSchedules` exist."""
  agentSchedulesExist: Boolean

  """Filter by the objects `agentWebhooks` relation."""
  agentWebhooks: ProjectToManyAgentWebhookFilter

  """Some related `agentWebhooks` exist."""
  agentWebhooksExist: Boolean

  """Filter by the objects `projectColumn` relation."""
  projectColumn: ProjectColumnFilter

  """Checks for all expressions in this list."""
  and: [ProjectFilter!]

  """Checks for any expressions in this list."""
  or: [ProjectFilter!]

  """Negates the expression."""
  not: ProjectFilter
}

"""
A filter to be used against UUID fields. All fields are combined with a logical and.
"""
input UUIDFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: UUID

  """Not equal to the specified value."""
  notEqualTo: UUID

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: UUID

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: UUID

  """Included in the specified list."""
  in: [UUID!]

  """Not included in the specified list."""
  notIn: [UUID!]

  """Less than the specified value."""
  lessThan: UUID

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: UUID

  """Greater than the specified value."""
  greaterThan: UUID

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: UUID
}

"""
A filter to be used against String fields. All fields are combined with a logical and.
"""
input StringFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: String

  """Not equal to the specified value."""
  notEqualTo: String

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: String

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: String

  """Included in the specified list."""
  in: [String!]

  """Not included in the specified list."""
  notIn: [String!]

  """Less than the specified value."""
  lessThan: String

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: String

  """Greater than the specified value."""
  greaterThan: String

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: String

  """Contains the specified string (case-sensitive)."""
  includes: String

  """Does not contain the specified string (case-sensitive)."""
  notIncludes: String

  """Contains the specified string (case-insensitive)."""
  includesInsensitive: String

  """Does not contain the specified string (case-insensitive)."""
  notIncludesInsensitive: String

  """Starts with the specified string (case-sensitive)."""
  startsWith: String

  """Does not start with the specified string (case-sensitive)."""
  notStartsWith: String

  """Starts with the specified string (case-insensitive)."""
  startsWithInsensitive: String

  """Does not start with the specified string (case-insensitive)."""
  notStartsWithInsensitive: String

  """Ends with the specified string (case-sensitive)."""
  endsWith: String

  """Does not end with the specified string (case-sensitive)."""
  notEndsWith: String

  """Ends with the specified string (case-insensitive)."""
  endsWithInsensitive: String

  """Does not end with the specified string (case-insensitive)."""
  notEndsWithInsensitive: String

  """
  Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  like: String

  """
  Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLike: String

  """
  Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  likeInsensitive: String

  """
  Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLikeInsensitive: String

  """Equal to the specified value (case-insensitive)."""
  equalToInsensitive: String

  """Not equal to the specified value (case-insensitive)."""
  notEqualToInsensitive: String

  """
  Not equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  distinctFromInsensitive: String

  """
  Equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  notDistinctFromInsensitive: String

  """Included in the specified list (case-insensitive)."""
  inInsensitive: [String!]

  """Not included in the specified list (case-insensitive)."""
  notInInsensitive: [String!]

  """Less than the specified value (case-insensitive)."""
  lessThanInsensitive: String

  """Less than or equal to the specified value (case-insensitive)."""
  lessThanOrEqualToInsensitive: String

  """Greater than the specified value (case-insensitive)."""
  greaterThanInsensitive: String

  """Greater than or equal to the specified value (case-insensitive)."""
  greaterThanOrEqualToInsensitive: String
}

"""
A filter to be used against Datetime fields. All fields are combined with a logical and.
"""
input DatetimeFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Datetime

  """Not equal to the specified value."""
  notEqualTo: Datetime

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Datetime

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Datetime

  """Included in the specified list."""
  in: [Datetime!]

  """Not included in the specified list."""
  notIn: [Datetime!]

  """Less than the specified value."""
  lessThan: Datetime

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Datetime

  """Greater than the specified value."""
  greaterThan: Datetime

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Datetime
}

"""
A filter to be used against Int fields. All fields are combined with a logical and.
"""
input IntFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Int

  """Not equal to the specified value."""
  notEqualTo: Int

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Int

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Int

  """Included in the specified list."""
  in: [Int!]

  """Not included in the specified list."""
  notIn: [Int!]

  """Less than the specified value."""
  lessThan: Int

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Int

  """Greater than the specified value."""
  greaterThan: Int

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Int
}

"""
A filter to be used against Boolean fields. All fields are combined with a logical and.
"""
input BooleanFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Boolean

  """Not equal to the specified value."""
  notEqualTo: Boolean

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Boolean

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Boolean

  """Included in the specified list."""
  in: [Boolean!]

  """Not included in the specified list."""
  notIn: [Boolean!]

  """Less than the specified value."""
  lessThan: Boolean

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Boolean

  """Greater than the specified value."""
  greaterThan: Boolean

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Boolean
}

"""
A filter to be used against many `Column` object types. All fields are combined with a logical and.
"""
input ProjectToManyColumnFilter {
  """
  Every related `Column` matches the filter criteria. All fields are combined with a logical and.
  """
  every: ColumnFilter

  """
  Some related `Column` matches the filter criteria. All fields are combined with a logical and.
  """
  some: ColumnFilter

  """
  No related `Column` matches the filter criteria. All fields are combined with a logical and.
  """
  none: ColumnFilter

  """Aggregates across related `Column` match the filter criteria."""
  aggregates: ColumnAggregatesFilter
}

"""
A filter to be used against `Column` object types. All fields are combined with a logical and.
"""
input ColumnFilter {
  """Filter by the objects `rowId` field."""
  rowId: UUIDFilter

  """Filter by the objects `title` field."""
  title: StringFilter

  """Filter by the objects `projectId` field."""
  projectId: UUIDFilter

  """Filter by the objects `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the objects `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects `index` field."""
  index: IntFilter

  """Filter by the objects `icon` field."""
  icon: StringFilter

  """Filter by the objects `tasks` relation."""
  tasks: ColumnToManyTaskFilter

  """Some related `tasks` exist."""
  tasksExist: Boolean

  """Filter by the objects `project` relation."""
  project: ProjectFilter

  """Checks for all expressions in this list."""
  and: [ColumnFilter!]

  """Checks for any expressions in this list."""
  or: [ColumnFilter!]

  """Negates the expression."""
  not: ColumnFilter
}

"""
A filter to be used against many `Task` object types. All fields are combined with a logical and.
"""
input ColumnToManyTaskFilter {
  """
  Every related `Task` matches the filter criteria. All fields are combined with a logical and.
  """
  every: TaskFilter

  """
  Some related `Task` matches the filter criteria. All fields are combined with a logical and.
  """
  some: TaskFilter

  """
  No related `Task` matches the filter criteria. All fields are combined with a logical and.
  """
  none: TaskFilter

  """Aggregates across related `Task` match the filter criteria."""
  aggregates: TaskAggregatesFilter
}

"""
A filter to be used against `Task` object types. All fields are combined with a logical and.
"""
input TaskFilter {
  """Filter by the objects `rowId` field."""
  rowId: UUIDFilter

  """Filter by the objects `content` field."""
  content: StringFilter

  """Filter by the objects `description` field."""
  description: StringFilter

  """Filter by the objects `priority` field."""
  priority: StringFilter

  """Filter by the objects `authorId` field."""
  authorId: UUIDFilter

  """Filter by the objects `columnId` field."""
  columnId: UUIDFilter

  """Filter by the objects `dueDate` field."""
  dueDate: DatetimeFilter

  """Filter by the objects `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the objects `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects `columnIndex` field."""
  columnIndex: IntFilter

  """Filter by the objects `projectId` field."""
  projectId: UUIDFilter

  """Filter by the objects `number` field."""
  number: IntFilter

  """Filter by the objects `assignees` relation."""
  assignees: TaskToManyAssigneeFilter

  """Some related `assignees` exist."""
  assigneesExist: Boolean

  """Filter by the objects `posts` relation."""
  posts: TaskToManyPostFilter

  """Some related `posts` exist."""
  postsExist: Boolean

  """Filter by the objects `taskLabels` relation."""
  taskLabels: TaskToManyTaskLabelFilter

  """Some related `taskLabels` exist."""
  taskLabelsExist: Boolean

  """Filter by the objects `author` relation."""
  author: UserFilter

  """A related `author` exists."""
  authorExists: Boolean

  """Filter by the objects `column` relation."""
  column: ColumnFilter

  """Filter by the objects `project` relation."""
  project: ProjectFilter

  """Checks for all expressions in this list."""
  and: [TaskFilter!]

  """Checks for any expressions in this list."""
  or: [TaskFilter!]

  """Negates the expression."""
  not: TaskFilter
}

"""
A filter to be used against many `Assignee` object types. All fields are combined with a logical and.
"""
input TaskToManyAssigneeFilter {
  """
  Every related `Assignee` matches the filter criteria. All fields are combined with a logical and.
  """
  every: AssigneeFilter

  """
  Some related `Assignee` matches the filter criteria. All fields are combined with a logical and.
  """
  some: AssigneeFilter

  """
  No related `Assignee` matches the filter criteria. All fields are combined with a logical and.
  """
  none: AssigneeFilter

  """Aggregates across related `Assignee` match the filter criteria."""
  aggregates: AssigneeAggregatesFilter
}

"""
A filter to be used against `Assignee` object types. All fields are combined with a logical and.
"""
input AssigneeFilter {
  """Filter by the objects `userId` field."""
  userId: UUIDFilter

  """Filter by the objects `taskId` field."""
  taskId: UUIDFilter

  """Filter by the objects `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the objects `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects `deletedAt` field."""
  deletedAt: DatetimeFilter

  """Filter by the objects `task` relation."""
  task: TaskFilter

  """Filter by the objects `user` relation."""
  user: UserFilter

  """Checks for all expressions in this list."""
  and: [AssigneeFilter!]

  """Checks for any expressions in this list."""
  or: [AssigneeFilter!]

  """Negates the expression."""
  not: AssigneeFilter
}

"""
A filter to be used against `User` object types. All fields are combined with a logical and.
"""
input UserFilter {
  """Filter by the objects `rowId` field."""
  rowId: UUIDFilter

  """Filter by the objects `identityProviderId` field."""
  identityProviderId: UUIDFilter

  """Filter by the objects `name` field."""
  name: StringFilter

  """Filter by the objects `avatarUrl` field."""
  avatarUrl: StringFilter

  """Filter by the objects `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the objects `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects `email` field."""
  email: StringFilter

  """Filter by the objects `assignees` relation."""
  assignees: UserToManyAssigneeFilter

  """Some related `assignees` exist."""
  assigneesExist: Boolean

  """Filter by the objects `authoredPosts` relation."""
  authoredPosts: UserToManyPostFilter

  """Some related `authoredPosts` exist."""
  authoredPostsExist: Boolean

  """Filter by the objects `authoredTasks` relation."""
  authoredTasks: UserToManyTaskFilter

  """Some related `authoredTasks` exist."""
  authoredTasksExist: Boolean

  """Filter by the objects `userPreferences` relation."""
  userPreferences: UserToManyUserPreferenceFilter

  """Some related `userPreferences` exist."""
  userPreferencesExist: Boolean

  """Filter by the objects `emojis` relation."""
  emojis: UserToManyEmojiFilter

  """Some related `emojis` exist."""
  emojisExist: Boolean

  """Filter by the objects `userOrganizations` relation."""
  userOrganizations: UserToManyUserOrganizationFilter

  """Some related `userOrganizations` exist."""
  userOrganizationsExist: Boolean

  """Filter by the objects `agentActivities` relation."""
  agentActivities: UserToManyAgentActivityFilter

  """Some related `agentActivities` exist."""
  agentActivitiesExist: Boolean

  """Filter by the objects `agentSessions` relation."""
  agentSessions: UserToManyAgentSessionFilter

  """Some related `agentSessions` exist."""
  agentSessionsExist: Boolean

  """Checks for all expressions in this list."""
  and: [UserFilter!]

  """Checks for any expressions in this list."""
  or: [UserFilter!]

  """Negates the expression."""
  not: UserFilter
}

"""
A filter to be used against many `Assignee` object types. All fields are combined with a logical and.
"""
input UserToManyAssigneeFilter {
  """
  Every related `Assignee` matches the filter criteria. All fields are combined with a logical and.
  """
  every: AssigneeFilter

  """
  Some related `Assignee` matches the filter criteria. All fields are combined with a logical and.
  """
  some: AssigneeFilter

  """
  No related `Assignee` matches the filter criteria. All fields are combined with a logical and.
  """
  none: AssigneeFilter

  """Aggregates across related `Assignee` match the filter criteria."""
  aggregates: AssigneeAggregatesFilter
}

"""A filter to be used against aggregates of `Assignee` object types."""
input AssigneeAggregatesFilter {
  """
  A filter that must pass for the relevant `Assignee` object to be included within the aggregate.
  """
  filter: AssigneeFilter

  """Distinct count aggregate over matching `Assignee` objects."""
  distinctCount: AssigneeDistinctCountAggregateFilter
}

input AssigneeDistinctCountAggregateFilter {
  userId: BigIntFilter
  taskId: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
  deletedAt: BigIntFilter
}

"""
A filter to be used against BigInt fields. All fields are combined with a logical and.
"""
input BigIntFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: BigInt

  """Not equal to the specified value."""
  notEqualTo: BigInt

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: BigInt

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: BigInt

  """Included in the specified list."""
  in: [BigInt!]

  """Not included in the specified list."""
  notIn: [BigInt!]

  """Less than the specified value."""
  lessThan: BigInt

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: BigInt

  """Greater than the specified value."""
  greaterThan: BigInt

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: BigInt
}

"""
A filter to be used against many `Post` object types. All fields are combined with a logical and.
"""
input UserToManyPostFilter {
  """
  Every related `Post` matches the filter criteria. All fields are combined with a logical and.
  """
  every: PostFilter

  """
  Some related `Post` matches the filter criteria. All fields are combined with a logical and.
  """
  some: PostFilter

  """
  No related `Post` matches the filter criteria. All fields are combined with a logical and.
  """
  none: PostFilter

  """Aggregates across related `Post` match the filter criteria."""
  aggregates: PostAggregatesFilter
}

"""
A filter to be used against `Post` object types. All fields are combined with a logical and.
"""
input PostFilter {
  """Filter by the objects `rowId` field."""
  rowId: UUIDFilter

  """Filter by the objects `title` field."""
  title: StringFilter

  """Filter by the objects `description` field."""
  description: StringFilter

  """Filter by the objects `authorId` field."""
  authorId: UUIDFilter

  """Filter by the objects `taskId` field."""
  taskId: UUIDFilter

  """Filter by the objects `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the objects `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects `emojis` relation."""
  emojis: PostToManyEmojiFilter

  """Some related `emojis` exist."""
  emojisExist: Boolean

  """Filter by the objects `author` relation."""
  author: UserFilter

  """A related `author` exists."""
  authorExists: Boolean

  """Filter by the objects `task` relation."""
  task: TaskFilter

  """Checks for all expressions in this list."""
  and: [PostFilter!]

  """Checks for any expressions in this list."""
  or: [PostFilter!]

  """Negates the expression."""
  not: PostFilter
}

"""
A filter to be used against many `Emoji` object types. All fields are combined with a logical and.
"""
input PostToManyEmojiFilter {
  """
  Every related `Emoji` matches the filter criteria. All fields are combined with a logical and.
  """
  every: EmojiFilter

  """
  Some related `Emoji` matches the filter criteria. All fields are combined with a logical and.
  """
  some: EmojiFilter

  """
  No related `Emoji` matches the filter criteria. All fields are combined with a logical and.
  """
  none: EmojiFilter

  """Aggregates across related `Emoji` match the filter criteria."""
  aggregates: EmojiAggregatesFilter
}

"""
A filter to be used against `Emoji` object types. All fields are combined with a logical and.
"""
input EmojiFilter {
  """Filter by the objects `rowId` field."""
  rowId: UUIDFilter

  """Filter by the objects `emoji` field."""
  emoji: StringFilter

  """Filter by the objects `postId` field."""
  postId: UUIDFilter

  """Filter by the objects `userId` field."""
  userId: UUIDFilter

  """Filter by the objects `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the objects `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects `post` relation."""
  post: PostFilter

  """Filter by the objects `user` relation."""
  user: UserFilter

  """Checks for all expressions in this list."""
  and: [EmojiFilter!]

  """Checks for any expressions in this list."""
  or: [EmojiFilter!]

  """Negates the expression."""
  not: EmojiFilter
}

"""A filter to be used against aggregates of `Emoji` object types."""
input EmojiAggregatesFilter {
  """
  A filter that must pass for the relevant `Emoji` object to be included within the aggregate.
  """
  filter: EmojiFilter

  """Distinct count aggregate over matching `Emoji` objects."""
  distinctCount: EmojiDistinctCountAggregateFilter
}

input EmojiDistinctCountAggregateFilter {
  rowId: BigIntFilter
  emoji: BigIntFilter
  postId: BigIntFilter
  userId: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
}

"""A filter to be used against aggregates of `Post` object types."""
input PostAggregatesFilter {
  """
  A filter that must pass for the relevant `Post` object to be included within the aggregate.
  """
  filter: PostFilter

  """Distinct count aggregate over matching `Post` objects."""
  distinctCount: PostDistinctCountAggregateFilter
}

input PostDistinctCountAggregateFilter {
  rowId: BigIntFilter
  title: BigIntFilter
  description: BigIntFilter
  authorId: BigIntFilter
  taskId: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
}

"""
A filter to be used against many `Task` object types. All fields are combined with a logical and.
"""
input UserToManyTaskFilter {
  """
  Every related `Task` matches the filter criteria. All fields are combined with a logical and.
  """
  every: TaskFilter

  """
  Some related `Task` matches the filter criteria. All fields are combined with a logical and.
  """
  some: TaskFilter

  """
  No related `Task` matches the filter criteria. All fields are combined with a logical and.
  """
  none: TaskFilter

  """Aggregates across related `Task` match the filter criteria."""
  aggregates: TaskAggregatesFilter
}

"""A filter to be used against aggregates of `Task` object types."""
input TaskAggregatesFilter {
  """
  A filter that must pass for the relevant `Task` object to be included within the aggregate.
  """
  filter: TaskFilter

  """Sum aggregate over matching `Task` objects."""
  sum: TaskSumAggregateFilter

  """Distinct count aggregate over matching `Task` objects."""
  distinctCount: TaskDistinctCountAggregateFilter

  """Minimum aggregate over matching `Task` objects."""
  min: TaskMinAggregateFilter

  """Maximum aggregate over matching `Task` objects."""
  max: TaskMaxAggregateFilter

  """Mean average aggregate over matching `Task` objects."""
  average: TaskAverageAggregateFilter

  """Sample standard deviation aggregate over matching `Task` objects."""
  stddevSample: TaskStddevSampleAggregateFilter

  """Population standard deviation aggregate over matching `Task` objects."""
  stddevPopulation: TaskStddevPopulationAggregateFilter

  """Sample variance aggregate over matching `Task` objects."""
  varianceSample: TaskVarianceSampleAggregateFilter

  """Population variance aggregate over matching `Task` objects."""
  variancePopulation: TaskVariancePopulationAggregateFilter
}

input TaskSumAggregateFilter {
  columnIndex: BigIntFilter
  number: BigIntFilter
}

input TaskDistinctCountAggregateFilter {
  rowId: BigIntFilter
  content: BigIntFilter
  description: BigIntFilter
  priority: BigIntFilter
  authorId: BigIntFilter
  columnId: BigIntFilter
  dueDate: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
  columnIndex: BigIntFilter
  projectId: BigIntFilter
  number: BigIntFilter
}

input TaskMinAggregateFilter {
  columnIndex: IntFilter
  number: IntFilter
}

input TaskMaxAggregateFilter {
  columnIndex: IntFilter
  number: IntFilter
}

input TaskAverageAggregateFilter {
  columnIndex: BigFloatFilter
  number: BigFloatFilter
}

"""
A filter to be used against BigFloat fields. All fields are combined with a logical and.
"""
input BigFloatFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: BigFloat

  """Not equal to the specified value."""
  notEqualTo: BigFloat

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: BigFloat

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: BigFloat

  """Included in the specified list."""
  in: [BigFloat!]

  """Not included in the specified list."""
  notIn: [BigFloat!]

  """Less than the specified value."""
  lessThan: BigFloat

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: BigFloat

  """Greater than the specified value."""
  greaterThan: BigFloat

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: BigFloat
}

input TaskStddevSampleAggregateFilter {
  columnIndex: BigFloatFilter
  number: BigFloatFilter
}

input TaskStddevPopulationAggregateFilter {
  columnIndex: BigFloatFilter
  number: BigFloatFilter
}

input TaskVarianceSampleAggregateFilter {
  columnIndex: BigFloatFilter
  number: BigFloatFilter
}

input TaskVariancePopulationAggregateFilter {
  columnIndex: BigFloatFilter
  number: BigFloatFilter
}

"""
A filter to be used against many `UserPreference` object types. All fields are combined with a logical and.
"""
input UserToManyUserPreferenceFilter {
  """
  Every related `UserPreference` matches the filter criteria. All fields are combined with a logical and.
  """
  every: UserPreferenceFilter

  """
  Some related `UserPreference` matches the filter criteria. All fields are combined with a logical and.
  """
  some: UserPreferenceFilter

  """
  No related `UserPreference` matches the filter criteria. All fields are combined with a logical and.
  """
  none: UserPreferenceFilter

  """Aggregates across related `UserPreference` match the filter criteria."""
  aggregates: UserPreferenceAggregatesFilter
}

"""
A filter to be used against `UserPreference` object types. All fields are combined with a logical and.
"""
input UserPreferenceFilter {
  """Filter by the objects `rowId` field."""
  rowId: UUIDFilter

  """Filter by the objects `userId` field."""
  userId: UUIDFilter

  """Filter by the objects `projectId` field."""
  projectId: UUIDFilter

  """Filter by the objects `hiddenColumnIds` field."""
  hiddenColumnIds: StringListFilter

  """Filter by the objects `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the objects `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects `viewMode` field."""
  viewMode: StringFilter

  """Filter by the objects `color` field."""
  color: StringFilter

  """Filter by the objects `project` relation."""
  project: ProjectFilter

  """Filter by the objects `user` relation."""
  user: UserFilter

  """Checks for all expressions in this list."""
  and: [UserPreferenceFilter!]

  """Checks for any expressions in this list."""
  or: [UserPreferenceFilter!]

  """Negates the expression."""
  not: UserPreferenceFilter
}

"""
A filter to be used against String List fields. All fields are combined with a logical and.
"""
input StringListFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: [String]

  """Not equal to the specified value."""
  notEqualTo: [String]

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: [String]

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: [String]

  """Less than the specified value."""
  lessThan: [String]

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: [String]

  """Greater than the specified value."""
  greaterThan: [String]

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: [String]

  """Contains the specified list of values."""
  contains: [String]

  """Contained by the specified list of values."""
  containedBy: [String]

  """Overlaps the specified list of values."""
  overlaps: [String]

  """Any array item is equal to the specified value."""
  anyEqualTo: String

  """Any array item is not equal to the specified value."""
  anyNotEqualTo: String

  """Any array item is less than the specified value."""
  anyLessThan: String

  """Any array item is less than or equal to the specified value."""
  anyLessThanOrEqualTo: String

  """Any array item is greater than the specified value."""
  anyGreaterThan: String

  """Any array item is greater than or equal to the specified value."""
  anyGreaterThanOrEqualTo: String
}

"""
A filter to be used against aggregates of `UserPreference` object types.
"""
input UserPreferenceAggregatesFilter {
  """
  A filter that must pass for the relevant `UserPreference` object to be included within the aggregate.
  """
  filter: UserPreferenceFilter

  """Distinct count aggregate over matching `UserPreference` objects."""
  distinctCount: UserPreferenceDistinctCountAggregateFilter
}

input UserPreferenceDistinctCountAggregateFilter {
  rowId: BigIntFilter
  userId: BigIntFilter
  projectId: BigIntFilter
  hiddenColumnIds: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
  viewMode: BigIntFilter
  color: BigIntFilter
}

"""
A filter to be used against many `Emoji` object types. All fields are combined with a logical and.
"""
input UserToManyEmojiFilter {
  """
  Every related `Emoji` matches the filter criteria. All fields are combined with a logical and.
  """
  every: EmojiFilter

  """
  Some related `Emoji` matches the filter criteria. All fields are combined with a logical and.
  """
  some: EmojiFilter

  """
  No related `Emoji` matches the filter criteria. All fields are combined with a logical and.
  """
  none: EmojiFilter

  """Aggregates across related `Emoji` match the filter criteria."""
  aggregates: EmojiAggregatesFilter
}

"""
A filter to be used against many `UserOrganization` object types. All fields are combined with a logical and.
"""
input UserToManyUserOrganizationFilter {
  """
  Every related `UserOrganization` matches the filter criteria. All fields are combined with a logical and.
  """
  every: UserOrganizationFilter

  """
  Some related `UserOrganization` matches the filter criteria. All fields are combined with a logical and.
  """
  some: UserOrganizationFilter

  """
  No related `UserOrganization` matches the filter criteria. All fields are combined with a logical and.
  """
  none: UserOrganizationFilter

  """
  Aggregates across related `UserOrganization` match the filter criteria.
  """
  aggregates: UserOrganizationAggregatesFilter
}

"""
A filter to be used against `UserOrganization` object types. All fields are combined with a logical and.
"""
input UserOrganizationFilter {
  """Filter by the objects `rowId` field."""
  rowId: UUIDFilter

  """Filter by the objects `userId` field."""
  userId: UUIDFilter

  """Filter by the objects `organizationId` field."""
  organizationId: StringFilter

  """Filter by the objects `slug` field."""
  slug: StringFilter

  """Filter by the objects `name` field."""
  name: StringFilter

  """Filter by the objects `type` field."""
  type: OrganizationTypeFilter

  """Filter by the objects `role` field."""
  role: MemberRoleFilter

  """Filter by the objects `syncedAt` field."""
  syncedAt: DatetimeFilter

  """Filter by the objects `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the objects `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects `user` relation."""
  user: UserFilter

  """Checks for all expressions in this list."""
  and: [UserOrganizationFilter!]

  """Checks for any expressions in this list."""
  or: [UserOrganizationFilter!]

  """Negates the expression."""
  not: UserOrganizationFilter
}

"""
A filter to be used against OrganizationType fields. All fields are combined with a logical and.
"""
input OrganizationTypeFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: OrganizationType

  """Not equal to the specified value."""
  notEqualTo: OrganizationType

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: OrganizationType

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: OrganizationType

  """Included in the specified list."""
  in: [OrganizationType!]

  """Not included in the specified list."""
  notIn: [OrganizationType!]

  """Less than the specified value."""
  lessThan: OrganizationType

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: OrganizationType

  """Greater than the specified value."""
  greaterThan: OrganizationType

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: OrganizationType
}

enum OrganizationType {
  personal
  team
}

"""
A filter to be used against MemberRole fields. All fields are combined with a logical and.
"""
input MemberRoleFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: MemberRole

  """Not equal to the specified value."""
  notEqualTo: MemberRole

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: MemberRole

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: MemberRole

  """Included in the specified list."""
  in: [MemberRole!]

  """Not included in the specified list."""
  notIn: [MemberRole!]

  """Less than the specified value."""
  lessThan: MemberRole

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: MemberRole

  """Greater than the specified value."""
  greaterThan: MemberRole

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: MemberRole
}

enum MemberRole {
  owner
  admin
  member
}

"""
A filter to be used against aggregates of `UserOrganization` object types.
"""
input UserOrganizationAggregatesFilter {
  """
  A filter that must pass for the relevant `UserOrganization` object to be included within the aggregate.
  """
  filter: UserOrganizationFilter

  """Distinct count aggregate over matching `UserOrganization` objects."""
  distinctCount: UserOrganizationDistinctCountAggregateFilter
}

input UserOrganizationDistinctCountAggregateFilter {
  rowId: BigIntFilter
  userId: BigIntFilter
  organizationId: BigIntFilter
  slug: BigIntFilter
  name: BigIntFilter
  type: BigIntFilter
  role: BigIntFilter
  syncedAt: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
}

"""
A filter to be used against many `AgentActivity` object types. All fields are combined with a logical and.
"""
input UserToManyAgentActivityFilter {
  """
  Every related `AgentActivity` matches the filter criteria. All fields are combined with a logical and.
  """
  every: AgentActivityFilter

  """
  Some related `AgentActivity` matches the filter criteria. All fields are combined with a logical and.
  """
  some: AgentActivityFilter

  """
  No related `AgentActivity` matches the filter criteria. All fields are combined with a logical and.
  """
  none: AgentActivityFilter

  """Aggregates across related `AgentActivity` match the filter criteria."""
  aggregates: AgentActivityAggregatesFilter
}

"""
A filter to be used against `AgentActivity` object types. All fields are combined with a logical and.
"""
input AgentActivityFilter {
  """Filter by the objects `rowId` field."""
  rowId: UUIDFilter

  """Filter by the objects `organizationId` field."""
  organizationId: StringFilter

  """Filter by the objects `projectId` field."""
  projectId: UUIDFilter

  """Filter by the objects `sessionId` field."""
  sessionId: UUIDFilter

  """Filter by the objects `userId` field."""
  userId: UUIDFilter

  """Filter by the objects `toolName` field."""
  toolName: StringFilter

  """Filter by the objects `requiresApproval` field."""
  requiresApproval: BooleanFilter

  """Filter by the objects `approvalStatus` field."""
  approvalStatus: StringFilter

  """Filter by the objects `status` field."""
  status: StringFilter

  """Filter by the objects `errorMessage` field."""
  errorMessage: StringFilter

  """Filter by the objects `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the objects `project` relation."""
  project: ProjectFilter

  """Filter by the objects `session` relation."""
  session: AgentSessionFilter

  """Filter by the objects `user` relation."""
  user: UserFilter

  """Checks for all expressions in this list."""
  and: [AgentActivityFilter!]

  """Checks for any expressions in this list."""
  or: [AgentActivityFilter!]

  """Negates the expression."""
  not: AgentActivityFilter
}

"""
A filter to be used against `AgentSession` object types. All fields are combined with a logical and.
"""
input AgentSessionFilter {
  """Filter by the objects `rowId` field."""
  rowId: UUIDFilter

  """Filter by the objects `organizationId` field."""
  organizationId: StringFilter

  """Filter by the objects `projectId` field."""
  projectId: UUIDFilter

  """Filter by the objects `userId` field."""
  userId: UUIDFilter

  """Filter by the objects `title` field."""
  title: StringFilter

  """Filter by the objects `totalTokensUsed` field."""
  totalTokensUsed: IntFilter

  """Filter by the objects `toolCallCount` field."""
  toolCallCount: IntFilter

  """Filter by the objects `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the objects `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects `type` field."""
  type: StringFilter

  """Filter by the objects `agentActivitiesBySessionId` relation."""
  agentActivitiesBySessionId: AgentSessionToManyAgentActivityFilter

  """Some related `agentActivitiesBySessionId` exist."""
  agentActivitiesBySessionIdExist: Boolean

  """Filter by the objects `project` relation."""
  project: ProjectFilter

  """A related `project` exists."""
  projectExists: Boolean

  """Filter by the objects `user` relation."""
  user: UserFilter

  """Checks for all expressions in this list."""
  and: [AgentSessionFilter!]

  """Checks for any expressions in this list."""
  or: [AgentSessionFilter!]

  """Negates the expression."""
  not: AgentSessionFilter
}

"""
A filter to be used against many `AgentActivity` object types. All fields are combined with a logical and.
"""
input AgentSessionToManyAgentActivityFilter {
  """
  Every related `AgentActivity` matches the filter criteria. All fields are combined with a logical and.
  """
  every: AgentActivityFilter

  """
  Some related `AgentActivity` matches the filter criteria. All fields are combined with a logical and.
  """
  some: AgentActivityFilter

  """
  No related `AgentActivity` matches the filter criteria. All fields are combined with a logical and.
  """
  none: AgentActivityFilter

  """Aggregates across related `AgentActivity` match the filter criteria."""
  aggregates: AgentActivityAggregatesFilter
}

"""
A filter to be used against aggregates of `AgentActivity` object types.
"""
input AgentActivityAggregatesFilter {
  """
  A filter that must pass for the relevant `AgentActivity` object to be included within the aggregate.
  """
  filter: AgentActivityFilter

  """Distinct count aggregate over matching `AgentActivity` objects."""
  distinctCount: AgentActivityDistinctCountAggregateFilter
}

input AgentActivityDistinctCountAggregateFilter {
  rowId: BigIntFilter
  organizationId: BigIntFilter
  projectId: BigIntFilter
  sessionId: BigIntFilter
  userId: BigIntFilter
  toolName: BigIntFilter
  toolInput: BigIntFilter
  toolOutput: BigIntFilter
  requiresApproval: BigIntFilter
  approvalStatus: BigIntFilter
  status: BigIntFilter
  errorMessage: BigIntFilter
  affectedTaskIds: BigIntFilter
  createdAt: BigIntFilter
  snapshotBefore: BigIntFilter
}

"""
A filter to be used against many `AgentSession` object types. All fields are combined with a logical and.
"""
input UserToManyAgentSessionFilter {
  """
  Every related `AgentSession` matches the filter criteria. All fields are combined with a logical and.
  """
  every: AgentSessionFilter

  """
  Some related `AgentSession` matches the filter criteria. All fields are combined with a logical and.
  """
  some: AgentSessionFilter

  """
  No related `AgentSession` matches the filter criteria. All fields are combined with a logical and.
  """
  none: AgentSessionFilter

  """Aggregates across related `AgentSession` match the filter criteria."""
  aggregates: AgentSessionAggregatesFilter
}

"""A filter to be used against aggregates of `AgentSession` object types."""
input AgentSessionAggregatesFilter {
  """
  A filter that must pass for the relevant `AgentSession` object to be included within the aggregate.
  """
  filter: AgentSessionFilter

  """Sum aggregate over matching `AgentSession` objects."""
  sum: AgentSessionSumAggregateFilter

  """Distinct count aggregate over matching `AgentSession` objects."""
  distinctCount: AgentSessionDistinctCountAggregateFilter

  """Minimum aggregate over matching `AgentSession` objects."""
  min: AgentSessionMinAggregateFilter

  """Maximum aggregate over matching `AgentSession` objects."""
  max: AgentSessionMaxAggregateFilter

  """Mean average aggregate over matching `AgentSession` objects."""
  average: AgentSessionAverageAggregateFilter

  """
  Sample standard deviation aggregate over matching `AgentSession` objects.
  """
  stddevSample: AgentSessionStddevSampleAggregateFilter

  """
  Population standard deviation aggregate over matching `AgentSession` objects.
  """
  stddevPopulation: AgentSessionStddevPopulationAggregateFilter

  """Sample variance aggregate over matching `AgentSession` objects."""
  varianceSample: AgentSessionVarianceSampleAggregateFilter

  """Population variance aggregate over matching `AgentSession` objects."""
  variancePopulation: AgentSessionVariancePopulationAggregateFilter
}

input AgentSessionSumAggregateFilter {
  totalTokensUsed: BigIntFilter
  toolCallCount: BigIntFilter
}

input AgentSessionDistinctCountAggregateFilter {
  rowId: BigIntFilter
  organizationId: BigIntFilter
  projectId: BigIntFilter
  userId: BigIntFilter
  title: BigIntFilter
  messages: BigIntFilter
  totalTokensUsed: BigIntFilter
  toolCallCount: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
  type: BigIntFilter
}

input AgentSessionMinAggregateFilter {
  totalTokensUsed: IntFilter
  toolCallCount: IntFilter
}

input AgentSessionMaxAggregateFilter {
  totalTokensUsed: IntFilter
  toolCallCount: IntFilter
}

input AgentSessionAverageAggregateFilter {
  totalTokensUsed: BigFloatFilter
  toolCallCount: BigFloatFilter
}

input AgentSessionStddevSampleAggregateFilter {
  totalTokensUsed: BigFloatFilter
  toolCallCount: BigFloatFilter
}

input AgentSessionStddevPopulationAggregateFilter {
  totalTokensUsed: BigFloatFilter
  toolCallCount: BigFloatFilter
}

input AgentSessionVarianceSampleAggregateFilter {
  totalTokensUsed: BigFloatFilter
  toolCallCount: BigFloatFilter
}

input AgentSessionVariancePopulationAggregateFilter {
  totalTokensUsed: BigFloatFilter
  toolCallCount: BigFloatFilter
}

"""
A filter to be used against many `Post` object types. All fields are combined with a logical and.
"""
input TaskToManyPostFilter {
  """
  Every related `Post` matches the filter criteria. All fields are combined with a logical and.
  """
  every: PostFilter

  """
  Some related `Post` matches the filter criteria. All fields are combined with a logical and.
  """
  some: PostFilter

  """
  No related `Post` matches the filter criteria. All fields are combined with a logical and.
  """
  none: PostFilter

  """Aggregates across related `Post` match the filter criteria."""
  aggregates: PostAggregatesFilter
}

"""
A filter to be used against many `TaskLabel` object types. All fields are combined with a logical and.
"""
input TaskToManyTaskLabelFilter {
  """
  Every related `TaskLabel` matches the filter criteria. All fields are combined with a logical and.
  """
  every: TaskLabelFilter

  """
  Some related `TaskLabel` matches the filter criteria. All fields are combined with a logical and.
  """
  some: TaskLabelFilter

  """
  No related `TaskLabel` matches the filter criteria. All fields are combined with a logical and.
  """
  none: TaskLabelFilter

  """Aggregates across related `TaskLabel` match the filter criteria."""
  aggregates: TaskLabelAggregatesFilter
}

"""
A filter to be used against `TaskLabel` object types. All fields are combined with a logical and.
"""
input TaskLabelFilter {
  """Filter by the objects `taskId` field."""
  taskId: UUIDFilter

  """Filter by the objects `labelId` field."""
  labelId: UUIDFilter

  """Filter by the objects `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the objects `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects `label` relation."""
  label: LabelFilter

  """Filter by the objects `task` relation."""
  task: TaskFilter

  """Checks for all expressions in this list."""
  and: [TaskLabelFilter!]

  """Checks for any expressions in this list."""
  or: [TaskLabelFilter!]

  """Negates the expression."""
  not: TaskLabelFilter
}

"""
A filter to be used against `Label` object types. All fields are combined with a logical and.
"""
input LabelFilter {
  """Filter by the objects `rowId` field."""
  rowId: UUIDFilter

  """Filter by the objects `name` field."""
  name: StringFilter

  """Filter by the objects `color` field."""
  color: StringFilter

  """Filter by the objects `projectId` field."""
  projectId: UUIDFilter

  """Filter by the objects `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the objects `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects `icon` field."""
  icon: StringFilter

  """Filter by the objects `organizationId` field."""
  organizationId: StringFilter

  """Filter by the objects `taskLabels` relation."""
  taskLabels: LabelToManyTaskLabelFilter

  """Some related `taskLabels` exist."""
  taskLabelsExist: Boolean

  """Filter by the objects `project` relation."""
  project: ProjectFilter

  """A related `project` exists."""
  projectExists: Boolean

  """Checks for all expressions in this list."""
  and: [LabelFilter!]

  """Checks for any expressions in this list."""
  or: [LabelFilter!]

  """Negates the expression."""
  not: LabelFilter
}

"""
A filter to be used against many `TaskLabel` object types. All fields are combined with a logical and.
"""
input LabelToManyTaskLabelFilter {
  """
  Every related `TaskLabel` matches the filter criteria. All fields are combined with a logical and.
  """
  every: TaskLabelFilter

  """
  Some related `TaskLabel` matches the filter criteria. All fields are combined with a logical and.
  """
  some: TaskLabelFilter

  """
  No related `TaskLabel` matches the filter criteria. All fields are combined with a logical and.
  """
  none: TaskLabelFilter

  """Aggregates across related `TaskLabel` match the filter criteria."""
  aggregates: TaskLabelAggregatesFilter
}

"""A filter to be used against aggregates of `TaskLabel` object types."""
input TaskLabelAggregatesFilter {
  """
  A filter that must pass for the relevant `TaskLabel` object to be included within the aggregate.
  """
  filter: TaskLabelFilter

  """Distinct count aggregate over matching `TaskLabel` objects."""
  distinctCount: TaskLabelDistinctCountAggregateFilter
}

input TaskLabelDistinctCountAggregateFilter {
  taskId: BigIntFilter
  labelId: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
}

"""A filter to be used against aggregates of `Column` object types."""
input ColumnAggregatesFilter {
  """
  A filter that must pass for the relevant `Column` object to be included within the aggregate.
  """
  filter: ColumnFilter

  """Sum aggregate over matching `Column` objects."""
  sum: ColumnSumAggregateFilter

  """Distinct count aggregate over matching `Column` objects."""
  distinctCount: ColumnDistinctCountAggregateFilter

  """Minimum aggregate over matching `Column` objects."""
  min: ColumnMinAggregateFilter

  """Maximum aggregate over matching `Column` objects."""
  max: ColumnMaxAggregateFilter

  """Mean average aggregate over matching `Column` objects."""
  average: ColumnAverageAggregateFilter

  """Sample standard deviation aggregate over matching `Column` objects."""
  stddevSample: ColumnStddevSampleAggregateFilter

  """
  Population standard deviation aggregate over matching `Column` objects.
  """
  stddevPopulation: ColumnStddevPopulationAggregateFilter

  """Sample variance aggregate over matching `Column` objects."""
  varianceSample: ColumnVarianceSampleAggregateFilter

  """Population variance aggregate over matching `Column` objects."""
  variancePopulation: ColumnVariancePopulationAggregateFilter
}

input ColumnSumAggregateFilter {
  index: BigIntFilter
}

input ColumnDistinctCountAggregateFilter {
  rowId: BigIntFilter
  title: BigIntFilter
  projectId: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
  index: BigIntFilter
  icon: BigIntFilter
}

input ColumnMinAggregateFilter {
  index: IntFilter
}

input ColumnMaxAggregateFilter {
  index: IntFilter
}

input ColumnAverageAggregateFilter {
  index: BigFloatFilter
}

input ColumnStddevSampleAggregateFilter {
  index: BigFloatFilter
}

input ColumnStddevPopulationAggregateFilter {
  index: BigFloatFilter
}

input ColumnVarianceSampleAggregateFilter {
  index: BigFloatFilter
}

input ColumnVariancePopulationAggregateFilter {
  index: BigFloatFilter
}

"""
A filter to be used against many `Task` object types. All fields are combined with a logical and.
"""
input ProjectToManyTaskFilter {
  """
  Every related `Task` matches the filter criteria. All fields are combined with a logical and.
  """
  every: TaskFilter

  """
  Some related `Task` matches the filter criteria. All fields are combined with a logical and.
  """
  some: TaskFilter

  """
  No related `Task` matches the filter criteria. All fields are combined with a logical and.
  """
  none: TaskFilter

  """Aggregates across related `Task` match the filter criteria."""
  aggregates: TaskAggregatesFilter
}

"""
A filter to be used against many `Label` object types. All fields are combined with a logical and.
"""
input ProjectToManyLabelFilter {
  """
  Every related `Label` matches the filter criteria. All fields are combined with a logical and.
  """
  every: LabelFilter

  """
  Some related `Label` matches the filter criteria. All fields are combined with a logical and.
  """
  some: LabelFilter

  """
  No related `Label` matches the filter criteria. All fields are combined with a logical and.
  """
  none: LabelFilter

  """Aggregates across related `Label` match the filter criteria."""
  aggregates: LabelAggregatesFilter
}

"""A filter to be used against aggregates of `Label` object types."""
input LabelAggregatesFilter {
  """
  A filter that must pass for the relevant `Label` object to be included within the aggregate.
  """
  filter: LabelFilter

  """Distinct count aggregate over matching `Label` objects."""
  distinctCount: LabelDistinctCountAggregateFilter
}

input LabelDistinctCountAggregateFilter {
  rowId: BigIntFilter
  name: BigIntFilter
  color: BigIntFilter
  projectId: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
  icon: BigIntFilter
  organizationId: BigIntFilter
}

"""
A filter to be used against many `UserPreference` object types. All fields are combined with a logical and.
"""
input ProjectToManyUserPreferenceFilter {
  """
  Every related `UserPreference` matches the filter criteria. All fields are combined with a logical and.
  """
  every: UserPreferenceFilter

  """
  Some related `UserPreference` matches the filter criteria. All fields are combined with a logical and.
  """
  some: UserPreferenceFilter

  """
  No related `UserPreference` matches the filter criteria. All fields are combined with a logical and.
  """
  none: UserPreferenceFilter

  """Aggregates across related `UserPreference` match the filter criteria."""
  aggregates: UserPreferenceAggregatesFilter
}

"""
A filter to be used against many `ProjectProjectLabel` object types. All fields are combined with a logical and.
"""
input ProjectToManyProjectProjectLabelFilter {
  """
  Every related `ProjectProjectLabel` matches the filter criteria. All fields are combined with a logical and.
  """
  every: ProjectProjectLabelFilter

  """
  Some related `ProjectProjectLabel` matches the filter criteria. All fields are combined with a logical and.
  """
  some: ProjectProjectLabelFilter

  """
  No related `ProjectProjectLabel` matches the filter criteria. All fields are combined with a logical and.
  """
  none: ProjectProjectLabelFilter

  """
  Aggregates across related `ProjectProjectLabel` match the filter criteria.
  """
  aggregates: ProjectProjectLabelAggregatesFilter
}

"""
A filter to be used against `ProjectProjectLabel` object types. All fields are combined with a logical and.
"""
input ProjectProjectLabelFilter {
  """Filter by the objects `projectId` field."""
  projectId: UUIDFilter

  """Filter by the objects `projectLabelId` field."""
  projectLabelId: UUIDFilter

  """Filter by the objects `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the objects `project` relation."""
  project: ProjectFilter

  """Filter by the objects `projectLabel` relation."""
  projectLabel: ProjectLabelFilter

  """Checks for all expressions in this list."""
  and: [ProjectProjectLabelFilter!]

  """Checks for any expressions in this list."""
  or: [ProjectProjectLabelFilter!]

  """Negates the expression."""
  not: ProjectProjectLabelFilter
}

"""
A filter to be used against `ProjectLabel` object types. All fields are combined with a logical and.
"""
input ProjectLabelFilter {
  """Filter by the objects `rowId` field."""
  rowId: UUIDFilter

  """Filter by the objects `name` field."""
  name: StringFilter

  """Filter by the objects `color` field."""
  color: StringFilter

  """Filter by the objects `icon` field."""
  icon: StringFilter

  """Filter by the objects `organizationId` field."""
  organizationId: StringFilter

  """Filter by the objects `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the objects `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects `projectProjectLabels` relation."""
  projectProjectLabels: ProjectLabelToManyProjectProjectLabelFilter

  """Some related `projectProjectLabels` exist."""
  projectProjectLabelsExist: Boolean

  """Checks for all expressions in this list."""
  and: [ProjectLabelFilter!]

  """Checks for any expressions in this list."""
  or: [ProjectLabelFilter!]

  """Negates the expression."""
  not: ProjectLabelFilter
}

"""
A filter to be used against many `ProjectProjectLabel` object types. All fields are combined with a logical and.
"""
input ProjectLabelToManyProjectProjectLabelFilter {
  """
  Every related `ProjectProjectLabel` matches the filter criteria. All fields are combined with a logical and.
  """
  every: ProjectProjectLabelFilter

  """
  Some related `ProjectProjectLabel` matches the filter criteria. All fields are combined with a logical and.
  """
  some: ProjectProjectLabelFilter

  """
  No related `ProjectProjectLabel` matches the filter criteria. All fields are combined with a logical and.
  """
  none: ProjectProjectLabelFilter

  """
  Aggregates across related `ProjectProjectLabel` match the filter criteria.
  """
  aggregates: ProjectProjectLabelAggregatesFilter
}

"""
A filter to be used against aggregates of `ProjectProjectLabel` object types.
"""
input ProjectProjectLabelAggregatesFilter {
  """
  A filter that must pass for the relevant `ProjectProjectLabel` object to be included within the aggregate.
  """
  filter: ProjectProjectLabelFilter

  """Distinct count aggregate over matching `ProjectProjectLabel` objects."""
  distinctCount: ProjectProjectLabelDistinctCountAggregateFilter
}

input ProjectProjectLabelDistinctCountAggregateFilter {
  projectId: BigIntFilter
  projectLabelId: BigIntFilter
  createdAt: BigIntFilter
}

"""
A filter to be used against many `AgentActivity` object types. All fields are combined with a logical and.
"""
input ProjectToManyAgentActivityFilter {
  """
  Every related `AgentActivity` matches the filter criteria. All fields are combined with a logical and.
  """
  every: AgentActivityFilter

  """
  Some related `AgentActivity` matches the filter criteria. All fields are combined with a logical and.
  """
  some: AgentActivityFilter

  """
  No related `AgentActivity` matches the filter criteria. All fields are combined with a logical and.
  """
  none: AgentActivityFilter

  """Aggregates across related `AgentActivity` match the filter criteria."""
  aggregates: AgentActivityAggregatesFilter
}

"""
A filter to be used against many `AgentSession` object types. All fields are combined with a logical and.
"""
input ProjectToManyAgentSessionFilter {
  """
  Every related `AgentSession` matches the filter criteria. All fields are combined with a logical and.
  """
  every: AgentSessionFilter

  """
  Some related `AgentSession` matches the filter criteria. All fields are combined with a logical and.
  """
  some: AgentSessionFilter

  """
  No related `AgentSession` matches the filter criteria. All fields are combined with a logical and.
  """
  none: AgentSessionFilter

  """Aggregates across related `AgentSession` match the filter criteria."""
  aggregates: AgentSessionAggregatesFilter
}

"""
A filter to be used against many `AgentSchedule` object types. All fields are combined with a logical and.
"""
input ProjectToManyAgentScheduleFilter {
  """
  Every related `AgentSchedule` matches the filter criteria. All fields are combined with a logical and.
  """
  every: AgentScheduleFilter

  """
  Some related `AgentSchedule` matches the filter criteria. All fields are combined with a logical and.
  """
  some: AgentScheduleFilter

  """
  No related `AgentSchedule` matches the filter criteria. All fields are combined with a logical and.
  """
  none: AgentScheduleFilter

  """Aggregates across related `AgentSchedule` match the filter criteria."""
  aggregates: AgentScheduleAggregatesFilter
}

"""
A filter to be used against `AgentSchedule` object types. All fields are combined with a logical and.
"""
input AgentScheduleFilter {
  """Filter by the objects `rowId` field."""
  rowId: UUIDFilter

  """Filter by the objects `organizationId` field."""
  organizationId: StringFilter

  """Filter by the objects `projectId` field."""
  projectId: UUIDFilter

  """Filter by the objects `name` field."""
  name: StringFilter

  """Filter by the objects `cronExpression` field."""
  cronExpression: StringFilter

  """Filter by the objects `instruction` field."""
  instruction: StringFilter

  """Filter by the objects `personaId` field."""
  personaId: UUIDFilter

  """Filter by the objects `enabled` field."""
  enabled: BooleanFilter

  """Filter by the objects `lastRunAt` field."""
  lastRunAt: DatetimeFilter

  """Filter by the objects `nextRunAt` field."""
  nextRunAt: DatetimeFilter

  """Filter by the objects `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the objects `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects `persona` relation."""
  persona: AgentPersonaFilter

  """A related `persona` exists."""
  personaExists: Boolean

  """Filter by the objects `project` relation."""
  project: ProjectFilter

  """Checks for all expressions in this list."""
  and: [AgentScheduleFilter!]

  """Checks for any expressions in this list."""
  or: [AgentScheduleFilter!]

  """Negates the expression."""
  not: AgentScheduleFilter
}

"""
A filter to be used against `AgentPersona` object types. All fields are combined with a logical and.
"""
input AgentPersonaFilter {
  """Filter by the objects `rowId` field."""
  rowId: UUIDFilter

  """Filter by the objects `organizationId` field."""
  organizationId: StringFilter

  """Filter by the objects `name` field."""
  name: StringFilter

  """Filter by the objects `description` field."""
  description: StringFilter

  """Filter by the objects `systemPrompt` field."""
  systemPrompt: StringFilter

  """Filter by the objects `icon` field."""
  icon: StringFilter

  """Filter by the objects `enabled` field."""
  enabled: BooleanFilter

  """Filter by the objects `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the objects `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects `agentMarketplaceListingsByPersonaId` relation."""
  agentMarketplaceListingsByPersonaId: AgentPersonaToManyAgentMarketplaceListingFilter

  """Some related `agentMarketplaceListingsByPersonaId` exist."""
  agentMarketplaceListingsByPersonaIdExist: Boolean

  """Filter by the objects `agentSchedulesByPersonaId` relation."""
  agentSchedulesByPersonaId: AgentPersonaToManyAgentScheduleFilter

  """Some related `agentSchedulesByPersonaId` exist."""
  agentSchedulesByPersonaIdExist: Boolean

  """Checks for all expressions in this list."""
  and: [AgentPersonaFilter!]

  """Checks for any expressions in this list."""
  or: [AgentPersonaFilter!]

  """Negates the expression."""
  not: AgentPersonaFilter
}

"""
A filter to be used against many `AgentMarketplaceListing` object types. All fields are combined with a logical and.
"""
input AgentPersonaToManyAgentMarketplaceListingFilter {
  """
  Every related `AgentMarketplaceListing` matches the filter criteria. All fields are combined with a logical and.
  """
  every: AgentMarketplaceListingFilter

  """
  Some related `AgentMarketplaceListing` matches the filter criteria. All fields are combined with a logical and.
  """
  some: AgentMarketplaceListingFilter

  """
  No related `AgentMarketplaceListing` matches the filter criteria. All fields are combined with a logical and.
  """
  none: AgentMarketplaceListingFilter

  """
  Aggregates across related `AgentMarketplaceListing` match the filter criteria.
  """
  aggregates: AgentMarketplaceListingAggregatesFilter
}

"""
A filter to be used against `AgentMarketplaceListing` object types. All fields are combined with a logical and.
"""
input AgentMarketplaceListingFilter {
  """Filter by the objects `rowId` field."""
  rowId: UUIDFilter

  """Filter by the objects `personaId` field."""
  personaId: UUIDFilter

  """Filter by the objects `organizationId` field."""
  organizationId: StringFilter

  """Filter by the objects `title` field."""
  title: StringFilter

  """Filter by the objects `description` field."""
  description: StringFilter

  """Filter by the objects `category` field."""
  category: StringFilter

  """Filter by the objects `installCount` field."""
  installCount: IntFilter

  """Filter by the objects `publishedAt` field."""
  publishedAt: DatetimeFilter

  """Filter by the objects `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the objects `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects `persona` relation."""
  persona: AgentPersonaFilter

  """Checks for all expressions in this list."""
  and: [AgentMarketplaceListingFilter!]

  """Checks for any expressions in this list."""
  or: [AgentMarketplaceListingFilter!]

  """Negates the expression."""
  not: AgentMarketplaceListingFilter
}

"""
A filter to be used against aggregates of `AgentMarketplaceListing` object types.
"""
input AgentMarketplaceListingAggregatesFilter {
  """
  A filter that must pass for the relevant `AgentMarketplaceListing` object to be included within the aggregate.
  """
  filter: AgentMarketplaceListingFilter

  """Sum aggregate over matching `AgentMarketplaceListing` objects."""
  sum: AgentMarketplaceListingSumAggregateFilter

  """
  Distinct count aggregate over matching `AgentMarketplaceListing` objects.
  """
  distinctCount: AgentMarketplaceListingDistinctCountAggregateFilter

  """Minimum aggregate over matching `AgentMarketplaceListing` objects."""
  min: AgentMarketplaceListingMinAggregateFilter

  """Maximum aggregate over matching `AgentMarketplaceListing` objects."""
  max: AgentMarketplaceListingMaxAggregateFilter

  """
  Mean average aggregate over matching `AgentMarketplaceListing` objects.
  """
  average: AgentMarketplaceListingAverageAggregateFilter

  """
  Sample standard deviation aggregate over matching `AgentMarketplaceListing` objects.
  """
  stddevSample: AgentMarketplaceListingStddevSampleAggregateFilter

  """
  Population standard deviation aggregate over matching `AgentMarketplaceListing` objects.
  """
  stddevPopulation: AgentMarketplaceListingStddevPopulationAggregateFilter

  """
  Sample variance aggregate over matching `AgentMarketplaceListing` objects.
  """
  varianceSample: AgentMarketplaceListingVarianceSampleAggregateFilter

  """
  Population variance aggregate over matching `AgentMarketplaceListing` objects.
  """
  variancePopulation: AgentMarketplaceListingVariancePopulationAggregateFilter
}

input AgentMarketplaceListingSumAggregateFilter {
  installCount: BigIntFilter
}

input AgentMarketplaceListingDistinctCountAggregateFilter {
  rowId: BigIntFilter
  personaId: BigIntFilter
  organizationId: BigIntFilter
  title: BigIntFilter
  description: BigIntFilter
  category: BigIntFilter
  installCount: BigIntFilter
  publishedAt: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
}

input AgentMarketplaceListingMinAggregateFilter {
  installCount: IntFilter
}

input AgentMarketplaceListingMaxAggregateFilter {
  installCount: IntFilter
}

input AgentMarketplaceListingAverageAggregateFilter {
  installCount: BigFloatFilter
}

input AgentMarketplaceListingStddevSampleAggregateFilter {
  installCount: BigFloatFilter
}

input AgentMarketplaceListingStddevPopulationAggregateFilter {
  installCount: BigFloatFilter
}

input AgentMarketplaceListingVarianceSampleAggregateFilter {
  installCount: BigFloatFilter
}

input AgentMarketplaceListingVariancePopulationAggregateFilter {
  installCount: BigFloatFilter
}

"""
A filter to be used against many `AgentSchedule` object types. All fields are combined with a logical and.
"""
input AgentPersonaToManyAgentScheduleFilter {
  """
  Every related `AgentSchedule` matches the filter criteria. All fields are combined with a logical and.
  """
  every: AgentScheduleFilter

  """
  Some related `AgentSchedule` matches the filter criteria. All fields are combined with a logical and.
  """
  some: AgentScheduleFilter

  """
  No related `AgentSchedule` matches the filter criteria. All fields are combined with a logical and.
  """
  none: AgentScheduleFilter

  """Aggregates across related `AgentSchedule` match the filter criteria."""
  aggregates: AgentScheduleAggregatesFilter
}

"""
A filter to be used against aggregates of `AgentSchedule` object types.
"""
input AgentScheduleAggregatesFilter {
  """
  A filter that must pass for the relevant `AgentSchedule` object to be included within the aggregate.
  """
  filter: AgentScheduleFilter

  """Distinct count aggregate over matching `AgentSchedule` objects."""
  distinctCount: AgentScheduleDistinctCountAggregateFilter
}

input AgentScheduleDistinctCountAggregateFilter {
  rowId: BigIntFilter
  organizationId: BigIntFilter
  projectId: BigIntFilter
  name: BigIntFilter
  cronExpression: BigIntFilter
  instruction: BigIntFilter
  personaId: BigIntFilter
  enabled: BigIntFilter
  lastRunAt: BigIntFilter
  nextRunAt: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
}

"""
A filter to be used against many `AgentWebhook` object types. All fields are combined with a logical and.
"""
input ProjectToManyAgentWebhookFilter {
  """
  Every related `AgentWebhook` matches the filter criteria. All fields are combined with a logical and.
  """
  every: AgentWebhookFilter

  """
  Some related `AgentWebhook` matches the filter criteria. All fields are combined with a logical and.
  """
  some: AgentWebhookFilter

  """
  No related `AgentWebhook` matches the filter criteria. All fields are combined with a logical and.
  """
  none: AgentWebhookFilter

  """Aggregates across related `AgentWebhook` match the filter criteria."""
  aggregates: AgentWebhookAggregatesFilter
}

"""
A filter to be used against `AgentWebhook` object types. All fields are combined with a logical and.
"""
input AgentWebhookFilter {
  """Filter by the objects `rowId` field."""
  rowId: UUIDFilter

  """Filter by the objects `organizationId` field."""
  organizationId: StringFilter

  """Filter by the objects `projectId` field."""
  projectId: UUIDFilter

  """Filter by the objects `name` field."""
  name: StringFilter

  """Filter by the objects `eventType` field."""
  eventType: StringFilter

  """Filter by the objects `instructionTemplate` field."""
  instructionTemplate: StringFilter

  """Filter by the objects `signingSecret` field."""
  signingSecret: StringFilter

  """Filter by the objects `enabled` field."""
  enabled: BooleanFilter

  """Filter by the objects `lastTriggeredAt` field."""
  lastTriggeredAt: DatetimeFilter

  """Filter by the objects `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the objects `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects `project` relation."""
  project: ProjectFilter

  """Checks for all expressions in this list."""
  and: [AgentWebhookFilter!]

  """Checks for any expressions in this list."""
  or: [AgentWebhookFilter!]

  """Negates the expression."""
  not: AgentWebhookFilter
}

"""A filter to be used against aggregates of `AgentWebhook` object types."""
input AgentWebhookAggregatesFilter {
  """
  A filter that must pass for the relevant `AgentWebhook` object to be included within the aggregate.
  """
  filter: AgentWebhookFilter

  """Distinct count aggregate over matching `AgentWebhook` objects."""
  distinctCount: AgentWebhookDistinctCountAggregateFilter
}

input AgentWebhookDistinctCountAggregateFilter {
  rowId: BigIntFilter
  organizationId: BigIntFilter
  projectId: BigIntFilter
  name: BigIntFilter
  eventType: BigIntFilter
  instructionTemplate: BigIntFilter
  signingSecret: BigIntFilter
  enabled: BigIntFilter
  lastTriggeredAt: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
}

"""
A filter to be used against `ProjectColumn` object types. All fields are combined with a logical and.
"""
input ProjectColumnFilter {
  """Filter by the objects `rowId` field."""
  rowId: UUIDFilter

  """Filter by the objects `icon` field."""
  icon: StringFilter

  """Filter by the objects `title` field."""
  title: StringFilter

  """Filter by the objects `organizationId` field."""
  organizationId: StringFilter

  """Filter by the objects `index` field."""
  index: IntFilter

  """Filter by the objects `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the objects `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects `projects` relation."""
  projects: ProjectColumnToManyProjectFilter

  """Some related `projects` exist."""
  projectsExist: Boolean

  """Checks for all expressions in this list."""
  and: [ProjectColumnFilter!]

  """Checks for any expressions in this list."""
  or: [ProjectColumnFilter!]

  """Negates the expression."""
  not: ProjectColumnFilter
}

"""
A filter to be used against many `Project` object types. All fields are combined with a logical and.
"""
input ProjectColumnToManyProjectFilter {
  """
  Every related `Project` matches the filter criteria. All fields are combined with a logical and.
  """
  every: ProjectFilter

  """
  Some related `Project` matches the filter criteria. All fields are combined with a logical and.
  """
  some: ProjectFilter

  """
  No related `Project` matches the filter criteria. All fields are combined with a logical and.
  """
  none: ProjectFilter

  """Aggregates across related `Project` match the filter criteria."""
  aggregates: ProjectAggregatesFilter
}

"""A filter to be used against aggregates of `Project` object types."""
input ProjectAggregatesFilter {
  """
  A filter that must pass for the relevant `Project` object to be included within the aggregate.
  """
  filter: ProjectFilter

  """Sum aggregate over matching `Project` objects."""
  sum: ProjectSumAggregateFilter

  """Distinct count aggregate over matching `Project` objects."""
  distinctCount: ProjectDistinctCountAggregateFilter

  """Minimum aggregate over matching `Project` objects."""
  min: ProjectMinAggregateFilter

  """Maximum aggregate over matching `Project` objects."""
  max: ProjectMaxAggregateFilter

  """Mean average aggregate over matching `Project` objects."""
  average: ProjectAverageAggregateFilter

  """Sample standard deviation aggregate over matching `Project` objects."""
  stddevSample: ProjectStddevSampleAggregateFilter

  """
  Population standard deviation aggregate over matching `Project` objects.
  """
  stddevPopulation: ProjectStddevPopulationAggregateFilter

  """Sample variance aggregate over matching `Project` objects."""
  varianceSample: ProjectVarianceSampleAggregateFilter

  """Population variance aggregate over matching `Project` objects."""
  variancePopulation: ProjectVariancePopulationAggregateFilter
}

input ProjectSumAggregateFilter {
  columnIndex: BigIntFilter
  nextTaskNumber: BigIntFilter
}

input ProjectDistinctCountAggregateFilter {
  rowId: BigIntFilter
  name: BigIntFilter
  description: BigIntFilter
  prefix: BigIntFilter
  organizationId: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
  projectColumnId: BigIntFilter
  slug: BigIntFilter
  columnIndex: BigIntFilter
  isPublic: BigIntFilter
  nextTaskNumber: BigIntFilter
}

input ProjectMinAggregateFilter {
  columnIndex: IntFilter
  nextTaskNumber: IntFilter
}

input ProjectMaxAggregateFilter {
  columnIndex: IntFilter
  nextTaskNumber: IntFilter
}

input ProjectAverageAggregateFilter {
  columnIndex: BigFloatFilter
  nextTaskNumber: BigFloatFilter
}

input ProjectStddevSampleAggregateFilter {
  columnIndex: BigFloatFilter
  nextTaskNumber: BigFloatFilter
}

input ProjectStddevPopulationAggregateFilter {
  columnIndex: BigFloatFilter
  nextTaskNumber: BigFloatFilter
}

input ProjectVarianceSampleAggregateFilter {
  columnIndex: BigFloatFilter
  nextTaskNumber: BigFloatFilter
}

input ProjectVariancePopulationAggregateFilter {
  columnIndex: BigFloatFilter
  nextTaskNumber: BigFloatFilter
}

"""Methods to use when ordering `Project`."""
enum ProjectOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  PREFIX_ASC
  PREFIX_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PROJECT_COLUMN_ID_ASC
  PROJECT_COLUMN_ID_DESC
  SLUG_ASC
  SLUG_DESC
  COLUMN_INDEX_ASC
  COLUMN_INDEX_DESC
  IS_PUBLIC_ASC
  IS_PUBLIC_DESC
  NEXT_TASK_NUMBER_ASC
  NEXT_TASK_NUMBER_DESC
  COLUMNS_COUNT_ASC
  COLUMNS_COUNT_DESC
  COLUMNS_SUM_INDEX_ASC
  COLUMNS_SUM_INDEX_DESC
  COLUMNS_DISTINCT_COUNT_ROW_ID_ASC
  COLUMNS_DISTINCT_COUNT_ROW_ID_DESC
  COLUMNS_DISTINCT_COUNT_TITLE_ASC
  COLUMNS_DISTINCT_COUNT_TITLE_DESC
  COLUMNS_DISTINCT_COUNT_PROJECT_ID_ASC
  COLUMNS_DISTINCT_COUNT_PROJECT_ID_DESC
  COLUMNS_DISTINCT_COUNT_CREATED_AT_ASC
  COLUMNS_DISTINCT_COUNT_CREATED_AT_DESC
  COLUMNS_DISTINCT_COUNT_UPDATED_AT_ASC
  COLUMNS_DISTINCT_COUNT_UPDATED_AT_DESC
  COLUMNS_DISTINCT_COUNT_INDEX_ASC
  COLUMNS_DISTINCT_COUNT_INDEX_DESC
  COLUMNS_DISTINCT_COUNT_ICON_ASC
  COLUMNS_DISTINCT_COUNT_ICON_DESC
  COLUMNS_MIN_INDEX_ASC
  COLUMNS_MIN_INDEX_DESC
  COLUMNS_MAX_INDEX_ASC
  COLUMNS_MAX_INDEX_DESC
  COLUMNS_AVERAGE_INDEX_ASC
  COLUMNS_AVERAGE_INDEX_DESC
  COLUMNS_STDDEV_SAMPLE_INDEX_ASC
  COLUMNS_STDDEV_SAMPLE_INDEX_DESC
  COLUMNS_STDDEV_POPULATION_INDEX_ASC
  COLUMNS_STDDEV_POPULATION_INDEX_DESC
  COLUMNS_VARIANCE_SAMPLE_INDEX_ASC
  COLUMNS_VARIANCE_SAMPLE_INDEX_DESC
  COLUMNS_VARIANCE_POPULATION_INDEX_ASC
  COLUMNS_VARIANCE_POPULATION_INDEX_DESC
  TASKS_COUNT_ASC
  TASKS_COUNT_DESC
  TASKS_SUM_COLUMN_INDEX_ASC
  TASKS_SUM_COLUMN_INDEX_DESC
  TASKS_SUM_NUMBER_ASC
  TASKS_SUM_NUMBER_DESC
  TASKS_DISTINCT_COUNT_ROW_ID_ASC
  TASKS_DISTINCT_COUNT_ROW_ID_DESC
  TASKS_DISTINCT_COUNT_CONTENT_ASC
  TASKS_DISTINCT_COUNT_CONTENT_DESC
  TASKS_DISTINCT_COUNT_DESCRIPTION_ASC
  TASKS_DISTINCT_COUNT_DESCRIPTION_DESC
  TASKS_DISTINCT_COUNT_PRIORITY_ASC
  TASKS_DISTINCT_COUNT_PRIORITY_DESC
  TASKS_DISTINCT_COUNT_AUTHOR_ID_ASC
  TASKS_DISTINCT_COUNT_AUTHOR_ID_DESC
  TASKS_DISTINCT_COUNT_COLUMN_ID_ASC
  TASKS_DISTINCT_COUNT_COLUMN_ID_DESC
  TASKS_DISTINCT_COUNT_DUE_DATE_ASC
  TASKS_DISTINCT_COUNT_DUE_DATE_DESC
  TASKS_DISTINCT_COUNT_CREATED_AT_ASC
  TASKS_DISTINCT_COUNT_CREATED_AT_DESC
  TASKS_DISTINCT_COUNT_UPDATED_AT_ASC
  TASKS_DISTINCT_COUNT_UPDATED_AT_DESC
  TASKS_DISTINCT_COUNT_COLUMN_INDEX_ASC
  TASKS_DISTINCT_COUNT_COLUMN_INDEX_DESC
  TASKS_DISTINCT_COUNT_PROJECT_ID_ASC
  TASKS_DISTINCT_COUNT_PROJECT_ID_DESC
  TASKS_DISTINCT_COUNT_NUMBER_ASC
  TASKS_DISTINCT_COUNT_NUMBER_DESC
  TASKS_MIN_COLUMN_INDEX_ASC
  TASKS_MIN_COLUMN_INDEX_DESC
  TASKS_MIN_NUMBER_ASC
  TASKS_MIN_NUMBER_DESC
  TASKS_MAX_COLUMN_INDEX_ASC
  TASKS_MAX_COLUMN_INDEX_DESC
  TASKS_MAX_NUMBER_ASC
  TASKS_MAX_NUMBER_DESC
  TASKS_AVERAGE_COLUMN_INDEX_ASC
  TASKS_AVERAGE_COLUMN_INDEX_DESC
  TASKS_AVERAGE_NUMBER_ASC
  TASKS_AVERAGE_NUMBER_DESC
  TASKS_STDDEV_SAMPLE_COLUMN_INDEX_ASC
  TASKS_STDDEV_SAMPLE_COLUMN_INDEX_DESC
  TASKS_STDDEV_SAMPLE_NUMBER_ASC
  TASKS_STDDEV_SAMPLE_NUMBER_DESC
  TASKS_STDDEV_POPULATION_COLUMN_INDEX_ASC
  TASKS_STDDEV_POPULATION_COLUMN_INDEX_DESC
  TASKS_STDDEV_POPULATION_NUMBER_ASC
  TASKS_STDDEV_POPULATION_NUMBER_DESC
  TASKS_VARIANCE_SAMPLE_COLUMN_INDEX_ASC
  TASKS_VARIANCE_SAMPLE_COLUMN_INDEX_DESC
  TASKS_VARIANCE_SAMPLE_NUMBER_ASC
  TASKS_VARIANCE_SAMPLE_NUMBER_DESC
  TASKS_VARIANCE_POPULATION_COLUMN_INDEX_ASC
  TASKS_VARIANCE_POPULATION_COLUMN_INDEX_DESC
  TASKS_VARIANCE_POPULATION_NUMBER_ASC
  TASKS_VARIANCE_POPULATION_NUMBER_DESC
  LABELS_COUNT_ASC
  LABELS_COUNT_DESC
  LABELS_DISTINCT_COUNT_ROW_ID_ASC
  LABELS_DISTINCT_COUNT_ROW_ID_DESC
  LABELS_DISTINCT_COUNT_NAME_ASC
  LABELS_DISTINCT_COUNT_NAME_DESC
  LABELS_DISTINCT_COUNT_COLOR_ASC
  LABELS_DISTINCT_COUNT_COLOR_DESC
  LABELS_DISTINCT_COUNT_PROJECT_ID_ASC
  LABELS_DISTINCT_COUNT_PROJECT_ID_DESC
  LABELS_DISTINCT_COUNT_CREATED_AT_ASC
  LABELS_DISTINCT_COUNT_CREATED_AT_DESC
  LABELS_DISTINCT_COUNT_UPDATED_AT_ASC
  LABELS_DISTINCT_COUNT_UPDATED_AT_DESC
  LABELS_DISTINCT_COUNT_ICON_ASC
  LABELS_DISTINCT_COUNT_ICON_DESC
  LABELS_DISTINCT_COUNT_ORGANIZATION_ID_ASC
  LABELS_DISTINCT_COUNT_ORGANIZATION_ID_DESC
  USER_PREFERENCES_COUNT_ASC
  USER_PREFERENCES_COUNT_DESC
  USER_PREFERENCES_DISTINCT_COUNT_ROW_ID_ASC
  USER_PREFERENCES_DISTINCT_COUNT_ROW_ID_DESC
  USER_PREFERENCES_DISTINCT_COUNT_USER_ID_ASC
  USER_PREFERENCES_DISTINCT_COUNT_USER_ID_DESC
  USER_PREFERENCES_DISTINCT_COUNT_PROJECT_ID_ASC
  USER_PREFERENCES_DISTINCT_COUNT_PROJECT_ID_DESC
  USER_PREFERENCES_DISTINCT_COUNT_HIDDEN_COLUMN_IDS_ASC
  USER_PREFERENCES_DISTINCT_COUNT_HIDDEN_COLUMN_IDS_DESC
  USER_PREFERENCES_DISTINCT_COUNT_CREATED_AT_ASC
  USER_PREFERENCES_DISTINCT_COUNT_CREATED_AT_DESC
  USER_PREFERENCES_DISTINCT_COUNT_UPDATED_AT_ASC
  USER_PREFERENCES_DISTINCT_COUNT_UPDATED_AT_DESC
  USER_PREFERENCES_DISTINCT_COUNT_VIEW_MODE_ASC
  USER_PREFERENCES_DISTINCT_COUNT_VIEW_MODE_DESC
  USER_PREFERENCES_DISTINCT_COUNT_COLOR_ASC
  USER_PREFERENCES_DISTINCT_COUNT_COLOR_DESC
  PROJECT_PROJECT_LABELS_COUNT_ASC
  PROJECT_PROJECT_LABELS_COUNT_DESC
  PROJECT_PROJECT_LABELS_DISTINCT_COUNT_PROJECT_ID_ASC
  PROJECT_PROJECT_LABELS_DISTINCT_COUNT_PROJECT_ID_DESC
  PROJECT_PROJECT_LABELS_DISTINCT_COUNT_PROJECT_LABEL_ID_ASC
  PROJECT_PROJECT_LABELS_DISTINCT_COUNT_PROJECT_LABEL_ID_DESC
  PROJECT_PROJECT_LABELS_DISTINCT_COUNT_CREATED_AT_ASC
  PROJECT_PROJECT_LABELS_DISTINCT_COUNT_CREATED_AT_DESC
  AGENT_ACTIVITIES_COUNT_ASC
  AGENT_ACTIVITIES_COUNT_DESC
  AGENT_ACTIVITIES_DISTINCT_COUNT_ROW_ID_ASC
  AGENT_ACTIVITIES_DISTINCT_COUNT_ROW_ID_DESC
  AGENT_ACTIVITIES_DISTINCT_COUNT_ORGANIZATION_ID_ASC
  AGENT_ACTIVITIES_DISTINCT_COUNT_ORGANIZATION_ID_DESC
  AGENT_ACTIVITIES_DISTINCT_COUNT_PROJECT_ID_ASC
  AGENT_ACTIVITIES_DISTINCT_COUNT_PROJECT_ID_DESC
  AGENT_ACTIVITIES_DISTINCT_COUNT_SESSION_ID_ASC
  AGENT_ACTIVITIES_DISTINCT_COUNT_SESSION_ID_DESC
  AGENT_ACTIVITIES_DISTINCT_COUNT_USER_ID_ASC
  AGENT_ACTIVITIES_DISTINCT_COUNT_USER_ID_DESC
  AGENT_ACTIVITIES_DISTINCT_COUNT_TOOL_NAME_ASC
  AGENT_ACTIVITIES_DISTINCT_COUNT_TOOL_NAME_DESC
  AGENT_ACTIVITIES_DISTINCT_COUNT_TOOL_INPUT_ASC
  AGENT_ACTIVITIES_DISTINCT_COUNT_TOOL_INPUT_DESC
  AGENT_ACTIVITIES_DISTINCT_COUNT_TOOL_OUTPUT_ASC
  AGENT_ACTIVITIES_DISTINCT_COUNT_TOOL_OUTPUT_DESC
  AGENT_ACTIVITIES_DISTINCT_COUNT_REQUIRES_APPROVAL_ASC
  AGENT_ACTIVITIES_DISTINCT_COUNT_REQUIRES_APPROVAL_DESC
  AGENT_ACTIVITIES_DISTINCT_COUNT_APPROVAL_STATUS_ASC
  AGENT_ACTIVITIES_DISTINCT_COUNT_APPROVAL_STATUS_DESC
  AGENT_ACTIVITIES_DISTINCT_COUNT_STATUS_ASC
  AGENT_ACTIVITIES_DISTINCT_COUNT_STATUS_DESC
  AGENT_ACTIVITIES_DISTINCT_COUNT_ERROR_MESSAGE_ASC
  AGENT_ACTIVITIES_DISTINCT_COUNT_ERROR_MESSAGE_DESC
  AGENT_ACTIVITIES_DISTINCT_COUNT_AFFECTED_TASK_IDS_ASC
  AGENT_ACTIVITIES_DISTINCT_COUNT_AFFECTED_TASK_IDS_DESC
  AGENT_ACTIVITIES_DISTINCT_COUNT_CREATED_AT_ASC
  AGENT_ACTIVITIES_DISTINCT_COUNT_CREATED_AT_DESC
  AGENT_ACTIVITIES_DISTINCT_COUNT_SNAPSHOT_BEFORE_ASC
  AGENT_ACTIVITIES_DISTINCT_COUNT_SNAPSHOT_BEFORE_DESC
  AGENT_SESSIONS_COUNT_ASC
  AGENT_SESSIONS_COUNT_DESC
  AGENT_SESSIONS_SUM_TOTAL_TOKENS_USED_ASC
  AGENT_SESSIONS_SUM_TOTAL_TOKENS_USED_DESC
  AGENT_SESSIONS_SUM_TOOL_CALL_COUNT_ASC
  AGENT_SESSIONS_SUM_TOOL_CALL_COUNT_DESC
  AGENT_SESSIONS_DISTINCT_COUNT_ROW_ID_ASC
  AGENT_SESSIONS_DISTINCT_COUNT_ROW_ID_DESC
  AGENT_SESSIONS_DISTINCT_COUNT_ORGANIZATION_ID_ASC
  AGENT_SESSIONS_DISTINCT_COUNT_ORGANIZATION_ID_DESC
  AGENT_SESSIONS_DISTINCT_COUNT_PROJECT_ID_ASC
  AGENT_SESSIONS_DISTINCT_COUNT_PROJECT_ID_DESC
  AGENT_SESSIONS_DISTINCT_COUNT_USER_ID_ASC
  AGENT_SESSIONS_DISTINCT_COUNT_USER_ID_DESC
  AGENT_SESSIONS_DISTINCT_COUNT_TITLE_ASC
  AGENT_SESSIONS_DISTINCT_COUNT_TITLE_DESC
  AGENT_SESSIONS_DISTINCT_COUNT_MESSAGES_ASC
  AGENT_SESSIONS_DISTINCT_COUNT_MESSAGES_DESC
  AGENT_SESSIONS_DISTINCT_COUNT_TOTAL_TOKENS_USED_ASC
  AGENT_SESSIONS_DISTINCT_COUNT_TOTAL_TOKENS_USED_DESC
  AGENT_SESSIONS_DISTINCT_COUNT_TOOL_CALL_COUNT_ASC
  AGENT_SESSIONS_DISTINCT_COUNT_TOOL_CALL_COUNT_DESC
  AGENT_SESSIONS_DISTINCT_COUNT_CREATED_AT_ASC
  AGENT_SESSIONS_DISTINCT_COUNT_CREATED_AT_DESC
  AGENT_SESSIONS_DISTINCT_COUNT_UPDATED_AT_ASC
  AGENT_SESSIONS_DISTINCT_COUNT_UPDATED_AT_DESC
  AGENT_SESSIONS_DISTINCT_COUNT_TYPE_ASC
  AGENT_SESSIONS_DISTINCT_COUNT_TYPE_DESC
  AGENT_SESSIONS_MIN_TOTAL_TOKENS_USED_ASC
  AGENT_SESSIONS_MIN_TOTAL_TOKENS_USED_DESC
  AGENT_SESSIONS_MIN_TOOL_CALL_COUNT_ASC
  AGENT_SESSIONS_MIN_TOOL_CALL_COUNT_DESC
  AGENT_SESSIONS_MAX_TOTAL_TOKENS_USED_ASC
  AGENT_SESSIONS_MAX_TOTAL_TOKENS_USED_DESC
  AGENT_SESSIONS_MAX_TOOL_CALL_COUNT_ASC
  AGENT_SESSIONS_MAX_TOOL_CALL_COUNT_DESC
  AGENT_SESSIONS_AVERAGE_TOTAL_TOKENS_USED_ASC
  AGENT_SESSIONS_AVERAGE_TOTAL_TOKENS_USED_DESC
  AGENT_SESSIONS_AVERAGE_TOOL_CALL_COUNT_ASC
  AGENT_SESSIONS_AVERAGE_TOOL_CALL_COUNT_DESC
  AGENT_SESSIONS_STDDEV_SAMPLE_TOTAL_TOKENS_USED_ASC
  AGENT_SESSIONS_STDDEV_SAMPLE_TOTAL_TOKENS_USED_DESC
  AGENT_SESSIONS_STDDEV_SAMPLE_TOOL_CALL_COUNT_ASC
  AGENT_SESSIONS_STDDEV_SAMPLE_TOOL_CALL_COUNT_DESC
  AGENT_SESSIONS_STDDEV_POPULATION_TOTAL_TOKENS_USED_ASC
  AGENT_SESSIONS_STDDEV_POPULATION_TOTAL_TOKENS_USED_DESC
  AGENT_SESSIONS_STDDEV_POPULATION_TOOL_CALL_COUNT_ASC
  AGENT_SESSIONS_STDDEV_POPULATION_TOOL_CALL_COUNT_DESC
  AGENT_SESSIONS_VARIANCE_SAMPLE_TOTAL_TOKENS_USED_ASC
  AGENT_SESSIONS_VARIANCE_SAMPLE_TOTAL_TOKENS_USED_DESC
  AGENT_SESSIONS_VARIANCE_SAMPLE_TOOL_CALL_COUNT_ASC
  AGENT_SESSIONS_VARIANCE_SAMPLE_TOOL_CALL_COUNT_DESC
  AGENT_SESSIONS_VARIANCE_POPULATION_TOTAL_TOKENS_USED_ASC
  AGENT_SESSIONS_VARIANCE_POPULATION_TOTAL_TOKENS_USED_DESC
  AGENT_SESSIONS_VARIANCE_POPULATION_TOOL_CALL_COUNT_ASC
  AGENT_SESSIONS_VARIANCE_POPULATION_TOOL_CALL_COUNT_DESC
  AGENT_SCHEDULES_COUNT_ASC
  AGENT_SCHEDULES_COUNT_DESC
  AGENT_SCHEDULES_DISTINCT_COUNT_ROW_ID_ASC
  AGENT_SCHEDULES_DISTINCT_COUNT_ROW_ID_DESC
  AGENT_SCHEDULES_DISTINCT_COUNT_ORGANIZATION_ID_ASC
  AGENT_SCHEDULES_DISTINCT_COUNT_ORGANIZATION_ID_DESC
  AGENT_SCHEDULES_DISTINCT_COUNT_PROJECT_ID_ASC
  AGENT_SCHEDULES_DISTINCT_COUNT_PROJECT_ID_DESC
  AGENT_SCHEDULES_DISTINCT_COUNT_NAME_ASC
  AGENT_SCHEDULES_DISTINCT_COUNT_NAME_DESC
  AGENT_SCHEDULES_DISTINCT_COUNT_CRON_EXPRESSION_ASC
  AGENT_SCHEDULES_DISTINCT_COUNT_CRON_EXPRESSION_DESC
  AGENT_SCHEDULES_DISTINCT_COUNT_INSTRUCTION_ASC
  AGENT_SCHEDULES_DISTINCT_COUNT_INSTRUCTION_DESC
  AGENT_SCHEDULES_DISTINCT_COUNT_PERSONA_ID_ASC
  AGENT_SCHEDULES_DISTINCT_COUNT_PERSONA_ID_DESC
  AGENT_SCHEDULES_DISTINCT_COUNT_ENABLED_ASC
  AGENT_SCHEDULES_DISTINCT_COUNT_ENABLED_DESC
  AGENT_SCHEDULES_DISTINCT_COUNT_LAST_RUN_AT_ASC
  AGENT_SCHEDULES_DISTINCT_COUNT_LAST_RUN_AT_DESC
  AGENT_SCHEDULES_DISTINCT_COUNT_NEXT_RUN_AT_ASC
  AGENT_SCHEDULES_DISTINCT_COUNT_NEXT_RUN_AT_DESC
  AGENT_SCHEDULES_DISTINCT_COUNT_CREATED_AT_ASC
  AGENT_SCHEDULES_DISTINCT_COUNT_CREATED_AT_DESC
  AGENT_SCHEDULES_DISTINCT_COUNT_UPDATED_AT_ASC
  AGENT_SCHEDULES_DISTINCT_COUNT_UPDATED_AT_DESC
  AGENT_WEBHOOKS_COUNT_ASC
  AGENT_WEBHOOKS_COUNT_DESC
  AGENT_WEBHOOKS_DISTINCT_COUNT_ROW_ID_ASC
  AGENT_WEBHOOKS_DISTINCT_COUNT_ROW_ID_DESC
  AGENT_WEBHOOKS_DISTINCT_COUNT_ORGANIZATION_ID_ASC
  AGENT_WEBHOOKS_DISTINCT_COUNT_ORGANIZATION_ID_DESC
  AGENT_WEBHOOKS_DISTINCT_COUNT_PROJECT_ID_ASC
  AGENT_WEBHOOKS_DISTINCT_COUNT_PROJECT_ID_DESC
  AGENT_WEBHOOKS_DISTINCT_COUNT_NAME_ASC
  AGENT_WEBHOOKS_DISTINCT_COUNT_NAME_DESC
  AGENT_WEBHOOKS_DISTINCT_COUNT_EVENT_TYPE_ASC
  AGENT_WEBHOOKS_DISTINCT_COUNT_EVENT_TYPE_DESC
  AGENT_WEBHOOKS_DISTINCT_COUNT_INSTRUCTION_TEMPLATE_ASC
  AGENT_WEBHOOKS_DISTINCT_COUNT_INSTRUCTION_TEMPLATE_DESC
  AGENT_WEBHOOKS_DISTINCT_COUNT_SIGNING_SECRET_ASC
  AGENT_WEBHOOKS_DISTINCT_COUNT_SIGNING_SECRET_DESC
  AGENT_WEBHOOKS_DISTINCT_COUNT_ENABLED_ASC
  AGENT_WEBHOOKS_DISTINCT_COUNT_ENABLED_DESC
  AGENT_WEBHOOKS_DISTINCT_COUNT_LAST_TRIGGERED_AT_ASC
  AGENT_WEBHOOKS_DISTINCT_COUNT_LAST_TRIGGERED_AT_DESC
  AGENT_WEBHOOKS_DISTINCT_COUNT_CREATED_AT_ASC
  AGENT_WEBHOOKS_DISTINCT_COUNT_CREATED_AT_DESC
  AGENT_WEBHOOKS_DISTINCT_COUNT_UPDATED_AT_ASC
  AGENT_WEBHOOKS_DISTINCT_COUNT_UPDATED_AT_DESC
}

"""A connection to a list of `Column` values."""
type ColumnConnection {
  """A list of `Column` objects."""
  nodes: [Column!]!

  """
  A list of edges which contains the `Column` and cursor to aid in pagination.
  """
  edges: [ColumnEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Column` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: ColumnAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Column` for these aggregates."""
    groupBy: [ColumnGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: ColumnHavingInput
  ): [ColumnAggregates!]
}

type Column implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  title: String!
  projectId: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!
  index: Int!
  icon: String

  """Reads a single `Project` that is related to this `Column`."""
  project: Project

  """Reads and enables pagination through a set of `Task`."""
  tasks(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TaskCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TaskFilter

    """The method to use when ordering `Task`."""
    orderBy: [TaskOrderBy!] = [PRIMARY_KEY_ASC]
  ): TaskConnection!
}

"""A connection to a list of `Task` values."""
type TaskConnection {
  """A list of `Task` objects."""
  nodes: [Task!]!

  """
  A list of edges which contains the `Task` and cursor to aid in pagination.
  """
  edges: [TaskEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Task` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: TaskAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Task` for these aggregates."""
    groupBy: [TaskGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: TaskHavingInput
  ): [TaskAggregates!]
}

type Task implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  content: String!
  description: String!
  priority: String!
  authorId: UUID
  columnId: UUID!
  dueDate: Datetime
  createdAt: Datetime!
  updatedAt: Datetime!
  columnIndex: Int!
  projectId: UUID!
  number: Int

  """Reads a single `User` that is related to this `Task`."""
  author: User

  """Reads a single `Column` that is related to this `Task`."""
  column: Column

  """Reads a single `Project` that is related to this `Task`."""
  project: Project

  """Reads and enables pagination through a set of `Assignee`."""
  assignees(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AssigneeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AssigneeFilter

    """The method to use when ordering `Assignee`."""
    orderBy: [AssigneeOrderBy!] = [PRIMARY_KEY_ASC]
  ): AssigneeConnection!

  """Reads and enables pagination through a set of `Post`."""
  posts(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PostCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PostFilter

    """The method to use when ordering `Post`."""
    orderBy: [PostOrderBy!] = [PRIMARY_KEY_ASC]
  ): PostConnection!

  """Reads and enables pagination through a set of `TaskLabel`."""
  taskLabels(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TaskLabelCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TaskLabelFilter

    """The method to use when ordering `TaskLabel`."""
    orderBy: [TaskLabelOrderBy!] = [PRIMARY_KEY_ASC]
  ): TaskLabelConnection!
}

type User implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  identityProviderId: UUID!
  name: String!
  avatarUrl: String
  createdAt: Datetime!
  updatedAt: Datetime!
  email: String!

  """Reads and enables pagination through a set of `Assignee`."""
  assignees(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AssigneeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AssigneeFilter

    """The method to use when ordering `Assignee`."""
    orderBy: [AssigneeOrderBy!] = [PRIMARY_KEY_ASC]
  ): AssigneeConnection!

  """Reads and enables pagination through a set of `Post`."""
  authoredPosts(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PostCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PostFilter

    """The method to use when ordering `Post`."""
    orderBy: [PostOrderBy!] = [PRIMARY_KEY_ASC]
  ): PostConnection!

  """Reads and enables pagination through a set of `Task`."""
  authoredTasks(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TaskCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TaskFilter

    """The method to use when ordering `Task`."""
    orderBy: [TaskOrderBy!] = [PRIMARY_KEY_ASC]
  ): TaskConnection!

  """Reads and enables pagination through a set of `UserPreference`."""
  userPreferences(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserPreferenceCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserPreferenceFilter

    """The method to use when ordering `UserPreference`."""
    orderBy: [UserPreferenceOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserPreferenceConnection!

  """Reads and enables pagination through a set of `Emoji`."""
  emojis(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EmojiCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EmojiFilter

    """The method to use when ordering `Emoji`."""
    orderBy: [EmojiOrderBy!] = [PRIMARY_KEY_ASC]
  ): EmojiConnection!

  """Reads and enables pagination through a set of `UserOrganization`."""
  userOrganizations(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserOrganizationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserOrganizationFilter

    """The method to use when ordering `UserOrganization`."""
    orderBy: [UserOrganizationOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserOrganizationConnection!

  """Reads and enables pagination through a set of `AgentActivity`."""
  agentActivities(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AgentActivityCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AgentActivityFilter

    """The method to use when ordering `AgentActivity`."""
    orderBy: [AgentActivityOrderBy!] = [PRIMARY_KEY_ASC]
  ): AgentActivityConnection!

  """Reads and enables pagination through a set of `AgentSession`."""
  agentSessions(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AgentSessionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AgentSessionFilter

    """The method to use when ordering `AgentSession`."""
    orderBy: [AgentSessionOrderBy!] = [PRIMARY_KEY_ASC]
  ): AgentSessionConnection!
}

"""A connection to a list of `Assignee` values."""
type AssigneeConnection {
  """A list of `Assignee` objects."""
  nodes: [Assignee!]!

  """
  A list of edges which contains the `Assignee` and cursor to aid in pagination.
  """
  edges: [AssigneeEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Assignee` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: AssigneeAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Assignee` for these aggregates."""
    groupBy: [AssigneeGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: AssigneeHavingInput
  ): [AssigneeAggregates!]
}

type Assignee implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  userId: UUID!
  taskId: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!
  deletedAt: Datetime

  """Reads a single `Task` that is related to this `Assignee`."""
  task: Task

  """Reads a single `User` that is related to this `Assignee`."""
  user: User
}

"""A `Assignee` edge in the connection."""
type AssigneeEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Assignee` at the end of the edge."""
  node: Assignee!
}

type AssigneeAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: AssigneeDistinctCountAggregates
}

type AssigneeDistinctCountAggregates {
  """Distinct count of userId across the matching connection"""
  userId: BigInt

  """Distinct count of taskId across the matching connection"""
  taskId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt

  """Distinct count of deletedAt across the matching connection"""
  deletedAt: BigInt
}

"""Grouping methods for `Assignee` for usage during aggregation."""
enum AssigneeGroupBy {
  USER_ID
  TASK_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
  DELETED_AT
  DELETED_AT_TRUNCATED_TO_HOUR
  DELETED_AT_TRUNCATED_TO_DAY
}

"""Conditions for `Assignee` aggregates."""
input AssigneeHavingInput {
  AND: [AssigneeHavingInput!]
  OR: [AssigneeHavingInput!]
  sum: AssigneeHavingSumInput
  distinctCount: AssigneeHavingDistinctCountInput
  min: AssigneeHavingMinInput
  max: AssigneeHavingMaxInput
  average: AssigneeHavingAverageInput
  stddevSample: AssigneeHavingStddevSampleInput
  stddevPopulation: AssigneeHavingStddevPopulationInput
  varianceSample: AssigneeHavingVarianceSampleInput
  variancePopulation: AssigneeHavingVariancePopulationInput
}

input AssigneeHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

input AssigneeHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

input AssigneeHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

input AssigneeHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

input AssigneeHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

input AssigneeHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

input AssigneeHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

input AssigneeHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

input AssigneeHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

"""
A condition to be used against `Assignee` object types. All fields are tested
for equality and combined with a logical and.
"""
input AssigneeCondition {
  """Checks for equality with the objects `userId` field."""
  userId: UUID

  """Checks for equality with the objects `taskId` field."""
  taskId: UUID

  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the objects `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the objects `deletedAt` field."""
  deletedAt: Datetime
}

"""Methods to use when ordering `Assignee`."""
enum AssigneeOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  USER_ID_ASC
  USER_ID_DESC
  TASK_ID_ASC
  TASK_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  DELETED_AT_ASC
  DELETED_AT_DESC
}

"""A connection to a list of `Post` values."""
type PostConnection {
  """A list of `Post` objects."""
  nodes: [Post!]!

  """
  A list of edges which contains the `Post` and cursor to aid in pagination.
  """
  edges: [PostEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Post` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: PostAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Post` for these aggregates."""
    groupBy: [PostGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: PostHavingInput
  ): [PostAggregates!]
}

type Post implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  title: String
  description: String
  authorId: UUID
  taskId: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!

  """Reads a single `User` that is related to this `Post`."""
  author: User

  """Reads a single `Task` that is related to this `Post`."""
  task: Task

  """Reads and enables pagination through a set of `Emoji`."""
  emojis(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EmojiCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EmojiFilter

    """The method to use when ordering `Emoji`."""
    orderBy: [EmojiOrderBy!] = [PRIMARY_KEY_ASC]
  ): EmojiConnection!
}

"""A connection to a list of `Emoji` values."""
type EmojiConnection {
  """A list of `Emoji` objects."""
  nodes: [Emoji!]!

  """
  A list of edges which contains the `Emoji` and cursor to aid in pagination.
  """
  edges: [EmojiEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Emoji` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: EmojiAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Emoji` for these aggregates."""
    groupBy: [EmojiGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: EmojiHavingInput
  ): [EmojiAggregates!]
}

type Emoji implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  emoji: String
  postId: UUID!
  userId: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!

  """Reads a single `Post` that is related to this `Emoji`."""
  post: Post

  """Reads a single `User` that is related to this `Emoji`."""
  user: User
}

"""A `Emoji` edge in the connection."""
type EmojiEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Emoji` at the end of the edge."""
  node: Emoji!
}

type EmojiAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: EmojiDistinctCountAggregates
}

type EmojiDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of emoji across the matching connection"""
  emoji: BigInt

  """Distinct count of postId across the matching connection"""
  postId: BigInt

  """Distinct count of userId across the matching connection"""
  userId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

"""Grouping methods for `Emoji` for usage during aggregation."""
enum EmojiGroupBy {
  EMOJI
  POST_ID
  USER_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for `Emoji` aggregates."""
input EmojiHavingInput {
  AND: [EmojiHavingInput!]
  OR: [EmojiHavingInput!]
  sum: EmojiHavingSumInput
  distinctCount: EmojiHavingDistinctCountInput
  min: EmojiHavingMinInput
  max: EmojiHavingMaxInput
  average: EmojiHavingAverageInput
  stddevSample: EmojiHavingStddevSampleInput
  stddevPopulation: EmojiHavingStddevPopulationInput
  varianceSample: EmojiHavingVarianceSampleInput
  variancePopulation: EmojiHavingVariancePopulationInput
}

input EmojiHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input EmojiHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input EmojiHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input EmojiHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input EmojiHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input EmojiHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input EmojiHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input EmojiHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input EmojiHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""
A condition to be used against `Emoji` object types. All fields are tested for equality and combined with a logical and.
"""
input EmojiCondition {
  """Checks for equality with the objects `rowId` field."""
  rowId: UUID

  """Checks for equality with the objects `emoji` field."""
  emoji: String

  """Checks for equality with the objects `postId` field."""
  postId: UUID

  """Checks for equality with the objects `userId` field."""
  userId: UUID

  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the objects `updatedAt` field."""
  updatedAt: Datetime
}

"""Methods to use when ordering `Emoji`."""
enum EmojiOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  EMOJI_ASC
  EMOJI_DESC
  POST_ID_ASC
  POST_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

"""A `Post` edge in the connection."""
type PostEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Post` at the end of the edge."""
  node: Post!
}

type PostAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: PostDistinctCountAggregates
}

type PostDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of title across the matching connection"""
  title: BigInt

  """Distinct count of description across the matching connection"""
  description: BigInt

  """Distinct count of authorId across the matching connection"""
  authorId: BigInt

  """Distinct count of taskId across the matching connection"""
  taskId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

"""Grouping methods for `Post` for usage during aggregation."""
enum PostGroupBy {
  TITLE
  DESCRIPTION
  AUTHOR_ID
  TASK_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for `Post` aggregates."""
input PostHavingInput {
  AND: [PostHavingInput!]
  OR: [PostHavingInput!]
  sum: PostHavingSumInput
  distinctCount: PostHavingDistinctCountInput
  min: PostHavingMinInput
  max: PostHavingMaxInput
  average: PostHavingAverageInput
  stddevSample: PostHavingStddevSampleInput
  stddevPopulation: PostHavingStddevPopulationInput
  varianceSample: PostHavingVarianceSampleInput
  variancePopulation: PostHavingVariancePopulationInput
}

input PostHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input PostHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input PostHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input PostHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input PostHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input PostHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input PostHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input PostHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input PostHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""
A condition to be used against `Post` object types. All fields are tested for equality and combined with a logical and.
"""
input PostCondition {
  """Checks for equality with the objects `rowId` field."""
  rowId: UUID

  """Checks for equality with the objects `title` field."""
  title: String

  """Checks for equality with the objects `description` field."""
  description: String

  """Checks for equality with the objects `authorId` field."""
  authorId: UUID

  """Checks for equality with the objects `taskId` field."""
  taskId: UUID

  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the objects `updatedAt` field."""
  updatedAt: Datetime
}

"""Methods to use when ordering `Post`."""
enum PostOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  TITLE_ASC
  TITLE_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  AUTHOR_ID_ASC
  AUTHOR_ID_DESC
  TASK_ID_ASC
  TASK_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  EMOJIS_COUNT_ASC
  EMOJIS_COUNT_DESC
  EMOJIS_DISTINCT_COUNT_ROW_ID_ASC
  EMOJIS_DISTINCT_COUNT_ROW_ID_DESC
  EMOJIS_DISTINCT_COUNT_EMOJI_ASC
  EMOJIS_DISTINCT_COUNT_EMOJI_DESC
  EMOJIS_DISTINCT_COUNT_POST_ID_ASC
  EMOJIS_DISTINCT_COUNT_POST_ID_DESC
  EMOJIS_DISTINCT_COUNT_USER_ID_ASC
  EMOJIS_DISTINCT_COUNT_USER_ID_DESC
  EMOJIS_DISTINCT_COUNT_CREATED_AT_ASC
  EMOJIS_DISTINCT_COUNT_CREATED_AT_DESC
  EMOJIS_DISTINCT_COUNT_UPDATED_AT_ASC
  EMOJIS_DISTINCT_COUNT_UPDATED_AT_DESC
}

"""
A condition to be used against `Task` object types. All fields are tested for equality and combined with a logical and.
"""
input TaskCondition {
  """Checks for equality with the objects `rowId` field."""
  rowId: UUID

  """Checks for equality with the objects `content` field."""
  content: String

  """Checks for equality with the objects `description` field."""
  description: String

  """Checks for equality with the objects `priority` field."""
  priority: String

  """Checks for equality with the objects `authorId` field."""
  authorId: UUID

  """Checks for equality with the objects `columnId` field."""
  columnId: UUID

  """Checks for equality with the objects `dueDate` field."""
  dueDate: Datetime

  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the objects `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the objects `columnIndex` field."""
  columnIndex: Int

  """Checks for equality with the objects `projectId` field."""
  projectId: UUID

  """Checks for equality with the objects `number` field."""
  number: Int
}

"""Methods to use when ordering `Task`."""
enum TaskOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  CONTENT_ASC
  CONTENT_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  PRIORITY_ASC
  PRIORITY_DESC
  AUTHOR_ID_ASC
  AUTHOR_ID_DESC
  COLUMN_ID_ASC
  COLUMN_ID_DESC
  DUE_DATE_ASC
  DUE_DATE_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  COLUMN_INDEX_ASC
  COLUMN_INDEX_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
  NUMBER_ASC
  NUMBER_DESC
  ASSIGNEES_COUNT_ASC
  ASSIGNEES_COUNT_DESC
  ASSIGNEES_DISTINCT_COUNT_USER_ID_ASC
  ASSIGNEES_DISTINCT_COUNT_USER_ID_DESC
  ASSIGNEES_DISTINCT_COUNT_TASK_ID_ASC
  ASSIGNEES_DISTINCT_COUNT_TASK_ID_DESC
  ASSIGNEES_DISTINCT_COUNT_CREATED_AT_ASC
  ASSIGNEES_DISTINCT_COUNT_CREATED_AT_DESC
  ASSIGNEES_DISTINCT_COUNT_UPDATED_AT_ASC
  ASSIGNEES_DISTINCT_COUNT_UPDATED_AT_DESC
  ASSIGNEES_DISTINCT_COUNT_DELETED_AT_ASC
  ASSIGNEES_DISTINCT_COUNT_DELETED_AT_DESC
  POSTS_COUNT_ASC
  POSTS_COUNT_DESC
  POSTS_DISTINCT_COUNT_ROW_ID_ASC
  POSTS_DISTINCT_COUNT_ROW_ID_DESC
  POSTS_DISTINCT_COUNT_TITLE_ASC
  POSTS_DISTINCT_COUNT_TITLE_DESC
  POSTS_DISTINCT_COUNT_DESCRIPTION_ASC
  POSTS_DISTINCT_COUNT_DESCRIPTION_DESC
  POSTS_DISTINCT_COUNT_AUTHOR_ID_ASC
  POSTS_DISTINCT_COUNT_AUTHOR_ID_DESC
  POSTS_DISTINCT_COUNT_TASK_ID_ASC
  POSTS_DISTINCT_COUNT_TASK_ID_DESC
  POSTS_DISTINCT_COUNT_CREATED_AT_ASC
  POSTS_DISTINCT_COUNT_CREATED_AT_DESC
  POSTS_DISTINCT_COUNT_UPDATED_AT_ASC
  POSTS_DISTINCT_COUNT_UPDATED_AT_DESC
  TASK_LABELS_COUNT_ASC
  TASK_LABELS_COUNT_DESC
  TASK_LABELS_DISTINCT_COUNT_TASK_ID_ASC
  TASK_LABELS_DISTINCT_COUNT_TASK_ID_DESC
  TASK_LABELS_DISTINCT_COUNT_LABEL_ID_ASC
  TASK_LABELS_DISTINCT_COUNT_LABEL_ID_DESC
  TASK_LABELS_DISTINCT_COUNT_CREATED_AT_ASC
  TASK_LABELS_DISTINCT_COUNT_CREATED_AT_DESC
  TASK_LABELS_DISTINCT_COUNT_UPDATED_AT_ASC
  TASK_LABELS_DISTINCT_COUNT_UPDATED_AT_DESC
}

"""A connection to a list of `UserPreference` values."""
type UserPreferenceConnection {
  """A list of `UserPreference` objects."""
  nodes: [UserPreference!]!

  """
  A list of edges which contains the `UserPreference` and cursor to aid in pagination.
  """
  edges: [UserPreferenceEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `UserPreference` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: UserPreferenceAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `UserPreference` for these aggregates."""
    groupBy: [UserPreferenceGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: UserPreferenceHavingInput
  ): [UserPreferenceAggregates!]
}

type UserPreference implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  userId: UUID!
  projectId: UUID!
  hiddenColumnIds: [String]!
  createdAt: Datetime!
  updatedAt: Datetime!
  viewMode: String!
  color: String

  """Reads a single `Project` that is related to this `UserPreference`."""
  project: Project

  """Reads a single `User` that is related to this `UserPreference`."""
  user: User
}

"""A `UserPreference` edge in the connection."""
type UserPreferenceEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `UserPreference` at the end of the edge."""
  node: UserPreference!
}

type UserPreferenceAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: UserPreferenceDistinctCountAggregates
}

type UserPreferenceDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of userId across the matching connection"""
  userId: BigInt

  """Distinct count of projectId across the matching connection"""
  projectId: BigInt

  """Distinct count of hiddenColumnIds across the matching connection"""
  hiddenColumnIds: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt

  """Distinct count of viewMode across the matching connection"""
  viewMode: BigInt

  """Distinct count of color across the matching connection"""
  color: BigInt
}

"""Grouping methods for `UserPreference` for usage during aggregation."""
enum UserPreferenceGroupBy {
  USER_ID
  PROJECT_ID
  HIDDEN_COLUMN_IDS
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
  VIEW_MODE
  COLOR
}

"""Conditions for `UserPreference` aggregates."""
input UserPreferenceHavingInput {
  AND: [UserPreferenceHavingInput!]
  OR: [UserPreferenceHavingInput!]
  sum: UserPreferenceHavingSumInput
  distinctCount: UserPreferenceHavingDistinctCountInput
  min: UserPreferenceHavingMinInput
  max: UserPreferenceHavingMaxInput
  average: UserPreferenceHavingAverageInput
  stddevSample: UserPreferenceHavingStddevSampleInput
  stddevPopulation: UserPreferenceHavingStddevPopulationInput
  varianceSample: UserPreferenceHavingVarianceSampleInput
  variancePopulation: UserPreferenceHavingVariancePopulationInput
}

input UserPreferenceHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserPreferenceHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserPreferenceHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserPreferenceHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserPreferenceHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserPreferenceHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserPreferenceHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserPreferenceHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserPreferenceHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""
A condition to be used against `UserPreference` object types. All fields are
tested for equality and combined with a logical and.
"""
input UserPreferenceCondition {
  """Checks for equality with the objects `rowId` field."""
  rowId: UUID

  """Checks for equality with the objects `userId` field."""
  userId: UUID

  """Checks for equality with the objects `projectId` field."""
  projectId: UUID

  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the objects `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the objects `viewMode` field."""
  viewMode: String

  """Checks for equality with the objects `color` field."""
  color: String
}

"""Methods to use when ordering `UserPreference`."""
enum UserPreferenceOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  VIEW_MODE_ASC
  VIEW_MODE_DESC
  COLOR_ASC
  COLOR_DESC
}

"""A connection to a list of `UserOrganization` values."""
type UserOrganizationConnection {
  """A list of `UserOrganization` objects."""
  nodes: [UserOrganization!]!

  """
  A list of edges which contains the `UserOrganization` and cursor to aid in pagination.
  """
  edges: [UserOrganizationEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `UserOrganization` you could get from the connection.
  """
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: UserOrganizationAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """
    The method to use when grouping `UserOrganization` for these aggregates.
    """
    groupBy: [UserOrganizationGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: UserOrganizationHavingInput
  ): [UserOrganizationAggregates!]
}

type UserOrganization implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  userId: UUID!
  organizationId: String!
  slug: String!
  name: String
  type: OrganizationType!
  role: MemberRole!
  syncedAt: Datetime!
  createdAt: Datetime!
  updatedAt: Datetime!

  """Reads a single `User` that is related to this `UserOrganization`."""
  user: User
}

"""A `UserOrganization` edge in the connection."""
type UserOrganizationEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `UserOrganization` at the end of the edge."""
  node: UserOrganization!
}

type UserOrganizationAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: UserOrganizationDistinctCountAggregates
}

type UserOrganizationDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of userId across the matching connection"""
  userId: BigInt

  """Distinct count of organizationId across the matching connection"""
  organizationId: BigInt

  """Distinct count of slug across the matching connection"""
  slug: BigInt

  """Distinct count of name across the matching connection"""
  name: BigInt

  """Distinct count of type across the matching connection"""
  type: BigInt

  """Distinct count of role across the matching connection"""
  role: BigInt

  """Distinct count of syncedAt across the matching connection"""
  syncedAt: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

"""Grouping methods for `UserOrganization` for usage during aggregation."""
enum UserOrganizationGroupBy {
  USER_ID
  ORGANIZATION_ID
  SLUG
  NAME
  TYPE
  ROLE
  SYNCED_AT
  SYNCED_AT_TRUNCATED_TO_HOUR
  SYNCED_AT_TRUNCATED_TO_DAY
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for `UserOrganization` aggregates."""
input UserOrganizationHavingInput {
  AND: [UserOrganizationHavingInput!]
  OR: [UserOrganizationHavingInput!]
  sum: UserOrganizationHavingSumInput
  distinctCount: UserOrganizationHavingDistinctCountInput
  min: UserOrganizationHavingMinInput
  max: UserOrganizationHavingMaxInput
  average: UserOrganizationHavingAverageInput
  stddevSample: UserOrganizationHavingStddevSampleInput
  stddevPopulation: UserOrganizationHavingStddevPopulationInput
  varianceSample: UserOrganizationHavingVarianceSampleInput
  variancePopulation: UserOrganizationHavingVariancePopulationInput
}

input UserOrganizationHavingSumInput {
  syncedAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserOrganizationHavingDistinctCountInput {
  syncedAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserOrganizationHavingMinInput {
  syncedAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserOrganizationHavingMaxInput {
  syncedAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserOrganizationHavingAverageInput {
  syncedAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserOrganizationHavingStddevSampleInput {
  syncedAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserOrganizationHavingStddevPopulationInput {
  syncedAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserOrganizationHavingVarianceSampleInput {
  syncedAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserOrganizationHavingVariancePopulationInput {
  syncedAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""
A condition to be used against `UserOrganization` object types. All fields are
tested for equality and combined with a logical and.
"""
input UserOrganizationCondition {
  """Checks for equality with the objects `rowId` field."""
  rowId: UUID

  """Checks for equality with the objects `userId` field."""
  userId: UUID

  """Checks for equality with the objects `organizationId` field."""
  organizationId: String

  """Checks for equality with the objects `slug` field."""
  slug: String

  """Checks for equality with the objects `name` field."""
  name: String

  """Checks for equality with the objects `type` field."""
  type: OrganizationType

  """Checks for equality with the objects `role` field."""
  role: MemberRole

  """Checks for equality with the objects `syncedAt` field."""
  syncedAt: Datetime

  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the objects `updatedAt` field."""
  updatedAt: Datetime
}

"""Methods to use when ordering `UserOrganization`."""
enum UserOrganizationOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  SLUG_ASC
  SLUG_DESC
  NAME_ASC
  NAME_DESC
  SYNCED_AT_ASC
  SYNCED_AT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

"""A connection to a list of `AgentActivity` values."""
type AgentActivityConnection {
  """A list of `AgentActivity` objects."""
  nodes: [AgentActivity!]!

  """
  A list of edges which contains the `AgentActivity` and cursor to aid in pagination.
  """
  edges: [AgentActivityEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `AgentActivity` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: AgentActivityAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `AgentActivity` for these aggregates."""
    groupBy: [AgentActivityGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: AgentActivityHavingInput
  ): [AgentActivityAggregates!]
}

type AgentActivity implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  organizationId: String!
  projectId: UUID!
  sessionId: UUID!
  userId: UUID!
  toolName: String!
  toolInput: JSON!
  toolOutput: JSON
  requiresApproval: Boolean!
  approvalStatus: String
  status: String!
  errorMessage: String
  affectedTaskIds: JSON!
  createdAt: Datetime!
  snapshotBefore: JSON

  """Reads a single `Project` that is related to this `AgentActivity`."""
  project: Project

  """Reads a single `AgentSession` that is related to this `AgentActivity`."""
  session: AgentSession

  """Reads a single `User` that is related to this `AgentActivity`."""
  user: User
}

"""
Represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

type AgentSession implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  organizationId: String!
  projectId: UUID
  userId: UUID!
  title: String
  messages: JSON!
  totalTokensUsed: Int!
  toolCallCount: Int!
  createdAt: Datetime!
  updatedAt: Datetime!
  type: String!

  """Reads a single `Project` that is related to this `AgentSession`."""
  project: Project

  """Reads a single `User` that is related to this `AgentSession`."""
  user: User

  """Reads and enables pagination through a set of `AgentActivity`."""
  agentActivitiesBySessionId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AgentActivityCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AgentActivityFilter

    """The method to use when ordering `AgentActivity`."""
    orderBy: [AgentActivityOrderBy!] = [PRIMARY_KEY_ASC]
  ): AgentActivityConnection!
}

"""
A condition to be used against `AgentActivity` object types. All fields are
tested for equality and combined with a logical and.
"""
input AgentActivityCondition {
  """Checks for equality with the objects `rowId` field."""
  rowId: UUID

  """Checks for equality with the objects `organizationId` field."""
  organizationId: String

  """Checks for equality with the objects `projectId` field."""
  projectId: UUID

  """Checks for equality with the objects `sessionId` field."""
  sessionId: UUID

  """Checks for equality with the objects `userId` field."""
  userId: UUID

  """Checks for equality with the objects `toolName` field."""
  toolName: String

  """Checks for equality with the objects `requiresApproval` field."""
  requiresApproval: Boolean

  """Checks for equality with the objects `approvalStatus` field."""
  approvalStatus: String

  """Checks for equality with the objects `status` field."""
  status: String

  """Checks for equality with the objects `errorMessage` field."""
  errorMessage: String

  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
}

"""Methods to use when ordering `AgentActivity`."""
enum AgentActivityOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
  SESSION_ID_ASC
  SESSION_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  TOOL_NAME_ASC
  TOOL_NAME_DESC
  REQUIRES_APPROVAL_ASC
  REQUIRES_APPROVAL_DESC
  APPROVAL_STATUS_ASC
  APPROVAL_STATUS_DESC
  STATUS_ASC
  STATUS_DESC
  ERROR_MESSAGE_ASC
  ERROR_MESSAGE_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
}

"""A `AgentActivity` edge in the connection."""
type AgentActivityEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `AgentActivity` at the end of the edge."""
  node: AgentActivity!
}

type AgentActivityAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: AgentActivityDistinctCountAggregates
}

type AgentActivityDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of organizationId across the matching connection"""
  organizationId: BigInt

  """Distinct count of projectId across the matching connection"""
  projectId: BigInt

  """Distinct count of sessionId across the matching connection"""
  sessionId: BigInt

  """Distinct count of userId across the matching connection"""
  userId: BigInt

  """Distinct count of toolName across the matching connection"""
  toolName: BigInt

  """Distinct count of toolInput across the matching connection"""
  toolInput: BigInt

  """Distinct count of toolOutput across the matching connection"""
  toolOutput: BigInt

  """Distinct count of requiresApproval across the matching connection"""
  requiresApproval: BigInt

  """Distinct count of approvalStatus across the matching connection"""
  approvalStatus: BigInt

  """Distinct count of status across the matching connection"""
  status: BigInt

  """Distinct count of errorMessage across the matching connection"""
  errorMessage: BigInt

  """Distinct count of affectedTaskIds across the matching connection"""
  affectedTaskIds: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of snapshotBefore across the matching connection"""
  snapshotBefore: BigInt
}

"""Grouping methods for `AgentActivity` for usage during aggregation."""
enum AgentActivityGroupBy {
  ORGANIZATION_ID
  PROJECT_ID
  SESSION_ID
  USER_ID
  TOOL_NAME
  TOOL_INPUT
  TOOL_OUTPUT
  REQUIRES_APPROVAL
  APPROVAL_STATUS
  STATUS
  ERROR_MESSAGE
  AFFECTED_TASK_IDS
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  SNAPSHOT_BEFORE
}

"""Conditions for `AgentActivity` aggregates."""
input AgentActivityHavingInput {
  AND: [AgentActivityHavingInput!]
  OR: [AgentActivityHavingInput!]
  sum: AgentActivityHavingSumInput
  distinctCount: AgentActivityHavingDistinctCountInput
  min: AgentActivityHavingMinInput
  max: AgentActivityHavingMaxInput
  average: AgentActivityHavingAverageInput
  stddevSample: AgentActivityHavingStddevSampleInput
  stddevPopulation: AgentActivityHavingStddevPopulationInput
  varianceSample: AgentActivityHavingVarianceSampleInput
  variancePopulation: AgentActivityHavingVariancePopulationInput
}

input AgentActivityHavingSumInput {
  createdAt: HavingDatetimeFilter
}

input AgentActivityHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
}

input AgentActivityHavingMinInput {
  createdAt: HavingDatetimeFilter
}

input AgentActivityHavingMaxInput {
  createdAt: HavingDatetimeFilter
}

input AgentActivityHavingAverageInput {
  createdAt: HavingDatetimeFilter
}

input AgentActivityHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
}

input AgentActivityHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
}

input AgentActivityHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
}

input AgentActivityHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
}

"""A connection to a list of `AgentSession` values."""
type AgentSessionConnection {
  """A list of `AgentSession` objects."""
  nodes: [AgentSession!]!

  """
  A list of edges which contains the `AgentSession` and cursor to aid in pagination.
  """
  edges: [AgentSessionEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `AgentSession` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: AgentSessionAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `AgentSession` for these aggregates."""
    groupBy: [AgentSessionGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: AgentSessionHavingInput
  ): [AgentSessionAggregates!]
}

"""A `AgentSession` edge in the connection."""
type AgentSessionEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `AgentSession` at the end of the edge."""
  node: AgentSession!
}

type AgentSessionAggregates {
  keys: [String]

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: AgentSessionSumAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: AgentSessionDistinctCountAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: AgentSessionMinAggregates

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: AgentSessionMaxAggregates

  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: AgentSessionAverageAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: AgentSessionStddevSampleAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: AgentSessionStddevPopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: AgentSessionVarianceSampleAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: AgentSessionVariancePopulationAggregates
}

type AgentSessionSumAggregates {
  """Sum of totalTokensUsed across the matching connection"""
  totalTokensUsed: BigInt!

  """Sum of toolCallCount across the matching connection"""
  toolCallCount: BigInt!
}

type AgentSessionDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of organizationId across the matching connection"""
  organizationId: BigInt

  """Distinct count of projectId across the matching connection"""
  projectId: BigInt

  """Distinct count of userId across the matching connection"""
  userId: BigInt

  """Distinct count of title across the matching connection"""
  title: BigInt

  """Distinct count of messages across the matching connection"""
  messages: BigInt

  """Distinct count of totalTokensUsed across the matching connection"""
  totalTokensUsed: BigInt

  """Distinct count of toolCallCount across the matching connection"""
  toolCallCount: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt

  """Distinct count of type across the matching connection"""
  type: BigInt
}

type AgentSessionMinAggregates {
  """Minimum of totalTokensUsed across the matching connection"""
  totalTokensUsed: Int

  """Minimum of toolCallCount across the matching connection"""
  toolCallCount: Int
}

type AgentSessionMaxAggregates {
  """Maximum of totalTokensUsed across the matching connection"""
  totalTokensUsed: Int

  """Maximum of toolCallCount across the matching connection"""
  toolCallCount: Int
}

type AgentSessionAverageAggregates {
  """Mean average of totalTokensUsed across the matching connection"""
  totalTokensUsed: BigFloat

  """Mean average of toolCallCount across the matching connection"""
  toolCallCount: BigFloat
}

type AgentSessionStddevSampleAggregates {
  """
  Sample standard deviation of totalTokensUsed across the matching connection
  """
  totalTokensUsed: BigFloat

  """
  Sample standard deviation of toolCallCount across the matching connection
  """
  toolCallCount: BigFloat
}

type AgentSessionStddevPopulationAggregates {
  """
  Population standard deviation of totalTokensUsed across the matching connection
  """
  totalTokensUsed: BigFloat

  """
  Population standard deviation of toolCallCount across the matching connection
  """
  toolCallCount: BigFloat
}

type AgentSessionVarianceSampleAggregates {
  """Sample variance of totalTokensUsed across the matching connection"""
  totalTokensUsed: BigFloat

  """Sample variance of toolCallCount across the matching connection"""
  toolCallCount: BigFloat
}

type AgentSessionVariancePopulationAggregates {
  """Population variance of totalTokensUsed across the matching connection"""
  totalTokensUsed: BigFloat

  """Population variance of toolCallCount across the matching connection"""
  toolCallCount: BigFloat
}

"""Grouping methods for `AgentSession` for usage during aggregation."""
enum AgentSessionGroupBy {
  ORGANIZATION_ID
  PROJECT_ID
  USER_ID
  TITLE
  MESSAGES
  TOTAL_TOKENS_USED
  TOOL_CALL_COUNT
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
  TYPE
}

"""Conditions for `AgentSession` aggregates."""
input AgentSessionHavingInput {
  AND: [AgentSessionHavingInput!]
  OR: [AgentSessionHavingInput!]
  sum: AgentSessionHavingSumInput
  distinctCount: AgentSessionHavingDistinctCountInput
  min: AgentSessionHavingMinInput
  max: AgentSessionHavingMaxInput
  average: AgentSessionHavingAverageInput
  stddevSample: AgentSessionHavingStddevSampleInput
  stddevPopulation: AgentSessionHavingStddevPopulationInput
  varianceSample: AgentSessionHavingVarianceSampleInput
  variancePopulation: AgentSessionHavingVariancePopulationInput
}

input AgentSessionHavingSumInput {
  totalTokensUsed: HavingIntFilter
  toolCallCount: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentSessionHavingDistinctCountInput {
  totalTokensUsed: HavingIntFilter
  toolCallCount: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentSessionHavingMinInput {
  totalTokensUsed: HavingIntFilter
  toolCallCount: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentSessionHavingMaxInput {
  totalTokensUsed: HavingIntFilter
  toolCallCount: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentSessionHavingAverageInput {
  totalTokensUsed: HavingIntFilter
  toolCallCount: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentSessionHavingStddevSampleInput {
  totalTokensUsed: HavingIntFilter
  toolCallCount: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentSessionHavingStddevPopulationInput {
  totalTokensUsed: HavingIntFilter
  toolCallCount: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentSessionHavingVarianceSampleInput {
  totalTokensUsed: HavingIntFilter
  toolCallCount: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentSessionHavingVariancePopulationInput {
  totalTokensUsed: HavingIntFilter
  toolCallCount: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""
A condition to be used against `AgentSession` object types. All fields are
tested for equality and combined with a logical and.
"""
input AgentSessionCondition {
  """Checks for equality with the objects `rowId` field."""
  rowId: UUID

  """Checks for equality with the objects `organizationId` field."""
  organizationId: String

  """Checks for equality with the objects `projectId` field."""
  projectId: UUID

  """Checks for equality with the objects `userId` field."""
  userId: UUID

  """Checks for equality with the objects `title` field."""
  title: String

  """Checks for equality with the objects `totalTokensUsed` field."""
  totalTokensUsed: Int

  """Checks for equality with the objects `toolCallCount` field."""
  toolCallCount: Int

  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the objects `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the objects `type` field."""
  type: String
}

"""Methods to use when ordering `AgentSession`."""
enum AgentSessionOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  TITLE_ASC
  TITLE_DESC
  TOTAL_TOKENS_USED_ASC
  TOTAL_TOKENS_USED_DESC
  TOOL_CALL_COUNT_ASC
  TOOL_CALL_COUNT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  TYPE_ASC
  TYPE_DESC
  AGENT_ACTIVITIES_BY_SESSION_ID_COUNT_ASC
  AGENT_ACTIVITIES_BY_SESSION_ID_COUNT_DESC
  AGENT_ACTIVITIES_BY_SESSION_ID_DISTINCT_COUNT_ROW_ID_ASC
  AGENT_ACTIVITIES_BY_SESSION_ID_DISTINCT_COUNT_ROW_ID_DESC
  AGENT_ACTIVITIES_BY_SESSION_ID_DISTINCT_COUNT_ORGANIZATION_ID_ASC
  AGENT_ACTIVITIES_BY_SESSION_ID_DISTINCT_COUNT_ORGANIZATION_ID_DESC
  AGENT_ACTIVITIES_BY_SESSION_ID_DISTINCT_COUNT_PROJECT_ID_ASC
  AGENT_ACTIVITIES_BY_SESSION_ID_DISTINCT_COUNT_PROJECT_ID_DESC
  AGENT_ACTIVITIES_BY_SESSION_ID_DISTINCT_COUNT_SESSION_ID_ASC
  AGENT_ACTIVITIES_BY_SESSION_ID_DISTINCT_COUNT_SESSION_ID_DESC
  AGENT_ACTIVITIES_BY_SESSION_ID_DISTINCT_COUNT_USER_ID_ASC
  AGENT_ACTIVITIES_BY_SESSION_ID_DISTINCT_COUNT_USER_ID_DESC
  AGENT_ACTIVITIES_BY_SESSION_ID_DISTINCT_COUNT_TOOL_NAME_ASC
  AGENT_ACTIVITIES_BY_SESSION_ID_DISTINCT_COUNT_TOOL_NAME_DESC
  AGENT_ACTIVITIES_BY_SESSION_ID_DISTINCT_COUNT_TOOL_INPUT_ASC
  AGENT_ACTIVITIES_BY_SESSION_ID_DISTINCT_COUNT_TOOL_INPUT_DESC
  AGENT_ACTIVITIES_BY_SESSION_ID_DISTINCT_COUNT_TOOL_OUTPUT_ASC
  AGENT_ACTIVITIES_BY_SESSION_ID_DISTINCT_COUNT_TOOL_OUTPUT_DESC
  AGENT_ACTIVITIES_BY_SESSION_ID_DISTINCT_COUNT_REQUIRES_APPROVAL_ASC
  AGENT_ACTIVITIES_BY_SESSION_ID_DISTINCT_COUNT_REQUIRES_APPROVAL_DESC
  AGENT_ACTIVITIES_BY_SESSION_ID_DISTINCT_COUNT_APPROVAL_STATUS_ASC
  AGENT_ACTIVITIES_BY_SESSION_ID_DISTINCT_COUNT_APPROVAL_STATUS_DESC
  AGENT_ACTIVITIES_BY_SESSION_ID_DISTINCT_COUNT_STATUS_ASC
  AGENT_ACTIVITIES_BY_SESSION_ID_DISTINCT_COUNT_STATUS_DESC
  AGENT_ACTIVITIES_BY_SESSION_ID_DISTINCT_COUNT_ERROR_MESSAGE_ASC
  AGENT_ACTIVITIES_BY_SESSION_ID_DISTINCT_COUNT_ERROR_MESSAGE_DESC
  AGENT_ACTIVITIES_BY_SESSION_ID_DISTINCT_COUNT_AFFECTED_TASK_IDS_ASC
  AGENT_ACTIVITIES_BY_SESSION_ID_DISTINCT_COUNT_AFFECTED_TASK_IDS_DESC
  AGENT_ACTIVITIES_BY_SESSION_ID_DISTINCT_COUNT_CREATED_AT_ASC
  AGENT_ACTIVITIES_BY_SESSION_ID_DISTINCT_COUNT_CREATED_AT_DESC
  AGENT_ACTIVITIES_BY_SESSION_ID_DISTINCT_COUNT_SNAPSHOT_BEFORE_ASC
  AGENT_ACTIVITIES_BY_SESSION_ID_DISTINCT_COUNT_SNAPSHOT_BEFORE_DESC
}

"""A connection to a list of `TaskLabel` values."""
type TaskLabelConnection {
  """A list of `TaskLabel` objects."""
  nodes: [TaskLabel!]!

  """
  A list of edges which contains the `TaskLabel` and cursor to aid in pagination.
  """
  edges: [TaskLabelEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `TaskLabel` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: TaskLabelAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `TaskLabel` for these aggregates."""
    groupBy: [TaskLabelGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: TaskLabelHavingInput
  ): [TaskLabelAggregates!]
}

type TaskLabel implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  taskId: UUID!
  labelId: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!

  """Reads a single `Label` that is related to this `TaskLabel`."""
  label: Label

  """Reads a single `Task` that is related to this `TaskLabel`."""
  task: Task
}

type Label implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  name: String!
  color: String!
  projectId: UUID
  createdAt: Datetime!
  updatedAt: Datetime!
  icon: String
  organizationId: String

  """Reads a single `Project` that is related to this `Label`."""
  project: Project

  """Reads and enables pagination through a set of `TaskLabel`."""
  taskLabels(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TaskLabelCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TaskLabelFilter

    """The method to use when ordering `TaskLabel`."""
    orderBy: [TaskLabelOrderBy!] = [PRIMARY_KEY_ASC]
  ): TaskLabelConnection!
}

"""
A condition to be used against `TaskLabel` object types. All fields are tested
for equality and combined with a logical and.
"""
input TaskLabelCondition {
  """Checks for equality with the objects `taskId` field."""
  taskId: UUID

  """Checks for equality with the objects `labelId` field."""
  labelId: UUID

  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the objects `updatedAt` field."""
  updatedAt: Datetime
}

"""Methods to use when ordering `TaskLabel`."""
enum TaskLabelOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  TASK_ID_ASC
  TASK_ID_DESC
  LABEL_ID_ASC
  LABEL_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

"""A `TaskLabel` edge in the connection."""
type TaskLabelEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `TaskLabel` at the end of the edge."""
  node: TaskLabel!
}

type TaskLabelAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: TaskLabelDistinctCountAggregates
}

type TaskLabelDistinctCountAggregates {
  """Distinct count of taskId across the matching connection"""
  taskId: BigInt

  """Distinct count of labelId across the matching connection"""
  labelId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

"""Grouping methods for `TaskLabel` for usage during aggregation."""
enum TaskLabelGroupBy {
  TASK_ID
  LABEL_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for `TaskLabel` aggregates."""
input TaskLabelHavingInput {
  AND: [TaskLabelHavingInput!]
  OR: [TaskLabelHavingInput!]
  sum: TaskLabelHavingSumInput
  distinctCount: TaskLabelHavingDistinctCountInput
  min: TaskLabelHavingMinInput
  max: TaskLabelHavingMaxInput
  average: TaskLabelHavingAverageInput
  stddevSample: TaskLabelHavingStddevSampleInput
  stddevPopulation: TaskLabelHavingStddevPopulationInput
  varianceSample: TaskLabelHavingVarianceSampleInput
  variancePopulation: TaskLabelHavingVariancePopulationInput
}

input TaskLabelHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TaskLabelHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TaskLabelHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TaskLabelHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TaskLabelHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TaskLabelHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TaskLabelHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TaskLabelHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input TaskLabelHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""A `Task` edge in the connection."""
type TaskEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Task` at the end of the edge."""
  node: Task!
}

type TaskAggregates {
  keys: [String]

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: TaskSumAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: TaskDistinctCountAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: TaskMinAggregates

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: TaskMaxAggregates

  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: TaskAverageAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: TaskStddevSampleAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: TaskStddevPopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: TaskVarianceSampleAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: TaskVariancePopulationAggregates
}

type TaskSumAggregates {
  """Sum of columnIndex across the matching connection"""
  columnIndex: BigInt!

  """Sum of number across the matching connection"""
  number: BigInt!
}

type TaskDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of content across the matching connection"""
  content: BigInt

  """Distinct count of description across the matching connection"""
  description: BigInt

  """Distinct count of priority across the matching connection"""
  priority: BigInt

  """Distinct count of authorId across the matching connection"""
  authorId: BigInt

  """Distinct count of columnId across the matching connection"""
  columnId: BigInt

  """Distinct count of dueDate across the matching connection"""
  dueDate: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt

  """Distinct count of columnIndex across the matching connection"""
  columnIndex: BigInt

  """Distinct count of projectId across the matching connection"""
  projectId: BigInt

  """Distinct count of number across the matching connection"""
  number: BigInt
}

type TaskMinAggregates {
  """Minimum of columnIndex across the matching connection"""
  columnIndex: Int

  """Minimum of number across the matching connection"""
  number: Int
}

type TaskMaxAggregates {
  """Maximum of columnIndex across the matching connection"""
  columnIndex: Int

  """Maximum of number across the matching connection"""
  number: Int
}

type TaskAverageAggregates {
  """Mean average of columnIndex across the matching connection"""
  columnIndex: BigFloat

  """Mean average of number across the matching connection"""
  number: BigFloat
}

type TaskStddevSampleAggregates {
  """
  Sample standard deviation of columnIndex across the matching connection
  """
  columnIndex: BigFloat

  """Sample standard deviation of number across the matching connection"""
  number: BigFloat
}

type TaskStddevPopulationAggregates {
  """
  Population standard deviation of columnIndex across the matching connection
  """
  columnIndex: BigFloat

  """Population standard deviation of number across the matching connection"""
  number: BigFloat
}

type TaskVarianceSampleAggregates {
  """Sample variance of columnIndex across the matching connection"""
  columnIndex: BigFloat

  """Sample variance of number across the matching connection"""
  number: BigFloat
}

type TaskVariancePopulationAggregates {
  """Population variance of columnIndex across the matching connection"""
  columnIndex: BigFloat

  """Population variance of number across the matching connection"""
  number: BigFloat
}

"""Grouping methods for `Task` for usage during aggregation."""
enum TaskGroupBy {
  CONTENT
  DESCRIPTION
  PRIORITY
  AUTHOR_ID
  COLUMN_ID
  DUE_DATE
  DUE_DATE_TRUNCATED_TO_HOUR
  DUE_DATE_TRUNCATED_TO_DAY
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
  COLUMN_INDEX
  PROJECT_ID
  NUMBER
}

"""Conditions for `Task` aggregates."""
input TaskHavingInput {
  AND: [TaskHavingInput!]
  OR: [TaskHavingInput!]
  sum: TaskHavingSumInput
  distinctCount: TaskHavingDistinctCountInput
  min: TaskHavingMinInput
  max: TaskHavingMaxInput
  average: TaskHavingAverageInput
  stddevSample: TaskHavingStddevSampleInput
  stddevPopulation: TaskHavingStddevPopulationInput
  varianceSample: TaskHavingVarianceSampleInput
  variancePopulation: TaskHavingVariancePopulationInput
}

input TaskHavingSumInput {
  dueDate: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  number: HavingIntFilter
}

input TaskHavingDistinctCountInput {
  dueDate: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  number: HavingIntFilter
}

input TaskHavingMinInput {
  dueDate: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  number: HavingIntFilter
}

input TaskHavingMaxInput {
  dueDate: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  number: HavingIntFilter
}

input TaskHavingAverageInput {
  dueDate: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  number: HavingIntFilter
}

input TaskHavingStddevSampleInput {
  dueDate: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  number: HavingIntFilter
}

input TaskHavingStddevPopulationInput {
  dueDate: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  number: HavingIntFilter
}

input TaskHavingVarianceSampleInput {
  dueDate: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  number: HavingIntFilter
}

input TaskHavingVariancePopulationInput {
  dueDate: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  columnIndex: HavingIntFilter
  number: HavingIntFilter
}

"""A `Column` edge in the connection."""
type ColumnEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Column` at the end of the edge."""
  node: Column!
}

type ColumnAggregates {
  keys: [String]

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: ColumnSumAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: ColumnDistinctCountAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: ColumnMinAggregates

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: ColumnMaxAggregates

  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: ColumnAverageAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: ColumnStddevSampleAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: ColumnStddevPopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: ColumnVarianceSampleAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: ColumnVariancePopulationAggregates
}

type ColumnSumAggregates {
  """Sum of index across the matching connection"""
  index: BigInt!
}

type ColumnDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of title across the matching connection"""
  title: BigInt

  """Distinct count of projectId across the matching connection"""
  projectId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt

  """Distinct count of index across the matching connection"""
  index: BigInt

  """Distinct count of icon across the matching connection"""
  icon: BigInt
}

type ColumnMinAggregates {
  """Minimum of index across the matching connection"""
  index: Int
}

type ColumnMaxAggregates {
  """Maximum of index across the matching connection"""
  index: Int
}

type ColumnAverageAggregates {
  """Mean average of index across the matching connection"""
  index: BigFloat
}

type ColumnStddevSampleAggregates {
  """Sample standard deviation of index across the matching connection"""
  index: BigFloat
}

type ColumnStddevPopulationAggregates {
  """Population standard deviation of index across the matching connection"""
  index: BigFloat
}

type ColumnVarianceSampleAggregates {
  """Sample variance of index across the matching connection"""
  index: BigFloat
}

type ColumnVariancePopulationAggregates {
  """Population variance of index across the matching connection"""
  index: BigFloat
}

"""Grouping methods for `Column` for usage during aggregation."""
enum ColumnGroupBy {
  TITLE
  PROJECT_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
  INDEX
  ICON
}

"""Conditions for `Column` aggregates."""
input ColumnHavingInput {
  AND: [ColumnHavingInput!]
  OR: [ColumnHavingInput!]
  sum: ColumnHavingSumInput
  distinctCount: ColumnHavingDistinctCountInput
  min: ColumnHavingMinInput
  max: ColumnHavingMaxInput
  average: ColumnHavingAverageInput
  stddevSample: ColumnHavingStddevSampleInput
  stddevPopulation: ColumnHavingStddevPopulationInput
  varianceSample: ColumnHavingVarianceSampleInput
  variancePopulation: ColumnHavingVariancePopulationInput
}

input ColumnHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  index: HavingIntFilter
}

input ColumnHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  index: HavingIntFilter
}

input ColumnHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  index: HavingIntFilter
}

input ColumnHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  index: HavingIntFilter
}

input ColumnHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  index: HavingIntFilter
}

input ColumnHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  index: HavingIntFilter
}

input ColumnHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  index: HavingIntFilter
}

input ColumnHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  index: HavingIntFilter
}

input ColumnHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  index: HavingIntFilter
}

"""
A condition to be used against `Column` object types. All fields are tested for equality and combined with a logical and.
"""
input ColumnCondition {
  """Checks for equality with the objects `rowId` field."""
  rowId: UUID

  """Checks for equality with the objects `title` field."""
  title: String

  """Checks for equality with the objects `projectId` field."""
  projectId: UUID

  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the objects `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the objects `index` field."""
  index: Int

  """Checks for equality with the objects `icon` field."""
  icon: String
}

"""Methods to use when ordering `Column`."""
enum ColumnOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  TITLE_ASC
  TITLE_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  INDEX_ASC
  INDEX_DESC
  ICON_ASC
  ICON_DESC
  TASKS_COUNT_ASC
  TASKS_COUNT_DESC
  TASKS_SUM_COLUMN_INDEX_ASC
  TASKS_SUM_COLUMN_INDEX_DESC
  TASKS_SUM_NUMBER_ASC
  TASKS_SUM_NUMBER_DESC
  TASKS_DISTINCT_COUNT_ROW_ID_ASC
  TASKS_DISTINCT_COUNT_ROW_ID_DESC
  TASKS_DISTINCT_COUNT_CONTENT_ASC
  TASKS_DISTINCT_COUNT_CONTENT_DESC
  TASKS_DISTINCT_COUNT_DESCRIPTION_ASC
  TASKS_DISTINCT_COUNT_DESCRIPTION_DESC
  TASKS_DISTINCT_COUNT_PRIORITY_ASC
  TASKS_DISTINCT_COUNT_PRIORITY_DESC
  TASKS_DISTINCT_COUNT_AUTHOR_ID_ASC
  TASKS_DISTINCT_COUNT_AUTHOR_ID_DESC
  TASKS_DISTINCT_COUNT_COLUMN_ID_ASC
  TASKS_DISTINCT_COUNT_COLUMN_ID_DESC
  TASKS_DISTINCT_COUNT_DUE_DATE_ASC
  TASKS_DISTINCT_COUNT_DUE_DATE_DESC
  TASKS_DISTINCT_COUNT_CREATED_AT_ASC
  TASKS_DISTINCT_COUNT_CREATED_AT_DESC
  TASKS_DISTINCT_COUNT_UPDATED_AT_ASC
  TASKS_DISTINCT_COUNT_UPDATED_AT_DESC
  TASKS_DISTINCT_COUNT_COLUMN_INDEX_ASC
  TASKS_DISTINCT_COUNT_COLUMN_INDEX_DESC
  TASKS_DISTINCT_COUNT_PROJECT_ID_ASC
  TASKS_DISTINCT_COUNT_PROJECT_ID_DESC
  TASKS_DISTINCT_COUNT_NUMBER_ASC
  TASKS_DISTINCT_COUNT_NUMBER_DESC
  TASKS_MIN_COLUMN_INDEX_ASC
  TASKS_MIN_COLUMN_INDEX_DESC
  TASKS_MIN_NUMBER_ASC
  TASKS_MIN_NUMBER_DESC
  TASKS_MAX_COLUMN_INDEX_ASC
  TASKS_MAX_COLUMN_INDEX_DESC
  TASKS_MAX_NUMBER_ASC
  TASKS_MAX_NUMBER_DESC
  TASKS_AVERAGE_COLUMN_INDEX_ASC
  TASKS_AVERAGE_COLUMN_INDEX_DESC
  TASKS_AVERAGE_NUMBER_ASC
  TASKS_AVERAGE_NUMBER_DESC
  TASKS_STDDEV_SAMPLE_COLUMN_INDEX_ASC
  TASKS_STDDEV_SAMPLE_COLUMN_INDEX_DESC
  TASKS_STDDEV_SAMPLE_NUMBER_ASC
  TASKS_STDDEV_SAMPLE_NUMBER_DESC
  TASKS_STDDEV_POPULATION_COLUMN_INDEX_ASC
  TASKS_STDDEV_POPULATION_COLUMN_INDEX_DESC
  TASKS_STDDEV_POPULATION_NUMBER_ASC
  TASKS_STDDEV_POPULATION_NUMBER_DESC
  TASKS_VARIANCE_SAMPLE_COLUMN_INDEX_ASC
  TASKS_VARIANCE_SAMPLE_COLUMN_INDEX_DESC
  TASKS_VARIANCE_SAMPLE_NUMBER_ASC
  TASKS_VARIANCE_SAMPLE_NUMBER_DESC
  TASKS_VARIANCE_POPULATION_COLUMN_INDEX_ASC
  TASKS_VARIANCE_POPULATION_COLUMN_INDEX_DESC
  TASKS_VARIANCE_POPULATION_NUMBER_ASC
  TASKS_VARIANCE_POPULATION_NUMBER_DESC
}

"""A connection to a list of `Label` values."""
type LabelConnection {
  """A list of `Label` objects."""
  nodes: [Label!]!

  """
  A list of edges which contains the `Label` and cursor to aid in pagination.
  """
  edges: [LabelEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Label` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: LabelAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Label` for these aggregates."""
    groupBy: [LabelGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: LabelHavingInput
  ): [LabelAggregates!]
}

"""A `Label` edge in the connection."""
type LabelEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Label` at the end of the edge."""
  node: Label!
}

type LabelAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: LabelDistinctCountAggregates
}

type LabelDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of name across the matching connection"""
  name: BigInt

  """Distinct count of color across the matching connection"""
  color: BigInt

  """Distinct count of projectId across the matching connection"""
  projectId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt

  """Distinct count of icon across the matching connection"""
  icon: BigInt

  """Distinct count of organizationId across the matching connection"""
  organizationId: BigInt
}

"""Grouping methods for `Label` for usage during aggregation."""
enum LabelGroupBy {
  NAME
  COLOR
  PROJECT_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
  ICON
  ORGANIZATION_ID
}

"""Conditions for `Label` aggregates."""
input LabelHavingInput {
  AND: [LabelHavingInput!]
  OR: [LabelHavingInput!]
  sum: LabelHavingSumInput
  distinctCount: LabelHavingDistinctCountInput
  min: LabelHavingMinInput
  max: LabelHavingMaxInput
  average: LabelHavingAverageInput
  stddevSample: LabelHavingStddevSampleInput
  stddevPopulation: LabelHavingStddevPopulationInput
  varianceSample: LabelHavingVarianceSampleInput
  variancePopulation: LabelHavingVariancePopulationInput
}

input LabelHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input LabelHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input LabelHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input LabelHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input LabelHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input LabelHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input LabelHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input LabelHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input LabelHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""
A condition to be used against `Label` object types. All fields are tested for equality and combined with a logical and.
"""
input LabelCondition {
  """Checks for equality with the objects `rowId` field."""
  rowId: UUID

  """Checks for equality with the objects `name` field."""
  name: String

  """Checks for equality with the objects `color` field."""
  color: String

  """Checks for equality with the objects `projectId` field."""
  projectId: UUID

  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the objects `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the objects `icon` field."""
  icon: String

  """Checks for equality with the objects `organizationId` field."""
  organizationId: String
}

"""Methods to use when ordering `Label`."""
enum LabelOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  NAME_ASC
  NAME_DESC
  COLOR_ASC
  COLOR_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  ICON_ASC
  ICON_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  TASK_LABELS_COUNT_ASC
  TASK_LABELS_COUNT_DESC
  TASK_LABELS_DISTINCT_COUNT_TASK_ID_ASC
  TASK_LABELS_DISTINCT_COUNT_TASK_ID_DESC
  TASK_LABELS_DISTINCT_COUNT_LABEL_ID_ASC
  TASK_LABELS_DISTINCT_COUNT_LABEL_ID_DESC
  TASK_LABELS_DISTINCT_COUNT_CREATED_AT_ASC
  TASK_LABELS_DISTINCT_COUNT_CREATED_AT_DESC
  TASK_LABELS_DISTINCT_COUNT_UPDATED_AT_ASC
  TASK_LABELS_DISTINCT_COUNT_UPDATED_AT_DESC
}

"""A connection to a list of `ProjectProjectLabel` values."""
type ProjectProjectLabelConnection {
  """A list of `ProjectProjectLabel` objects."""
  nodes: [ProjectProjectLabel!]!

  """
  A list of edges which contains the `ProjectProjectLabel` and cursor to aid in pagination.
  """
  edges: [ProjectProjectLabelEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `ProjectProjectLabel` you could get from the connection.
  """
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: ProjectProjectLabelAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """
    The method to use when grouping `ProjectProjectLabel` for these aggregates.
    """
    groupBy: [ProjectProjectLabelGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: ProjectProjectLabelHavingInput
  ): [ProjectProjectLabelAggregates!]
}

"""A `ProjectProjectLabel` edge in the connection."""
type ProjectProjectLabelEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ProjectProjectLabel` at the end of the edge."""
  node: ProjectProjectLabel!
}

type ProjectProjectLabelAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: ProjectProjectLabelDistinctCountAggregates
}

type ProjectProjectLabelDistinctCountAggregates {
  """Distinct count of projectId across the matching connection"""
  projectId: BigInt

  """Distinct count of projectLabelId across the matching connection"""
  projectLabelId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt
}

"""
Grouping methods for `ProjectProjectLabel` for usage during aggregation.
"""
enum ProjectProjectLabelGroupBy {
  PROJECT_ID
  PROJECT_LABEL_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for `ProjectProjectLabel` aggregates."""
input ProjectProjectLabelHavingInput {
  AND: [ProjectProjectLabelHavingInput!]
  OR: [ProjectProjectLabelHavingInput!]
  sum: ProjectProjectLabelHavingSumInput
  distinctCount: ProjectProjectLabelHavingDistinctCountInput
  min: ProjectProjectLabelHavingMinInput
  max: ProjectProjectLabelHavingMaxInput
  average: ProjectProjectLabelHavingAverageInput
  stddevSample: ProjectProjectLabelHavingStddevSampleInput
  stddevPopulation: ProjectProjectLabelHavingStddevPopulationInput
  varianceSample: ProjectProjectLabelHavingVarianceSampleInput
  variancePopulation: ProjectProjectLabelHavingVariancePopulationInput
}

input ProjectProjectLabelHavingSumInput {
  createdAt: HavingDatetimeFilter
}

input ProjectProjectLabelHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
}

input ProjectProjectLabelHavingMinInput {
  createdAt: HavingDatetimeFilter
}

input ProjectProjectLabelHavingMaxInput {
  createdAt: HavingDatetimeFilter
}

input ProjectProjectLabelHavingAverageInput {
  createdAt: HavingDatetimeFilter
}

input ProjectProjectLabelHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
}

input ProjectProjectLabelHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
}

input ProjectProjectLabelHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
}

input ProjectProjectLabelHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
}

"""
A condition to be used against `ProjectProjectLabel` object types. All fields
are tested for equality and combined with a logical and.
"""
input ProjectProjectLabelCondition {
  """Checks for equality with the objects `projectId` field."""
  projectId: UUID

  """Checks for equality with the objects `projectLabelId` field."""
  projectLabelId: UUID

  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
}

"""Methods to use when ordering `ProjectProjectLabel`."""
enum ProjectProjectLabelOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
  PROJECT_LABEL_ID_ASC
  PROJECT_LABEL_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
}

"""A connection to a list of `AgentSchedule` values."""
type AgentScheduleConnection {
  """A list of `AgentSchedule` objects."""
  nodes: [AgentSchedule!]!

  """
  A list of edges which contains the `AgentSchedule` and cursor to aid in pagination.
  """
  edges: [AgentScheduleEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `AgentSchedule` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: AgentScheduleAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `AgentSchedule` for these aggregates."""
    groupBy: [AgentScheduleGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: AgentScheduleHavingInput
  ): [AgentScheduleAggregates!]
}

type AgentSchedule implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  organizationId: String!
  projectId: UUID!
  name: String!
  cronExpression: String!
  instruction: String!
  personaId: UUID
  enabled: Boolean!
  lastRunAt: Datetime
  nextRunAt: Datetime
  createdAt: Datetime!
  updatedAt: Datetime!

  """Reads a single `AgentPersona` that is related to this `AgentSchedule`."""
  persona: AgentPersona

  """Reads a single `Project` that is related to this `AgentSchedule`."""
  project: Project
}

type AgentPersona implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  organizationId: String!
  name: String!
  description: String
  systemPrompt: String!
  icon: String
  enabled: Boolean!
  createdAt: Datetime!
  updatedAt: Datetime!

  """
  Reads and enables pagination through a set of `AgentMarketplaceListing`.
  """
  agentMarketplaceListingsByPersonaId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AgentMarketplaceListingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AgentMarketplaceListingFilter

    """The method to use when ordering `AgentMarketplaceListing`."""
    orderBy: [AgentMarketplaceListingOrderBy!] = [PRIMARY_KEY_ASC]
  ): AgentMarketplaceListingConnection!

  """Reads and enables pagination through a set of `AgentSchedule`."""
  agentSchedulesByPersonaId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AgentScheduleCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AgentScheduleFilter

    """The method to use when ordering `AgentSchedule`."""
    orderBy: [AgentScheduleOrderBy!] = [PRIMARY_KEY_ASC]
  ): AgentScheduleConnection!
}

"""A connection to a list of `AgentMarketplaceListing` values."""
type AgentMarketplaceListingConnection {
  """A list of `AgentMarketplaceListing` objects."""
  nodes: [AgentMarketplaceListing!]!

  """
  A list of edges which contains the `AgentMarketplaceListing` and cursor to aid in pagination.
  """
  edges: [AgentMarketplaceListingEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `AgentMarketplaceListing` you could get from the connection.
  """
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: AgentMarketplaceListingAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """
    The method to use when grouping `AgentMarketplaceListing` for these aggregates.
    """
    groupBy: [AgentMarketplaceListingGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: AgentMarketplaceListingHavingInput
  ): [AgentMarketplaceListingAggregates!]
}

type AgentMarketplaceListing implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  personaId: UUID!
  organizationId: String!
  title: String!
  description: String
  category: String!
  installCount: Int!
  publishedAt: Datetime!
  createdAt: Datetime!
  updatedAt: Datetime!

  """
  Reads a single `AgentPersona` that is related to this `AgentMarketplaceListing`.
  """
  persona: AgentPersona
}

"""A `AgentMarketplaceListing` edge in the connection."""
type AgentMarketplaceListingEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `AgentMarketplaceListing` at the end of the edge."""
  node: AgentMarketplaceListing!
}

type AgentMarketplaceListingAggregates {
  keys: [String]

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: AgentMarketplaceListingSumAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: AgentMarketplaceListingDistinctCountAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: AgentMarketplaceListingMinAggregates

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: AgentMarketplaceListingMaxAggregates

  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: AgentMarketplaceListingAverageAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: AgentMarketplaceListingStddevSampleAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: AgentMarketplaceListingStddevPopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: AgentMarketplaceListingVarianceSampleAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: AgentMarketplaceListingVariancePopulationAggregates
}

type AgentMarketplaceListingSumAggregates {
  """Sum of installCount across the matching connection"""
  installCount: BigInt!
}

type AgentMarketplaceListingDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of personaId across the matching connection"""
  personaId: BigInt

  """Distinct count of organizationId across the matching connection"""
  organizationId: BigInt

  """Distinct count of title across the matching connection"""
  title: BigInt

  """Distinct count of description across the matching connection"""
  description: BigInt

  """Distinct count of category across the matching connection"""
  category: BigInt

  """Distinct count of installCount across the matching connection"""
  installCount: BigInt

  """Distinct count of publishedAt across the matching connection"""
  publishedAt: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

type AgentMarketplaceListingMinAggregates {
  """Minimum of installCount across the matching connection"""
  installCount: Int
}

type AgentMarketplaceListingMaxAggregates {
  """Maximum of installCount across the matching connection"""
  installCount: Int
}

type AgentMarketplaceListingAverageAggregates {
  """Mean average of installCount across the matching connection"""
  installCount: BigFloat
}

type AgentMarketplaceListingStddevSampleAggregates {
  """
  Sample standard deviation of installCount across the matching connection
  """
  installCount: BigFloat
}

type AgentMarketplaceListingStddevPopulationAggregates {
  """
  Population standard deviation of installCount across the matching connection
  """
  installCount: BigFloat
}

type AgentMarketplaceListingVarianceSampleAggregates {
  """Sample variance of installCount across the matching connection"""
  installCount: BigFloat
}

type AgentMarketplaceListingVariancePopulationAggregates {
  """Population variance of installCount across the matching connection"""
  installCount: BigFloat
}

"""
Grouping methods for `AgentMarketplaceListing` for usage during aggregation.
"""
enum AgentMarketplaceListingGroupBy {
  PERSONA_ID
  ORGANIZATION_ID
  TITLE
  DESCRIPTION
  CATEGORY
  INSTALL_COUNT
  PUBLISHED_AT
  PUBLISHED_AT_TRUNCATED_TO_HOUR
  PUBLISHED_AT_TRUNCATED_TO_DAY
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for `AgentMarketplaceListing` aggregates."""
input AgentMarketplaceListingHavingInput {
  AND: [AgentMarketplaceListingHavingInput!]
  OR: [AgentMarketplaceListingHavingInput!]
  sum: AgentMarketplaceListingHavingSumInput
  distinctCount: AgentMarketplaceListingHavingDistinctCountInput
  min: AgentMarketplaceListingHavingMinInput
  max: AgentMarketplaceListingHavingMaxInput
  average: AgentMarketplaceListingHavingAverageInput
  stddevSample: AgentMarketplaceListingHavingStddevSampleInput
  stddevPopulation: AgentMarketplaceListingHavingStddevPopulationInput
  varianceSample: AgentMarketplaceListingHavingVarianceSampleInput
  variancePopulation: AgentMarketplaceListingHavingVariancePopulationInput
}

input AgentMarketplaceListingHavingSumInput {
  installCount: HavingIntFilter
  publishedAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentMarketplaceListingHavingDistinctCountInput {
  installCount: HavingIntFilter
  publishedAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentMarketplaceListingHavingMinInput {
  installCount: HavingIntFilter
  publishedAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentMarketplaceListingHavingMaxInput {
  installCount: HavingIntFilter
  publishedAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentMarketplaceListingHavingAverageInput {
  installCount: HavingIntFilter
  publishedAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentMarketplaceListingHavingStddevSampleInput {
  installCount: HavingIntFilter
  publishedAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentMarketplaceListingHavingStddevPopulationInput {
  installCount: HavingIntFilter
  publishedAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentMarketplaceListingHavingVarianceSampleInput {
  installCount: HavingIntFilter
  publishedAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentMarketplaceListingHavingVariancePopulationInput {
  installCount: HavingIntFilter
  publishedAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""
A condition to be used against `AgentMarketplaceListing` object types. All
fields are tested for equality and combined with a logical and.
"""
input AgentMarketplaceListingCondition {
  """Checks for equality with the objects `rowId` field."""
  rowId: UUID

  """Checks for equality with the objects `personaId` field."""
  personaId: UUID

  """Checks for equality with the objects `organizationId` field."""
  organizationId: String

  """Checks for equality with the objects `title` field."""
  title: String

  """Checks for equality with the objects `description` field."""
  description: String

  """Checks for equality with the objects `category` field."""
  category: String

  """Checks for equality with the objects `installCount` field."""
  installCount: Int

  """Checks for equality with the objects `publishedAt` field."""
  publishedAt: Datetime

  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the objects `updatedAt` field."""
  updatedAt: Datetime
}

"""Methods to use when ordering `AgentMarketplaceListing`."""
enum AgentMarketplaceListingOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  PERSONA_ID_ASC
  PERSONA_ID_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  TITLE_ASC
  TITLE_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  CATEGORY_ASC
  CATEGORY_DESC
  INSTALL_COUNT_ASC
  INSTALL_COUNT_DESC
  PUBLISHED_AT_ASC
  PUBLISHED_AT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

"""
A condition to be used against `AgentSchedule` object types. All fields are
tested for equality and combined with a logical and.
"""
input AgentScheduleCondition {
  """Checks for equality with the objects `rowId` field."""
  rowId: UUID

  """Checks for equality with the objects `organizationId` field."""
  organizationId: String

  """Checks for equality with the objects `projectId` field."""
  projectId: UUID

  """Checks for equality with the objects `name` field."""
  name: String

  """Checks for equality with the objects `cronExpression` field."""
  cronExpression: String

  """Checks for equality with the objects `instruction` field."""
  instruction: String

  """Checks for equality with the objects `personaId` field."""
  personaId: UUID

  """Checks for equality with the objects `enabled` field."""
  enabled: Boolean

  """Checks for equality with the objects `lastRunAt` field."""
  lastRunAt: Datetime

  """Checks for equality with the objects `nextRunAt` field."""
  nextRunAt: Datetime

  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the objects `updatedAt` field."""
  updatedAt: Datetime
}

"""Methods to use when ordering `AgentSchedule`."""
enum AgentScheduleOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
  NAME_ASC
  NAME_DESC
  CRON_EXPRESSION_ASC
  CRON_EXPRESSION_DESC
  INSTRUCTION_ASC
  INSTRUCTION_DESC
  PERSONA_ID_ASC
  PERSONA_ID_DESC
  ENABLED_ASC
  ENABLED_DESC
  LAST_RUN_AT_ASC
  LAST_RUN_AT_DESC
  NEXT_RUN_AT_ASC
  NEXT_RUN_AT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

"""A `AgentSchedule` edge in the connection."""
type AgentScheduleEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `AgentSchedule` at the end of the edge."""
  node: AgentSchedule!
}

type AgentScheduleAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: AgentScheduleDistinctCountAggregates
}

type AgentScheduleDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of organizationId across the matching connection"""
  organizationId: BigInt

  """Distinct count of projectId across the matching connection"""
  projectId: BigInt

  """Distinct count of name across the matching connection"""
  name: BigInt

  """Distinct count of cronExpression across the matching connection"""
  cronExpression: BigInt

  """Distinct count of instruction across the matching connection"""
  instruction: BigInt

  """Distinct count of personaId across the matching connection"""
  personaId: BigInt

  """Distinct count of enabled across the matching connection"""
  enabled: BigInt

  """Distinct count of lastRunAt across the matching connection"""
  lastRunAt: BigInt

  """Distinct count of nextRunAt across the matching connection"""
  nextRunAt: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

"""Grouping methods for `AgentSchedule` for usage during aggregation."""
enum AgentScheduleGroupBy {
  ORGANIZATION_ID
  PROJECT_ID
  NAME
  CRON_EXPRESSION
  INSTRUCTION
  PERSONA_ID
  ENABLED
  LAST_RUN_AT
  LAST_RUN_AT_TRUNCATED_TO_HOUR
  LAST_RUN_AT_TRUNCATED_TO_DAY
  NEXT_RUN_AT
  NEXT_RUN_AT_TRUNCATED_TO_HOUR
  NEXT_RUN_AT_TRUNCATED_TO_DAY
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for `AgentSchedule` aggregates."""
input AgentScheduleHavingInput {
  AND: [AgentScheduleHavingInput!]
  OR: [AgentScheduleHavingInput!]
  sum: AgentScheduleHavingSumInput
  distinctCount: AgentScheduleHavingDistinctCountInput
  min: AgentScheduleHavingMinInput
  max: AgentScheduleHavingMaxInput
  average: AgentScheduleHavingAverageInput
  stddevSample: AgentScheduleHavingStddevSampleInput
  stddevPopulation: AgentScheduleHavingStddevPopulationInput
  varianceSample: AgentScheduleHavingVarianceSampleInput
  variancePopulation: AgentScheduleHavingVariancePopulationInput
}

input AgentScheduleHavingSumInput {
  lastRunAt: HavingDatetimeFilter
  nextRunAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentScheduleHavingDistinctCountInput {
  lastRunAt: HavingDatetimeFilter
  nextRunAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentScheduleHavingMinInput {
  lastRunAt: HavingDatetimeFilter
  nextRunAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentScheduleHavingMaxInput {
  lastRunAt: HavingDatetimeFilter
  nextRunAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentScheduleHavingAverageInput {
  lastRunAt: HavingDatetimeFilter
  nextRunAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentScheduleHavingStddevSampleInput {
  lastRunAt: HavingDatetimeFilter
  nextRunAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentScheduleHavingStddevPopulationInput {
  lastRunAt: HavingDatetimeFilter
  nextRunAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentScheduleHavingVarianceSampleInput {
  lastRunAt: HavingDatetimeFilter
  nextRunAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentScheduleHavingVariancePopulationInput {
  lastRunAt: HavingDatetimeFilter
  nextRunAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""A connection to a list of `AgentWebhook` values."""
type AgentWebhookConnection {
  """A list of `AgentWebhook` objects."""
  nodes: [AgentWebhook!]!

  """
  A list of edges which contains the `AgentWebhook` and cursor to aid in pagination.
  """
  edges: [AgentWebhookEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `AgentWebhook` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: AgentWebhookAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `AgentWebhook` for these aggregates."""
    groupBy: [AgentWebhookGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: AgentWebhookHavingInput
  ): [AgentWebhookAggregates!]
}

type AgentWebhook implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  organizationId: String!
  projectId: UUID!
  name: String!
  eventType: String!
  instructionTemplate: String!
  signingSecret: String!
  enabled: Boolean!
  lastTriggeredAt: Datetime
  createdAt: Datetime!
  updatedAt: Datetime!

  """Reads a single `Project` that is related to this `AgentWebhook`."""
  project: Project
}

"""A `AgentWebhook` edge in the connection."""
type AgentWebhookEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `AgentWebhook` at the end of the edge."""
  node: AgentWebhook!
}

type AgentWebhookAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: AgentWebhookDistinctCountAggregates
}

type AgentWebhookDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of organizationId across the matching connection"""
  organizationId: BigInt

  """Distinct count of projectId across the matching connection"""
  projectId: BigInt

  """Distinct count of name across the matching connection"""
  name: BigInt

  """Distinct count of eventType across the matching connection"""
  eventType: BigInt

  """Distinct count of instructionTemplate across the matching connection"""
  instructionTemplate: BigInt

  """Distinct count of signingSecret across the matching connection"""
  signingSecret: BigInt

  """Distinct count of enabled across the matching connection"""
  enabled: BigInt

  """Distinct count of lastTriggeredAt across the matching connection"""
  lastTriggeredAt: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

"""Grouping methods for `AgentWebhook` for usage during aggregation."""
enum AgentWebhookGroupBy {
  ORGANIZATION_ID
  PROJECT_ID
  NAME
  EVENT_TYPE
  INSTRUCTION_TEMPLATE
  SIGNING_SECRET
  ENABLED
  LAST_TRIGGERED_AT
  LAST_TRIGGERED_AT_TRUNCATED_TO_HOUR
  LAST_TRIGGERED_AT_TRUNCATED_TO_DAY
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for `AgentWebhook` aggregates."""
input AgentWebhookHavingInput {
  AND: [AgentWebhookHavingInput!]
  OR: [AgentWebhookHavingInput!]
  sum: AgentWebhookHavingSumInput
  distinctCount: AgentWebhookHavingDistinctCountInput
  min: AgentWebhookHavingMinInput
  max: AgentWebhookHavingMaxInput
  average: AgentWebhookHavingAverageInput
  stddevSample: AgentWebhookHavingStddevSampleInput
  stddevPopulation: AgentWebhookHavingStddevPopulationInput
  varianceSample: AgentWebhookHavingVarianceSampleInput
  variancePopulation: AgentWebhookHavingVariancePopulationInput
}

input AgentWebhookHavingSumInput {
  lastTriggeredAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentWebhookHavingDistinctCountInput {
  lastTriggeredAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentWebhookHavingMinInput {
  lastTriggeredAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentWebhookHavingMaxInput {
  lastTriggeredAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentWebhookHavingAverageInput {
  lastTriggeredAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentWebhookHavingStddevSampleInput {
  lastTriggeredAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentWebhookHavingStddevPopulationInput {
  lastTriggeredAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentWebhookHavingVarianceSampleInput {
  lastTriggeredAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentWebhookHavingVariancePopulationInput {
  lastTriggeredAt: HavingDatetimeFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""
A condition to be used against `AgentWebhook` object types. All fields are
tested for equality and combined with a logical and.
"""
input AgentWebhookCondition {
  """Checks for equality with the objects `rowId` field."""
  rowId: UUID

  """Checks for equality with the objects `organizationId` field."""
  organizationId: String

  """Checks for equality with the objects `projectId` field."""
  projectId: UUID

  """Checks for equality with the objects `name` field."""
  name: String

  """Checks for equality with the objects `eventType` field."""
  eventType: String

  """Checks for equality with the objects `instructionTemplate` field."""
  instructionTemplate: String

  """Checks for equality with the objects `signingSecret` field."""
  signingSecret: String

  """Checks for equality with the objects `enabled` field."""
  enabled: Boolean

  """Checks for equality with the objects `lastTriggeredAt` field."""
  lastTriggeredAt: Datetime

  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the objects `updatedAt` field."""
  updatedAt: Datetime
}

"""Methods to use when ordering `AgentWebhook`."""
enum AgentWebhookOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
  NAME_ASC
  NAME_DESC
  EVENT_TYPE_ASC
  EVENT_TYPE_DESC
  INSTRUCTION_TEMPLATE_ASC
  INSTRUCTION_TEMPLATE_DESC
  SIGNING_SECRET_ASC
  SIGNING_SECRET_DESC
  ENABLED_ASC
  ENABLED_DESC
  LAST_TRIGGERED_AT_ASC
  LAST_TRIGGERED_AT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

type ProjectLabel implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  name: String!
  color: String!
  icon: String
  organizationId: String!
  createdAt: Datetime!
  updatedAt: Datetime!

  """Reads and enables pagination through a set of `ProjectProjectLabel`."""
  projectProjectLabels(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectProjectLabelCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectProjectLabelFilter

    """The method to use when ordering `ProjectProjectLabel`."""
    orderBy: [ProjectProjectLabelOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectProjectLabelConnection!
}

type Setting implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!
  viewMode: String!
  billingAccountId: String
  organizationId: String!
  subscriptionId: String
  deletedAt: Datetime
  deletionReason: String
}

type AgentConfig implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  organizationId: String!
  model: String!
  enabled: Boolean!
  maxIterationsPerRequest: Int!
  requireApprovalForDestructive: Boolean!
  requireApprovalForCreate: Boolean!
  customInstructions: String
  createdAt: Datetime!
  updatedAt: Datetime!
  encryptedApiKey: String
  defaultPersonaId: UUID
}

"""A connection to a list of `User` values."""
type UserConnection {
  """A list of `User` objects."""
  nodes: [User!]!

  """
  A list of edges which contains the `User` and cursor to aid in pagination.
  """
  edges: [UserEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: UserAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `User` for these aggregates."""
    groupBy: [UserGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: UserHavingInput
  ): [UserAggregates!]
}

"""A `User` edge in the connection."""
type UserEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `User` at the end of the edge."""
  node: User!
}

type UserAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: UserDistinctCountAggregates
}

type UserDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of identityProviderId across the matching connection"""
  identityProviderId: BigInt

  """Distinct count of name across the matching connection"""
  name: BigInt

  """Distinct count of avatarUrl across the matching connection"""
  avatarUrl: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt

  """Distinct count of email across the matching connection"""
  email: BigInt
}

"""Grouping methods for `User` for usage during aggregation."""
enum UserGroupBy {
  NAME
  AVATAR_URL
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for `User` aggregates."""
input UserHavingInput {
  AND: [UserHavingInput!]
  OR: [UserHavingInput!]
  sum: UserHavingSumInput
  distinctCount: UserHavingDistinctCountInput
  min: UserHavingMinInput
  max: UserHavingMaxInput
  average: UserHavingAverageInput
  stddevSample: UserHavingStddevSampleInput
  stddevPopulation: UserHavingStddevPopulationInput
  varianceSample: UserHavingVarianceSampleInput
  variancePopulation: UserHavingVariancePopulationInput
}

input UserHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""
A condition to be used against `User` object types. All fields are tested for equality and combined with a logical and.
"""
input UserCondition {
  """Checks for equality with the objects `rowId` field."""
  rowId: UUID

  """Checks for equality with the objects `identityProviderId` field."""
  identityProviderId: UUID

  """Checks for equality with the objects `name` field."""
  name: String

  """Checks for equality with the objects `avatarUrl` field."""
  avatarUrl: String

  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the objects `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the objects `email` field."""
  email: String
}

"""Methods to use when ordering `User`."""
enum UserOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  IDENTITY_PROVIDER_ID_ASC
  IDENTITY_PROVIDER_ID_DESC
  NAME_ASC
  NAME_DESC
  AVATAR_URL_ASC
  AVATAR_URL_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  EMAIL_ASC
  EMAIL_DESC
  ASSIGNEES_COUNT_ASC
  ASSIGNEES_COUNT_DESC
  ASSIGNEES_DISTINCT_COUNT_USER_ID_ASC
  ASSIGNEES_DISTINCT_COUNT_USER_ID_DESC
  ASSIGNEES_DISTINCT_COUNT_TASK_ID_ASC
  ASSIGNEES_DISTINCT_COUNT_TASK_ID_DESC
  ASSIGNEES_DISTINCT_COUNT_CREATED_AT_ASC
  ASSIGNEES_DISTINCT_COUNT_CREATED_AT_DESC
  ASSIGNEES_DISTINCT_COUNT_UPDATED_AT_ASC
  ASSIGNEES_DISTINCT_COUNT_UPDATED_AT_DESC
  ASSIGNEES_DISTINCT_COUNT_DELETED_AT_ASC
  ASSIGNEES_DISTINCT_COUNT_DELETED_AT_DESC
  AUTHORED_POSTS_COUNT_ASC
  AUTHORED_POSTS_COUNT_DESC
  AUTHORED_POSTS_DISTINCT_COUNT_ROW_ID_ASC
  AUTHORED_POSTS_DISTINCT_COUNT_ROW_ID_DESC
  AUTHORED_POSTS_DISTINCT_COUNT_TITLE_ASC
  AUTHORED_POSTS_DISTINCT_COUNT_TITLE_DESC
  AUTHORED_POSTS_DISTINCT_COUNT_DESCRIPTION_ASC
  AUTHORED_POSTS_DISTINCT_COUNT_DESCRIPTION_DESC
  AUTHORED_POSTS_DISTINCT_COUNT_AUTHOR_ID_ASC
  AUTHORED_POSTS_DISTINCT_COUNT_AUTHOR_ID_DESC
  AUTHORED_POSTS_DISTINCT_COUNT_TASK_ID_ASC
  AUTHORED_POSTS_DISTINCT_COUNT_TASK_ID_DESC
  AUTHORED_POSTS_DISTINCT_COUNT_CREATED_AT_ASC
  AUTHORED_POSTS_DISTINCT_COUNT_CREATED_AT_DESC
  AUTHORED_POSTS_DISTINCT_COUNT_UPDATED_AT_ASC
  AUTHORED_POSTS_DISTINCT_COUNT_UPDATED_AT_DESC
  AUTHORED_TASKS_COUNT_ASC
  AUTHORED_TASKS_COUNT_DESC
  AUTHORED_TASKS_SUM_COLUMN_INDEX_ASC
  AUTHORED_TASKS_SUM_COLUMN_INDEX_DESC
  AUTHORED_TASKS_SUM_NUMBER_ASC
  AUTHORED_TASKS_SUM_NUMBER_DESC
  AUTHORED_TASKS_DISTINCT_COUNT_ROW_ID_ASC
  AUTHORED_TASKS_DISTINCT_COUNT_ROW_ID_DESC
  AUTHORED_TASKS_DISTINCT_COUNT_CONTENT_ASC
  AUTHORED_TASKS_DISTINCT_COUNT_CONTENT_DESC
  AUTHORED_TASKS_DISTINCT_COUNT_DESCRIPTION_ASC
  AUTHORED_TASKS_DISTINCT_COUNT_DESCRIPTION_DESC
  AUTHORED_TASKS_DISTINCT_COUNT_PRIORITY_ASC
  AUTHORED_TASKS_DISTINCT_COUNT_PRIORITY_DESC
  AUTHORED_TASKS_DISTINCT_COUNT_AUTHOR_ID_ASC
  AUTHORED_TASKS_DISTINCT_COUNT_AUTHOR_ID_DESC
  AUTHORED_TASKS_DISTINCT_COUNT_COLUMN_ID_ASC
  AUTHORED_TASKS_DISTINCT_COUNT_COLUMN_ID_DESC
  AUTHORED_TASKS_DISTINCT_COUNT_DUE_DATE_ASC
  AUTHORED_TASKS_DISTINCT_COUNT_DUE_DATE_DESC
  AUTHORED_TASKS_DISTINCT_COUNT_CREATED_AT_ASC
  AUTHORED_TASKS_DISTINCT_COUNT_CREATED_AT_DESC
  AUTHORED_TASKS_DISTINCT_COUNT_UPDATED_AT_ASC
  AUTHORED_TASKS_DISTINCT_COUNT_UPDATED_AT_DESC
  AUTHORED_TASKS_DISTINCT_COUNT_COLUMN_INDEX_ASC
  AUTHORED_TASKS_DISTINCT_COUNT_COLUMN_INDEX_DESC
  AUTHORED_TASKS_DISTINCT_COUNT_PROJECT_ID_ASC
  AUTHORED_TASKS_DISTINCT_COUNT_PROJECT_ID_DESC
  AUTHORED_TASKS_DISTINCT_COUNT_NUMBER_ASC
  AUTHORED_TASKS_DISTINCT_COUNT_NUMBER_DESC
  AUTHORED_TASKS_MIN_COLUMN_INDEX_ASC
  AUTHORED_TASKS_MIN_COLUMN_INDEX_DESC
  AUTHORED_TASKS_MIN_NUMBER_ASC
  AUTHORED_TASKS_MIN_NUMBER_DESC
  AUTHORED_TASKS_MAX_COLUMN_INDEX_ASC
  AUTHORED_TASKS_MAX_COLUMN_INDEX_DESC
  AUTHORED_TASKS_MAX_NUMBER_ASC
  AUTHORED_TASKS_MAX_NUMBER_DESC
  AUTHORED_TASKS_AVERAGE_COLUMN_INDEX_ASC
  AUTHORED_TASKS_AVERAGE_COLUMN_INDEX_DESC
  AUTHORED_TASKS_AVERAGE_NUMBER_ASC
  AUTHORED_TASKS_AVERAGE_NUMBER_DESC
  AUTHORED_TASKS_STDDEV_SAMPLE_COLUMN_INDEX_ASC
  AUTHORED_TASKS_STDDEV_SAMPLE_COLUMN_INDEX_DESC
  AUTHORED_TASKS_STDDEV_SAMPLE_NUMBER_ASC
  AUTHORED_TASKS_STDDEV_SAMPLE_NUMBER_DESC
  AUTHORED_TASKS_STDDEV_POPULATION_COLUMN_INDEX_ASC
  AUTHORED_TASKS_STDDEV_POPULATION_COLUMN_INDEX_DESC
  AUTHORED_TASKS_STDDEV_POPULATION_NUMBER_ASC
  AUTHORED_TASKS_STDDEV_POPULATION_NUMBER_DESC
  AUTHORED_TASKS_VARIANCE_SAMPLE_COLUMN_INDEX_ASC
  AUTHORED_TASKS_VARIANCE_SAMPLE_COLUMN_INDEX_DESC
  AUTHORED_TASKS_VARIANCE_SAMPLE_NUMBER_ASC
  AUTHORED_TASKS_VARIANCE_SAMPLE_NUMBER_DESC
  AUTHORED_TASKS_VARIANCE_POPULATION_COLUMN_INDEX_ASC
  AUTHORED_TASKS_VARIANCE_POPULATION_COLUMN_INDEX_DESC
  AUTHORED_TASKS_VARIANCE_POPULATION_NUMBER_ASC
  AUTHORED_TASKS_VARIANCE_POPULATION_NUMBER_DESC
  USER_PREFERENCES_COUNT_ASC
  USER_PREFERENCES_COUNT_DESC
  USER_PREFERENCES_DISTINCT_COUNT_ROW_ID_ASC
  USER_PREFERENCES_DISTINCT_COUNT_ROW_ID_DESC
  USER_PREFERENCES_DISTINCT_COUNT_USER_ID_ASC
  USER_PREFERENCES_DISTINCT_COUNT_USER_ID_DESC
  USER_PREFERENCES_DISTINCT_COUNT_PROJECT_ID_ASC
  USER_PREFERENCES_DISTINCT_COUNT_PROJECT_ID_DESC
  USER_PREFERENCES_DISTINCT_COUNT_HIDDEN_COLUMN_IDS_ASC
  USER_PREFERENCES_DISTINCT_COUNT_HIDDEN_COLUMN_IDS_DESC
  USER_PREFERENCES_DISTINCT_COUNT_CREATED_AT_ASC
  USER_PREFERENCES_DISTINCT_COUNT_CREATED_AT_DESC
  USER_PREFERENCES_DISTINCT_COUNT_UPDATED_AT_ASC
  USER_PREFERENCES_DISTINCT_COUNT_UPDATED_AT_DESC
  USER_PREFERENCES_DISTINCT_COUNT_VIEW_MODE_ASC
  USER_PREFERENCES_DISTINCT_COUNT_VIEW_MODE_DESC
  USER_PREFERENCES_DISTINCT_COUNT_COLOR_ASC
  USER_PREFERENCES_DISTINCT_COUNT_COLOR_DESC
  EMOJIS_COUNT_ASC
  EMOJIS_COUNT_DESC
  EMOJIS_DISTINCT_COUNT_ROW_ID_ASC
  EMOJIS_DISTINCT_COUNT_ROW_ID_DESC
  EMOJIS_DISTINCT_COUNT_EMOJI_ASC
  EMOJIS_DISTINCT_COUNT_EMOJI_DESC
  EMOJIS_DISTINCT_COUNT_POST_ID_ASC
  EMOJIS_DISTINCT_COUNT_POST_ID_DESC
  EMOJIS_DISTINCT_COUNT_USER_ID_ASC
  EMOJIS_DISTINCT_COUNT_USER_ID_DESC
  EMOJIS_DISTINCT_COUNT_CREATED_AT_ASC
  EMOJIS_DISTINCT_COUNT_CREATED_AT_DESC
  EMOJIS_DISTINCT_COUNT_UPDATED_AT_ASC
  EMOJIS_DISTINCT_COUNT_UPDATED_AT_DESC
  USER_ORGANIZATIONS_COUNT_ASC
  USER_ORGANIZATIONS_COUNT_DESC
  USER_ORGANIZATIONS_DISTINCT_COUNT_ROW_ID_ASC
  USER_ORGANIZATIONS_DISTINCT_COUNT_ROW_ID_DESC
  USER_ORGANIZATIONS_DISTINCT_COUNT_USER_ID_ASC
  USER_ORGANIZATIONS_DISTINCT_COUNT_USER_ID_DESC
  USER_ORGANIZATIONS_DISTINCT_COUNT_ORGANIZATION_ID_ASC
  USER_ORGANIZATIONS_DISTINCT_COUNT_ORGANIZATION_ID_DESC
  USER_ORGANIZATIONS_DISTINCT_COUNT_SLUG_ASC
  USER_ORGANIZATIONS_DISTINCT_COUNT_SLUG_DESC
  USER_ORGANIZATIONS_DISTINCT_COUNT_NAME_ASC
  USER_ORGANIZATIONS_DISTINCT_COUNT_NAME_DESC
  USER_ORGANIZATIONS_DISTINCT_COUNT_TYPE_ASC
  USER_ORGANIZATIONS_DISTINCT_COUNT_TYPE_DESC
  USER_ORGANIZATIONS_DISTINCT_COUNT_ROLE_ASC
  USER_ORGANIZATIONS_DISTINCT_COUNT_ROLE_DESC
  USER_ORGANIZATIONS_DISTINCT_COUNT_SYNCED_AT_ASC
  USER_ORGANIZATIONS_DISTINCT_COUNT_SYNCED_AT_DESC
  USER_ORGANIZATIONS_DISTINCT_COUNT_CREATED_AT_ASC
  USER_ORGANIZATIONS_DISTINCT_COUNT_CREATED_AT_DESC
  USER_ORGANIZATIONS_DISTINCT_COUNT_UPDATED_AT_ASC
  USER_ORGANIZATIONS_DISTINCT_COUNT_UPDATED_AT_DESC
  AGENT_ACTIVITIES_COUNT_ASC
  AGENT_ACTIVITIES_COUNT_DESC
  AGENT_ACTIVITIES_DISTINCT_COUNT_ROW_ID_ASC
  AGENT_ACTIVITIES_DISTINCT_COUNT_ROW_ID_DESC
  AGENT_ACTIVITIES_DISTINCT_COUNT_ORGANIZATION_ID_ASC
  AGENT_ACTIVITIES_DISTINCT_COUNT_ORGANIZATION_ID_DESC
  AGENT_ACTIVITIES_DISTINCT_COUNT_PROJECT_ID_ASC
  AGENT_ACTIVITIES_DISTINCT_COUNT_PROJECT_ID_DESC
  AGENT_ACTIVITIES_DISTINCT_COUNT_SESSION_ID_ASC
  AGENT_ACTIVITIES_DISTINCT_COUNT_SESSION_ID_DESC
  AGENT_ACTIVITIES_DISTINCT_COUNT_USER_ID_ASC
  AGENT_ACTIVITIES_DISTINCT_COUNT_USER_ID_DESC
  AGENT_ACTIVITIES_DISTINCT_COUNT_TOOL_NAME_ASC
  AGENT_ACTIVITIES_DISTINCT_COUNT_TOOL_NAME_DESC
  AGENT_ACTIVITIES_DISTINCT_COUNT_TOOL_INPUT_ASC
  AGENT_ACTIVITIES_DISTINCT_COUNT_TOOL_INPUT_DESC
  AGENT_ACTIVITIES_DISTINCT_COUNT_TOOL_OUTPUT_ASC
  AGENT_ACTIVITIES_DISTINCT_COUNT_TOOL_OUTPUT_DESC
  AGENT_ACTIVITIES_DISTINCT_COUNT_REQUIRES_APPROVAL_ASC
  AGENT_ACTIVITIES_DISTINCT_COUNT_REQUIRES_APPROVAL_DESC
  AGENT_ACTIVITIES_DISTINCT_COUNT_APPROVAL_STATUS_ASC
  AGENT_ACTIVITIES_DISTINCT_COUNT_APPROVAL_STATUS_DESC
  AGENT_ACTIVITIES_DISTINCT_COUNT_STATUS_ASC
  AGENT_ACTIVITIES_DISTINCT_COUNT_STATUS_DESC
  AGENT_ACTIVITIES_DISTINCT_COUNT_ERROR_MESSAGE_ASC
  AGENT_ACTIVITIES_DISTINCT_COUNT_ERROR_MESSAGE_DESC
  AGENT_ACTIVITIES_DISTINCT_COUNT_AFFECTED_TASK_IDS_ASC
  AGENT_ACTIVITIES_DISTINCT_COUNT_AFFECTED_TASK_IDS_DESC
  AGENT_ACTIVITIES_DISTINCT_COUNT_CREATED_AT_ASC
  AGENT_ACTIVITIES_DISTINCT_COUNT_CREATED_AT_DESC
  AGENT_ACTIVITIES_DISTINCT_COUNT_SNAPSHOT_BEFORE_ASC
  AGENT_ACTIVITIES_DISTINCT_COUNT_SNAPSHOT_BEFORE_DESC
  AGENT_SESSIONS_COUNT_ASC
  AGENT_SESSIONS_COUNT_DESC
  AGENT_SESSIONS_SUM_TOTAL_TOKENS_USED_ASC
  AGENT_SESSIONS_SUM_TOTAL_TOKENS_USED_DESC
  AGENT_SESSIONS_SUM_TOOL_CALL_COUNT_ASC
  AGENT_SESSIONS_SUM_TOOL_CALL_COUNT_DESC
  AGENT_SESSIONS_DISTINCT_COUNT_ROW_ID_ASC
  AGENT_SESSIONS_DISTINCT_COUNT_ROW_ID_DESC
  AGENT_SESSIONS_DISTINCT_COUNT_ORGANIZATION_ID_ASC
  AGENT_SESSIONS_DISTINCT_COUNT_ORGANIZATION_ID_DESC
  AGENT_SESSIONS_DISTINCT_COUNT_PROJECT_ID_ASC
  AGENT_SESSIONS_DISTINCT_COUNT_PROJECT_ID_DESC
  AGENT_SESSIONS_DISTINCT_COUNT_USER_ID_ASC
  AGENT_SESSIONS_DISTINCT_COUNT_USER_ID_DESC
  AGENT_SESSIONS_DISTINCT_COUNT_TITLE_ASC
  AGENT_SESSIONS_DISTINCT_COUNT_TITLE_DESC
  AGENT_SESSIONS_DISTINCT_COUNT_MESSAGES_ASC
  AGENT_SESSIONS_DISTINCT_COUNT_MESSAGES_DESC
  AGENT_SESSIONS_DISTINCT_COUNT_TOTAL_TOKENS_USED_ASC
  AGENT_SESSIONS_DISTINCT_COUNT_TOTAL_TOKENS_USED_DESC
  AGENT_SESSIONS_DISTINCT_COUNT_TOOL_CALL_COUNT_ASC
  AGENT_SESSIONS_DISTINCT_COUNT_TOOL_CALL_COUNT_DESC
  AGENT_SESSIONS_DISTINCT_COUNT_CREATED_AT_ASC
  AGENT_SESSIONS_DISTINCT_COUNT_CREATED_AT_DESC
  AGENT_SESSIONS_DISTINCT_COUNT_UPDATED_AT_ASC
  AGENT_SESSIONS_DISTINCT_COUNT_UPDATED_AT_DESC
  AGENT_SESSIONS_DISTINCT_COUNT_TYPE_ASC
  AGENT_SESSIONS_DISTINCT_COUNT_TYPE_DESC
  AGENT_SESSIONS_MIN_TOTAL_TOKENS_USED_ASC
  AGENT_SESSIONS_MIN_TOTAL_TOKENS_USED_DESC
  AGENT_SESSIONS_MIN_TOOL_CALL_COUNT_ASC
  AGENT_SESSIONS_MIN_TOOL_CALL_COUNT_DESC
  AGENT_SESSIONS_MAX_TOTAL_TOKENS_USED_ASC
  AGENT_SESSIONS_MAX_TOTAL_TOKENS_USED_DESC
  AGENT_SESSIONS_MAX_TOOL_CALL_COUNT_ASC
  AGENT_SESSIONS_MAX_TOOL_CALL_COUNT_DESC
  AGENT_SESSIONS_AVERAGE_TOTAL_TOKENS_USED_ASC
  AGENT_SESSIONS_AVERAGE_TOTAL_TOKENS_USED_DESC
  AGENT_SESSIONS_AVERAGE_TOOL_CALL_COUNT_ASC
  AGENT_SESSIONS_AVERAGE_TOOL_CALL_COUNT_DESC
  AGENT_SESSIONS_STDDEV_SAMPLE_TOTAL_TOKENS_USED_ASC
  AGENT_SESSIONS_STDDEV_SAMPLE_TOTAL_TOKENS_USED_DESC
  AGENT_SESSIONS_STDDEV_SAMPLE_TOOL_CALL_COUNT_ASC
  AGENT_SESSIONS_STDDEV_SAMPLE_TOOL_CALL_COUNT_DESC
  AGENT_SESSIONS_STDDEV_POPULATION_TOTAL_TOKENS_USED_ASC
  AGENT_SESSIONS_STDDEV_POPULATION_TOTAL_TOKENS_USED_DESC
  AGENT_SESSIONS_STDDEV_POPULATION_TOOL_CALL_COUNT_ASC
  AGENT_SESSIONS_STDDEV_POPULATION_TOOL_CALL_COUNT_DESC
  AGENT_SESSIONS_VARIANCE_SAMPLE_TOTAL_TOKENS_USED_ASC
  AGENT_SESSIONS_VARIANCE_SAMPLE_TOTAL_TOKENS_USED_DESC
  AGENT_SESSIONS_VARIANCE_SAMPLE_TOOL_CALL_COUNT_ASC
  AGENT_SESSIONS_VARIANCE_SAMPLE_TOOL_CALL_COUNT_DESC
  AGENT_SESSIONS_VARIANCE_POPULATION_TOTAL_TOKENS_USED_ASC
  AGENT_SESSIONS_VARIANCE_POPULATION_TOTAL_TOKENS_USED_DESC
  AGENT_SESSIONS_VARIANCE_POPULATION_TOOL_CALL_COUNT_ASC
  AGENT_SESSIONS_VARIANCE_POPULATION_TOOL_CALL_COUNT_DESC
}

"""A connection to a list of `ProjectLabel` values."""
type ProjectLabelConnection {
  """A list of `ProjectLabel` objects."""
  nodes: [ProjectLabel!]!

  """
  A list of edges which contains the `ProjectLabel` and cursor to aid in pagination.
  """
  edges: [ProjectLabelEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `ProjectLabel` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: ProjectLabelAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `ProjectLabel` for these aggregates."""
    groupBy: [ProjectLabelGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: ProjectLabelHavingInput
  ): [ProjectLabelAggregates!]
}

"""A `ProjectLabel` edge in the connection."""
type ProjectLabelEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ProjectLabel` at the end of the edge."""
  node: ProjectLabel!
}

type ProjectLabelAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: ProjectLabelDistinctCountAggregates
}

type ProjectLabelDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of name across the matching connection"""
  name: BigInt

  """Distinct count of color across the matching connection"""
  color: BigInt

  """Distinct count of icon across the matching connection"""
  icon: BigInt

  """Distinct count of organizationId across the matching connection"""
  organizationId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

"""Grouping methods for `ProjectLabel` for usage during aggregation."""
enum ProjectLabelGroupBy {
  NAME
  COLOR
  ICON
  ORGANIZATION_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for `ProjectLabel` aggregates."""
input ProjectLabelHavingInput {
  AND: [ProjectLabelHavingInput!]
  OR: [ProjectLabelHavingInput!]
  sum: ProjectLabelHavingSumInput
  distinctCount: ProjectLabelHavingDistinctCountInput
  min: ProjectLabelHavingMinInput
  max: ProjectLabelHavingMaxInput
  average: ProjectLabelHavingAverageInput
  stddevSample: ProjectLabelHavingStddevSampleInput
  stddevPopulation: ProjectLabelHavingStddevPopulationInput
  varianceSample: ProjectLabelHavingVarianceSampleInput
  variancePopulation: ProjectLabelHavingVariancePopulationInput
}

input ProjectLabelHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectLabelHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectLabelHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectLabelHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectLabelHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectLabelHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectLabelHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectLabelHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectLabelHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""
A condition to be used against `ProjectLabel` object types. All fields are
tested for equality and combined with a logical and.
"""
input ProjectLabelCondition {
  """Checks for equality with the objects `rowId` field."""
  rowId: UUID

  """Checks for equality with the objects `name` field."""
  name: String

  """Checks for equality with the objects `color` field."""
  color: String

  """Checks for equality with the objects `icon` field."""
  icon: String

  """Checks for equality with the objects `organizationId` field."""
  organizationId: String

  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the objects `updatedAt` field."""
  updatedAt: Datetime
}

"""Methods to use when ordering `ProjectLabel`."""
enum ProjectLabelOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  NAME_ASC
  NAME_DESC
  COLOR_ASC
  COLOR_DESC
  ICON_ASC
  ICON_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PROJECT_PROJECT_LABELS_COUNT_ASC
  PROJECT_PROJECT_LABELS_COUNT_DESC
  PROJECT_PROJECT_LABELS_DISTINCT_COUNT_PROJECT_ID_ASC
  PROJECT_PROJECT_LABELS_DISTINCT_COUNT_PROJECT_ID_DESC
  PROJECT_PROJECT_LABELS_DISTINCT_COUNT_PROJECT_LABEL_ID_ASC
  PROJECT_PROJECT_LABELS_DISTINCT_COUNT_PROJECT_LABEL_ID_DESC
  PROJECT_PROJECT_LABELS_DISTINCT_COUNT_CREATED_AT_ASC
  PROJECT_PROJECT_LABELS_DISTINCT_COUNT_CREATED_AT_DESC
}

"""A connection to a list of `AgentPersona` values."""
type AgentPersonaConnection {
  """A list of `AgentPersona` objects."""
  nodes: [AgentPersona!]!

  """
  A list of edges which contains the `AgentPersona` and cursor to aid in pagination.
  """
  edges: [AgentPersonaEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `AgentPersona` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: AgentPersonaAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `AgentPersona` for these aggregates."""
    groupBy: [AgentPersonaGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: AgentPersonaHavingInput
  ): [AgentPersonaAggregates!]
}

"""A `AgentPersona` edge in the connection."""
type AgentPersonaEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `AgentPersona` at the end of the edge."""
  node: AgentPersona!
}

type AgentPersonaAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: AgentPersonaDistinctCountAggregates
}

type AgentPersonaDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of organizationId across the matching connection"""
  organizationId: BigInt

  """Distinct count of name across the matching connection"""
  name: BigInt

  """Distinct count of description across the matching connection"""
  description: BigInt

  """Distinct count of systemPrompt across the matching connection"""
  systemPrompt: BigInt

  """Distinct count of icon across the matching connection"""
  icon: BigInt

  """Distinct count of enabled across the matching connection"""
  enabled: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

"""Grouping methods for `AgentPersona` for usage during aggregation."""
enum AgentPersonaGroupBy {
  ORGANIZATION_ID
  NAME
  DESCRIPTION
  SYSTEM_PROMPT
  ICON
  ENABLED
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for `AgentPersona` aggregates."""
input AgentPersonaHavingInput {
  AND: [AgentPersonaHavingInput!]
  OR: [AgentPersonaHavingInput!]
  sum: AgentPersonaHavingSumInput
  distinctCount: AgentPersonaHavingDistinctCountInput
  min: AgentPersonaHavingMinInput
  max: AgentPersonaHavingMaxInput
  average: AgentPersonaHavingAverageInput
  stddevSample: AgentPersonaHavingStddevSampleInput
  stddevPopulation: AgentPersonaHavingStddevPopulationInput
  varianceSample: AgentPersonaHavingVarianceSampleInput
  variancePopulation: AgentPersonaHavingVariancePopulationInput
}

input AgentPersonaHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentPersonaHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentPersonaHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentPersonaHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentPersonaHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentPersonaHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentPersonaHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentPersonaHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentPersonaHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""
A condition to be used against `AgentPersona` object types. All fields are
tested for equality and combined with a logical and.
"""
input AgentPersonaCondition {
  """Checks for equality with the objects `rowId` field."""
  rowId: UUID

  """Checks for equality with the objects `organizationId` field."""
  organizationId: String

  """Checks for equality with the objects `name` field."""
  name: String

  """Checks for equality with the objects `description` field."""
  description: String

  """Checks for equality with the objects `systemPrompt` field."""
  systemPrompt: String

  """Checks for equality with the objects `icon` field."""
  icon: String

  """Checks for equality with the objects `enabled` field."""
  enabled: Boolean

  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the objects `updatedAt` field."""
  updatedAt: Datetime
}

"""Methods to use when ordering `AgentPersona`."""
enum AgentPersonaOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  SYSTEM_PROMPT_ASC
  SYSTEM_PROMPT_DESC
  ICON_ASC
  ICON_DESC
  ENABLED_ASC
  ENABLED_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_COUNT_ASC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_COUNT_DESC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_SUM_INSTALL_COUNT_ASC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_SUM_INSTALL_COUNT_DESC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_DISTINCT_COUNT_ROW_ID_ASC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_DISTINCT_COUNT_ROW_ID_DESC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_DISTINCT_COUNT_PERSONA_ID_ASC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_DISTINCT_COUNT_PERSONA_ID_DESC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_DISTINCT_COUNT_ORGANIZATION_ID_ASC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_DISTINCT_COUNT_ORGANIZATION_ID_DESC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_DISTINCT_COUNT_TITLE_ASC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_DISTINCT_COUNT_TITLE_DESC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_DISTINCT_COUNT_DESCRIPTION_ASC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_DISTINCT_COUNT_DESCRIPTION_DESC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_DISTINCT_COUNT_CATEGORY_ASC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_DISTINCT_COUNT_CATEGORY_DESC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_DISTINCT_COUNT_INSTALL_COUNT_ASC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_DISTINCT_COUNT_INSTALL_COUNT_DESC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_DISTINCT_COUNT_PUBLISHED_AT_ASC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_DISTINCT_COUNT_PUBLISHED_AT_DESC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_DISTINCT_COUNT_CREATED_AT_ASC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_DISTINCT_COUNT_CREATED_AT_DESC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_DISTINCT_COUNT_UPDATED_AT_ASC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_DISTINCT_COUNT_UPDATED_AT_DESC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_MIN_INSTALL_COUNT_ASC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_MIN_INSTALL_COUNT_DESC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_MAX_INSTALL_COUNT_ASC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_MAX_INSTALL_COUNT_DESC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_AVERAGE_INSTALL_COUNT_ASC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_AVERAGE_INSTALL_COUNT_DESC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_STDDEV_SAMPLE_INSTALL_COUNT_ASC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_STDDEV_SAMPLE_INSTALL_COUNT_DESC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_STDDEV_POPULATION_INSTALL_COUNT_ASC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_STDDEV_POPULATION_INSTALL_COUNT_DESC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_VARIANCE_SAMPLE_INSTALL_COUNT_ASC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_VARIANCE_SAMPLE_INSTALL_COUNT_DESC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_VARIANCE_POPULATION_INSTALL_COUNT_ASC
  AGENT_MARKETPLACE_LISTINGS_BY_PERSONA_ID_VARIANCE_POPULATION_INSTALL_COUNT_DESC
  AGENT_SCHEDULES_BY_PERSONA_ID_COUNT_ASC
  AGENT_SCHEDULES_BY_PERSONA_ID_COUNT_DESC
  AGENT_SCHEDULES_BY_PERSONA_ID_DISTINCT_COUNT_ROW_ID_ASC
  AGENT_SCHEDULES_BY_PERSONA_ID_DISTINCT_COUNT_ROW_ID_DESC
  AGENT_SCHEDULES_BY_PERSONA_ID_DISTINCT_COUNT_ORGANIZATION_ID_ASC
  AGENT_SCHEDULES_BY_PERSONA_ID_DISTINCT_COUNT_ORGANIZATION_ID_DESC
  AGENT_SCHEDULES_BY_PERSONA_ID_DISTINCT_COUNT_PROJECT_ID_ASC
  AGENT_SCHEDULES_BY_PERSONA_ID_DISTINCT_COUNT_PROJECT_ID_DESC
  AGENT_SCHEDULES_BY_PERSONA_ID_DISTINCT_COUNT_NAME_ASC
  AGENT_SCHEDULES_BY_PERSONA_ID_DISTINCT_COUNT_NAME_DESC
  AGENT_SCHEDULES_BY_PERSONA_ID_DISTINCT_COUNT_CRON_EXPRESSION_ASC
  AGENT_SCHEDULES_BY_PERSONA_ID_DISTINCT_COUNT_CRON_EXPRESSION_DESC
  AGENT_SCHEDULES_BY_PERSONA_ID_DISTINCT_COUNT_INSTRUCTION_ASC
  AGENT_SCHEDULES_BY_PERSONA_ID_DISTINCT_COUNT_INSTRUCTION_DESC
  AGENT_SCHEDULES_BY_PERSONA_ID_DISTINCT_COUNT_PERSONA_ID_ASC
  AGENT_SCHEDULES_BY_PERSONA_ID_DISTINCT_COUNT_PERSONA_ID_DESC
  AGENT_SCHEDULES_BY_PERSONA_ID_DISTINCT_COUNT_ENABLED_ASC
  AGENT_SCHEDULES_BY_PERSONA_ID_DISTINCT_COUNT_ENABLED_DESC
  AGENT_SCHEDULES_BY_PERSONA_ID_DISTINCT_COUNT_LAST_RUN_AT_ASC
  AGENT_SCHEDULES_BY_PERSONA_ID_DISTINCT_COUNT_LAST_RUN_AT_DESC
  AGENT_SCHEDULES_BY_PERSONA_ID_DISTINCT_COUNT_NEXT_RUN_AT_ASC
  AGENT_SCHEDULES_BY_PERSONA_ID_DISTINCT_COUNT_NEXT_RUN_AT_DESC
  AGENT_SCHEDULES_BY_PERSONA_ID_DISTINCT_COUNT_CREATED_AT_ASC
  AGENT_SCHEDULES_BY_PERSONA_ID_DISTINCT_COUNT_CREATED_AT_DESC
  AGENT_SCHEDULES_BY_PERSONA_ID_DISTINCT_COUNT_UPDATED_AT_ASC
  AGENT_SCHEDULES_BY_PERSONA_ID_DISTINCT_COUNT_UPDATED_AT_DESC
}

"""A connection to a list of `ProjectColumn` values."""
type ProjectColumnConnection {
  """A list of `ProjectColumn` objects."""
  nodes: [ProjectColumn!]!

  """
  A list of edges which contains the `ProjectColumn` and cursor to aid in pagination.
  """
  edges: [ProjectColumnEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `ProjectColumn` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: ProjectColumnAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `ProjectColumn` for these aggregates."""
    groupBy: [ProjectColumnGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: ProjectColumnHavingInput
  ): [ProjectColumnAggregates!]
}

"""A `ProjectColumn` edge in the connection."""
type ProjectColumnEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ProjectColumn` at the end of the edge."""
  node: ProjectColumn!
}

type ProjectColumnAggregates {
  keys: [String]

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: ProjectColumnSumAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: ProjectColumnDistinctCountAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: ProjectColumnMinAggregates

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: ProjectColumnMaxAggregates

  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: ProjectColumnAverageAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: ProjectColumnStddevSampleAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: ProjectColumnStddevPopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: ProjectColumnVarianceSampleAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: ProjectColumnVariancePopulationAggregates
}

type ProjectColumnSumAggregates {
  """Sum of index across the matching connection"""
  index: BigInt!
}

type ProjectColumnDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of icon across the matching connection"""
  icon: BigInt

  """Distinct count of title across the matching connection"""
  title: BigInt

  """Distinct count of organizationId across the matching connection"""
  organizationId: BigInt

  """Distinct count of index across the matching connection"""
  index: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

type ProjectColumnMinAggregates {
  """Minimum of index across the matching connection"""
  index: Int
}

type ProjectColumnMaxAggregates {
  """Maximum of index across the matching connection"""
  index: Int
}

type ProjectColumnAverageAggregates {
  """Mean average of index across the matching connection"""
  index: BigFloat
}

type ProjectColumnStddevSampleAggregates {
  """Sample standard deviation of index across the matching connection"""
  index: BigFloat
}

type ProjectColumnStddevPopulationAggregates {
  """Population standard deviation of index across the matching connection"""
  index: BigFloat
}

type ProjectColumnVarianceSampleAggregates {
  """Sample variance of index across the matching connection"""
  index: BigFloat
}

type ProjectColumnVariancePopulationAggregates {
  """Population variance of index across the matching connection"""
  index: BigFloat
}

"""Grouping methods for `ProjectColumn` for usage during aggregation."""
enum ProjectColumnGroupBy {
  ICON
  TITLE
  ORGANIZATION_ID
  INDEX
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for `ProjectColumn` aggregates."""
input ProjectColumnHavingInput {
  AND: [ProjectColumnHavingInput!]
  OR: [ProjectColumnHavingInput!]
  sum: ProjectColumnHavingSumInput
  distinctCount: ProjectColumnHavingDistinctCountInput
  min: ProjectColumnHavingMinInput
  max: ProjectColumnHavingMaxInput
  average: ProjectColumnHavingAverageInput
  stddevSample: ProjectColumnHavingStddevSampleInput
  stddevPopulation: ProjectColumnHavingStddevPopulationInput
  varianceSample: ProjectColumnHavingVarianceSampleInput
  variancePopulation: ProjectColumnHavingVariancePopulationInput
}

input ProjectColumnHavingSumInput {
  index: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectColumnHavingDistinctCountInput {
  index: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectColumnHavingMinInput {
  index: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectColumnHavingMaxInput {
  index: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectColumnHavingAverageInput {
  index: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectColumnHavingStddevSampleInput {
  index: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectColumnHavingStddevPopulationInput {
  index: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectColumnHavingVarianceSampleInput {
  index: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectColumnHavingVariancePopulationInput {
  index: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""
A condition to be used against `ProjectColumn` object types. All fields are
tested for equality and combined with a logical and.
"""
input ProjectColumnCondition {
  """Checks for equality with the objects `rowId` field."""
  rowId: UUID

  """Checks for equality with the objects `icon` field."""
  icon: String

  """Checks for equality with the objects `title` field."""
  title: String

  """Checks for equality with the objects `organizationId` field."""
  organizationId: String

  """Checks for equality with the objects `index` field."""
  index: Int

  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the objects `updatedAt` field."""
  updatedAt: Datetime
}

"""Methods to use when ordering `ProjectColumn`."""
enum ProjectColumnOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  ICON_ASC
  ICON_DESC
  TITLE_ASC
  TITLE_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  INDEX_ASC
  INDEX_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PROJECTS_COUNT_ASC
  PROJECTS_COUNT_DESC
  PROJECTS_SUM_COLUMN_INDEX_ASC
  PROJECTS_SUM_COLUMN_INDEX_DESC
  PROJECTS_SUM_NEXT_TASK_NUMBER_ASC
  PROJECTS_SUM_NEXT_TASK_NUMBER_DESC
  PROJECTS_DISTINCT_COUNT_ROW_ID_ASC
  PROJECTS_DISTINCT_COUNT_ROW_ID_DESC
  PROJECTS_DISTINCT_COUNT_NAME_ASC
  PROJECTS_DISTINCT_COUNT_NAME_DESC
  PROJECTS_DISTINCT_COUNT_DESCRIPTION_ASC
  PROJECTS_DISTINCT_COUNT_DESCRIPTION_DESC
  PROJECTS_DISTINCT_COUNT_PREFIX_ASC
  PROJECTS_DISTINCT_COUNT_PREFIX_DESC
  PROJECTS_DISTINCT_COUNT_ORGANIZATION_ID_ASC
  PROJECTS_DISTINCT_COUNT_ORGANIZATION_ID_DESC
  PROJECTS_DISTINCT_COUNT_CREATED_AT_ASC
  PROJECTS_DISTINCT_COUNT_CREATED_AT_DESC
  PROJECTS_DISTINCT_COUNT_UPDATED_AT_ASC
  PROJECTS_DISTINCT_COUNT_UPDATED_AT_DESC
  PROJECTS_DISTINCT_COUNT_PROJECT_COLUMN_ID_ASC
  PROJECTS_DISTINCT_COUNT_PROJECT_COLUMN_ID_DESC
  PROJECTS_DISTINCT_COUNT_SLUG_ASC
  PROJECTS_DISTINCT_COUNT_SLUG_DESC
  PROJECTS_DISTINCT_COUNT_COLUMN_INDEX_ASC
  PROJECTS_DISTINCT_COUNT_COLUMN_INDEX_DESC
  PROJECTS_DISTINCT_COUNT_IS_PUBLIC_ASC
  PROJECTS_DISTINCT_COUNT_IS_PUBLIC_DESC
  PROJECTS_DISTINCT_COUNT_NEXT_TASK_NUMBER_ASC
  PROJECTS_DISTINCT_COUNT_NEXT_TASK_NUMBER_DESC
  PROJECTS_MIN_COLUMN_INDEX_ASC
  PROJECTS_MIN_COLUMN_INDEX_DESC
  PROJECTS_MIN_NEXT_TASK_NUMBER_ASC
  PROJECTS_MIN_NEXT_TASK_NUMBER_DESC
  PROJECTS_MAX_COLUMN_INDEX_ASC
  PROJECTS_MAX_COLUMN_INDEX_DESC
  PROJECTS_MAX_NEXT_TASK_NUMBER_ASC
  PROJECTS_MAX_NEXT_TASK_NUMBER_DESC
  PROJECTS_AVERAGE_COLUMN_INDEX_ASC
  PROJECTS_AVERAGE_COLUMN_INDEX_DESC
  PROJECTS_AVERAGE_NEXT_TASK_NUMBER_ASC
  PROJECTS_AVERAGE_NEXT_TASK_NUMBER_DESC
  PROJECTS_STDDEV_SAMPLE_COLUMN_INDEX_ASC
  PROJECTS_STDDEV_SAMPLE_COLUMN_INDEX_DESC
  PROJECTS_STDDEV_SAMPLE_NEXT_TASK_NUMBER_ASC
  PROJECTS_STDDEV_SAMPLE_NEXT_TASK_NUMBER_DESC
  PROJECTS_STDDEV_POPULATION_COLUMN_INDEX_ASC
  PROJECTS_STDDEV_POPULATION_COLUMN_INDEX_DESC
  PROJECTS_STDDEV_POPULATION_NEXT_TASK_NUMBER_ASC
  PROJECTS_STDDEV_POPULATION_NEXT_TASK_NUMBER_DESC
  PROJECTS_VARIANCE_SAMPLE_COLUMN_INDEX_ASC
  PROJECTS_VARIANCE_SAMPLE_COLUMN_INDEX_DESC
  PROJECTS_VARIANCE_SAMPLE_NEXT_TASK_NUMBER_ASC
  PROJECTS_VARIANCE_SAMPLE_NEXT_TASK_NUMBER_DESC
  PROJECTS_VARIANCE_POPULATION_COLUMN_INDEX_ASC
  PROJECTS_VARIANCE_POPULATION_COLUMN_INDEX_DESC
  PROJECTS_VARIANCE_POPULATION_NEXT_TASK_NUMBER_ASC
  PROJECTS_VARIANCE_POPULATION_NEXT_TASK_NUMBER_DESC
}

"""A connection to a list of `Setting` values."""
type SettingConnection {
  """A list of `Setting` objects."""
  nodes: [Setting!]!

  """
  A list of edges which contains the `Setting` and cursor to aid in pagination.
  """
  edges: [SettingEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Setting` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: SettingAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `Setting` for these aggregates."""
    groupBy: [SettingGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: SettingHavingInput
  ): [SettingAggregates!]
}

"""A `Setting` edge in the connection."""
type SettingEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Setting` at the end of the edge."""
  node: Setting!
}

type SettingAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: SettingDistinctCountAggregates
}

type SettingDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt

  """Distinct count of viewMode across the matching connection"""
  viewMode: BigInt

  """Distinct count of billingAccountId across the matching connection"""
  billingAccountId: BigInt

  """Distinct count of organizationId across the matching connection"""
  organizationId: BigInt

  """Distinct count of subscriptionId across the matching connection"""
  subscriptionId: BigInt

  """Distinct count of deletedAt across the matching connection"""
  deletedAt: BigInt

  """Distinct count of deletionReason across the matching connection"""
  deletionReason: BigInt
}

"""Grouping methods for `Setting` for usage during aggregation."""
enum SettingGroupBy {
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
  VIEW_MODE
  BILLING_ACCOUNT_ID
  SUBSCRIPTION_ID
  DELETED_AT
  DELETED_AT_TRUNCATED_TO_HOUR
  DELETED_AT_TRUNCATED_TO_DAY
  DELETION_REASON
}

"""Conditions for `Setting` aggregates."""
input SettingHavingInput {
  AND: [SettingHavingInput!]
  OR: [SettingHavingInput!]
  sum: SettingHavingSumInput
  distinctCount: SettingHavingDistinctCountInput
  min: SettingHavingMinInput
  max: SettingHavingMaxInput
  average: SettingHavingAverageInput
  stddevSample: SettingHavingStddevSampleInput
  stddevPopulation: SettingHavingStddevPopulationInput
  varianceSample: SettingHavingVarianceSampleInput
  variancePopulation: SettingHavingVariancePopulationInput
}

input SettingHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

input SettingHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

input SettingHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

input SettingHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

input SettingHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

input SettingHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

input SettingHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

input SettingHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

input SettingHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  deletedAt: HavingDatetimeFilter
}

"""
A condition to be used against `Setting` object types. All fields are tested for equality and combined with a logical and.
"""
input SettingCondition {
  """Checks for equality with the objects `rowId` field."""
  rowId: UUID

  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the objects `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the objects `viewMode` field."""
  viewMode: String

  """Checks for equality with the objects `billingAccountId` field."""
  billingAccountId: String

  """Checks for equality with the objects `organizationId` field."""
  organizationId: String

  """Checks for equality with the objects `subscriptionId` field."""
  subscriptionId: String

  """Checks for equality with the objects `deletedAt` field."""
  deletedAt: Datetime

  """Checks for equality with the objects `deletionReason` field."""
  deletionReason: String
}

"""
A filter to be used against `Setting` object types. All fields are combined with a logical and.
"""
input SettingFilter {
  """Filter by the objects `rowId` field."""
  rowId: UUIDFilter

  """Filter by the objects `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the objects `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects `viewMode` field."""
  viewMode: StringFilter

  """Filter by the objects `billingAccountId` field."""
  billingAccountId: StringFilter

  """Filter by the objects `organizationId` field."""
  organizationId: StringFilter

  """Filter by the objects `subscriptionId` field."""
  subscriptionId: StringFilter

  """Filter by the objects `deletedAt` field."""
  deletedAt: DatetimeFilter

  """Filter by the objects `deletionReason` field."""
  deletionReason: StringFilter

  """Checks for all expressions in this list."""
  and: [SettingFilter!]

  """Checks for any expressions in this list."""
  or: [SettingFilter!]

  """Negates the expression."""
  not: SettingFilter
}

"""Methods to use when ordering `Setting`."""
enum SettingOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  VIEW_MODE_ASC
  VIEW_MODE_DESC
  BILLING_ACCOUNT_ID_ASC
  BILLING_ACCOUNT_ID_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  SUBSCRIPTION_ID_ASC
  SUBSCRIPTION_ID_DESC
  DELETED_AT_ASC
  DELETED_AT_DESC
  DELETION_REASON_ASC
  DELETION_REASON_DESC
}

"""A connection to a list of `AgentConfig` values."""
type AgentConfigConnection {
  """A list of `AgentConfig` objects."""
  nodes: [AgentConfig!]!

  """
  A list of edges which contains the `AgentConfig` and cursor to aid in pagination.
  """
  edges: [AgentConfigEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `AgentConfig` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: AgentConfigAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping `AgentConfig` for these aggregates."""
    groupBy: [AgentConfigGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: AgentConfigHavingInput
  ): [AgentConfigAggregates!]
}

"""A `AgentConfig` edge in the connection."""
type AgentConfigEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `AgentConfig` at the end of the edge."""
  node: AgentConfig!
}

type AgentConfigAggregates {
  keys: [String]

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: AgentConfigSumAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: AgentConfigDistinctCountAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: AgentConfigMinAggregates

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: AgentConfigMaxAggregates

  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: AgentConfigAverageAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: AgentConfigStddevSampleAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: AgentConfigStddevPopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: AgentConfigVarianceSampleAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: AgentConfigVariancePopulationAggregates
}

type AgentConfigSumAggregates {
  """Sum of maxIterationsPerRequest across the matching connection"""
  maxIterationsPerRequest: BigInt!
}

type AgentConfigDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of organizationId across the matching connection"""
  organizationId: BigInt

  """Distinct count of model across the matching connection"""
  model: BigInt

  """Distinct count of enabled across the matching connection"""
  enabled: BigInt

  """
  Distinct count of maxIterationsPerRequest across the matching connection
  """
  maxIterationsPerRequest: BigInt

  """
  Distinct count of requireApprovalForDestructive across the matching connection
  """
  requireApprovalForDestructive: BigInt

  """
  Distinct count of requireApprovalForCreate across the matching connection
  """
  requireApprovalForCreate: BigInt

  """Distinct count of customInstructions across the matching connection"""
  customInstructions: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt

  """Distinct count of encryptedApiKey across the matching connection"""
  encryptedApiKey: BigInt

  """Distinct count of defaultPersonaId across the matching connection"""
  defaultPersonaId: BigInt
}

type AgentConfigMinAggregates {
  """Minimum of maxIterationsPerRequest across the matching connection"""
  maxIterationsPerRequest: Int
}

type AgentConfigMaxAggregates {
  """Maximum of maxIterationsPerRequest across the matching connection"""
  maxIterationsPerRequest: Int
}

type AgentConfigAverageAggregates {
  """Mean average of maxIterationsPerRequest across the matching connection"""
  maxIterationsPerRequest: BigFloat
}

type AgentConfigStddevSampleAggregates {
  """
  Sample standard deviation of maxIterationsPerRequest across the matching connection
  """
  maxIterationsPerRequest: BigFloat
}

type AgentConfigStddevPopulationAggregates {
  """
  Population standard deviation of maxIterationsPerRequest across the matching connection
  """
  maxIterationsPerRequest: BigFloat
}

type AgentConfigVarianceSampleAggregates {
  """
  Sample variance of maxIterationsPerRequest across the matching connection
  """
  maxIterationsPerRequest: BigFloat
}

type AgentConfigVariancePopulationAggregates {
  """
  Population variance of maxIterationsPerRequest across the matching connection
  """
  maxIterationsPerRequest: BigFloat
}

"""Grouping methods for `AgentConfig` for usage during aggregation."""
enum AgentConfigGroupBy {
  MODEL
  ENABLED
  MAX_ITERATIONS_PER_REQUEST
  REQUIRE_APPROVAL_FOR_DESTRUCTIVE
  REQUIRE_APPROVAL_FOR_CREATE
  CUSTOM_INSTRUCTIONS
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
  ENCRYPTED_API_KEY
  DEFAULT_PERSONA_ID
}

"""Conditions for `AgentConfig` aggregates."""
input AgentConfigHavingInput {
  AND: [AgentConfigHavingInput!]
  OR: [AgentConfigHavingInput!]
  sum: AgentConfigHavingSumInput
  distinctCount: AgentConfigHavingDistinctCountInput
  min: AgentConfigHavingMinInput
  max: AgentConfigHavingMaxInput
  average: AgentConfigHavingAverageInput
  stddevSample: AgentConfigHavingStddevSampleInput
  stddevPopulation: AgentConfigHavingStddevPopulationInput
  varianceSample: AgentConfigHavingVarianceSampleInput
  variancePopulation: AgentConfigHavingVariancePopulationInput
}

input AgentConfigHavingSumInput {
  maxIterationsPerRequest: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentConfigHavingDistinctCountInput {
  maxIterationsPerRequest: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentConfigHavingMinInput {
  maxIterationsPerRequest: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentConfigHavingMaxInput {
  maxIterationsPerRequest: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentConfigHavingAverageInput {
  maxIterationsPerRequest: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentConfigHavingStddevSampleInput {
  maxIterationsPerRequest: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentConfigHavingStddevPopulationInput {
  maxIterationsPerRequest: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentConfigHavingVarianceSampleInput {
  maxIterationsPerRequest: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input AgentConfigHavingVariancePopulationInput {
  maxIterationsPerRequest: HavingIntFilter
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""
A condition to be used against `AgentConfig` object types. All fields are tested
for equality and combined with a logical and.
"""
input AgentConfigCondition {
  """Checks for equality with the objects `rowId` field."""
  rowId: UUID

  """Checks for equality with the objects `organizationId` field."""
  organizationId: String

  """Checks for equality with the objects `model` field."""
  model: String

  """Checks for equality with the objects `enabled` field."""
  enabled: Boolean

  """Checks for equality with the objects `maxIterationsPerRequest` field."""
  maxIterationsPerRequest: Int

  """
  Checks for equality with the objects `requireApprovalForDestructive` field.
  """
  requireApprovalForDestructive: Boolean

  """
  Checks for equality with the objects `requireApprovalForCreate` field.
  """
  requireApprovalForCreate: Boolean

  """Checks for equality with the objects `customInstructions` field."""
  customInstructions: String

  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the objects `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the objects `encryptedApiKey` field."""
  encryptedApiKey: String

  """Checks for equality with the objects `defaultPersonaId` field."""
  defaultPersonaId: UUID
}

"""
A filter to be used against `AgentConfig` object types. All fields are combined with a logical and.
"""
input AgentConfigFilter {
  """Filter by the objects `rowId` field."""
  rowId: UUIDFilter

  """Filter by the objects `organizationId` field."""
  organizationId: StringFilter

  """Filter by the objects `model` field."""
  model: StringFilter

  """Filter by the objects `enabled` field."""
  enabled: BooleanFilter

  """Filter by the objects `maxIterationsPerRequest` field."""
  maxIterationsPerRequest: IntFilter

  """Filter by the objects `requireApprovalForDestructive` field."""
  requireApprovalForDestructive: BooleanFilter

  """Filter by the objects `requireApprovalForCreate` field."""
  requireApprovalForCreate: BooleanFilter

  """Filter by the objects `customInstructions` field."""
  customInstructions: StringFilter

  """Filter by the objects `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the objects `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects `encryptedApiKey` field."""
  encryptedApiKey: StringFilter

  """Filter by the objects `defaultPersonaId` field."""
  defaultPersonaId: UUIDFilter

  """Checks for all expressions in this list."""
  and: [AgentConfigFilter!]

  """Checks for any expressions in this list."""
  or: [AgentConfigFilter!]

  """Negates the expression."""
  not: AgentConfigFilter
}

"""Methods to use when ordering `AgentConfig`."""
enum AgentConfigOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  MODEL_ASC
  MODEL_DESC
  ENABLED_ASC
  ENABLED_DESC
  MAX_ITERATIONS_PER_REQUEST_ASC
  MAX_ITERATIONS_PER_REQUEST_DESC
  REQUIRE_APPROVAL_FOR_DESTRUCTIVE_ASC
  REQUIRE_APPROVAL_FOR_DESTRUCTIVE_DESC
  REQUIRE_APPROVAL_FOR_CREATE_ASC
  REQUIRE_APPROVAL_FOR_CREATE_DESC
  CUSTOM_INSTRUCTIONS_ASC
  CUSTOM_INSTRUCTIONS_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  ENCRYPTED_API_KEY_ASC
  ENCRYPTED_API_KEY_DESC
  DEFAULT_PERSONA_ID_ASC
  DEFAULT_PERSONA_ID_DESC
}

"""
The root mutation type which contains root level fields which mutate data.
"""
type Mutation {
  """Creates a single `ProjectProjectLabel`."""
  createProjectProjectLabel(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateProjectProjectLabelInput!
  ): CreateProjectProjectLabelPayload

  """Creates a single `TaskLabel`."""
  createTaskLabel(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateTaskLabelInput!
  ): CreateTaskLabelPayload

  """Creates a single `Assignee`."""
  createAssignee(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateAssigneeInput!
  ): CreateAssigneePayload

  """Creates a single `Emoji`."""
  createEmoji(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateEmojiInput!
  ): CreateEmojiPayload

  """Creates a single `User`."""
  createUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateUserInput!
  ): CreateUserPayload

  """Creates a single `Post`."""
  createPost(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreatePostInput!
  ): CreatePostPayload

  """Creates a single `ProjectLabel`."""
  createProjectLabel(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateProjectLabelInput!
  ): CreateProjectLabelPayload

  """Creates a single `Label`."""
  createLabel(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateLabelInput!
  ): CreateLabelPayload

  """Creates a single `Column`."""
  createColumn(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateColumnInput!
  ): CreateColumnPayload

  """Creates a single `AgentPersona`."""
  createAgentPersona(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateAgentPersonaInput!
  ): CreateAgentPersonaPayload

  """Creates a single `ProjectColumn`."""
  createProjectColumn(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateProjectColumnInput!
  ): CreateProjectColumnPayload

  """Creates a single `UserPreference`."""
  createUserPreference(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateUserPreferenceInput!
  ): CreateUserPreferencePayload

  """Creates a single `AgentMarketplaceListing`."""
  createAgentMarketplaceListing(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateAgentMarketplaceListingInput!
  ): CreateAgentMarketplaceListingPayload

  """Creates a single `AgentWebhook`."""
  createAgentWebhook(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateAgentWebhookInput!
  ): CreateAgentWebhookPayload

  """Creates a single `AgentSchedule`."""
  createAgentSchedule(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateAgentScheduleInput!
  ): CreateAgentSchedulePayload

  """Creates a single `AgentSession`."""
  createAgentSession(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateAgentSessionInput!
  ): CreateAgentSessionPayload

  """Creates a single `Setting`."""
  createSetting(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateSettingInput!
  ): CreateSettingPayload

  """Creates a single `Project`."""
  createProject(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateProjectInput!
  ): CreateProjectPayload

  """Creates a single `Task`."""
  createTask(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateTaskInput!
  ): CreateTaskPayload

  """Creates a single `AgentConfig`."""
  createAgentConfig(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateAgentConfigInput!
  ): CreateAgentConfigPayload

  """Creates a single `AgentActivity`."""
  createAgentActivity(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateAgentActivityInput!
  ): CreateAgentActivityPayload

  """Creates a single `UserOrganization`."""
  createUserOrganization(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateUserOrganizationInput!
  ): CreateUserOrganizationPayload

  """
  Updates a single `ProjectProjectLabel` using its globally unique id and a patch.
  """
  updateProjectProjectLabelById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateProjectProjectLabelByIdInput!
  ): UpdateProjectProjectLabelPayload

  """Updates a single `ProjectProjectLabel` using a unique key and a patch."""
  updateProjectProjectLabel(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateProjectProjectLabelInput!
  ): UpdateProjectProjectLabelPayload

  """Updates a single `TaskLabel` using its globally unique id and a patch."""
  updateTaskLabelById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateTaskLabelByIdInput!
  ): UpdateTaskLabelPayload

  """Updates a single `TaskLabel` using a unique key and a patch."""
  updateTaskLabel(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateTaskLabelInput!
  ): UpdateTaskLabelPayload

  """Updates a single `Assignee` using its globally unique id and a patch."""
  updateAssigneeById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateAssigneeByIdInput!
  ): UpdateAssigneePayload

  """Updates a single `Assignee` using a unique key and a patch."""
  updateAssignee(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateAssigneeInput!
  ): UpdateAssigneePayload

  """Updates a single `Emoji` using its globally unique id and a patch."""
  updateEmojiById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateEmojiByIdInput!
  ): UpdateEmojiPayload

  """Updates a single `Emoji` using a unique key and a patch."""
  updateEmoji(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateEmojiInput!
  ): UpdateEmojiPayload

  """Updates a single `User` using its globally unique id and a patch."""
  updateUserById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateUserByIdInput!
  ): UpdateUserPayload

  """Updates a single `User` using a unique key and a patch."""
  updateUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateUserInput!
  ): UpdateUserPayload

  """Updates a single `Post` using its globally unique id and a patch."""
  updatePostById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdatePostByIdInput!
  ): UpdatePostPayload

  """Updates a single `Post` using a unique key and a patch."""
  updatePost(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdatePostInput!
  ): UpdatePostPayload

  """
  Updates a single `ProjectLabel` using its globally unique id and a patch.
  """
  updateProjectLabelById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateProjectLabelByIdInput!
  ): UpdateProjectLabelPayload

  """Updates a single `ProjectLabel` using a unique key and a patch."""
  updateProjectLabel(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateProjectLabelInput!
  ): UpdateProjectLabelPayload

  """Updates a single `Label` using its globally unique id and a patch."""
  updateLabelById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateLabelByIdInput!
  ): UpdateLabelPayload

  """Updates a single `Label` using a unique key and a patch."""
  updateLabel(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateLabelInput!
  ): UpdateLabelPayload

  """Updates a single `Column` using its globally unique id and a patch."""
  updateColumnById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateColumnByIdInput!
  ): UpdateColumnPayload

  """Updates a single `Column` using a unique key and a patch."""
  updateColumn(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateColumnInput!
  ): UpdateColumnPayload

  """
  Updates a single `AgentPersona` using its globally unique id and a patch.
  """
  updateAgentPersonaById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateAgentPersonaByIdInput!
  ): UpdateAgentPersonaPayload

  """Updates a single `AgentPersona` using a unique key and a patch."""
  updateAgentPersona(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateAgentPersonaInput!
  ): UpdateAgentPersonaPayload

  """
  Updates a single `ProjectColumn` using its globally unique id and a patch.
  """
  updateProjectColumnById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateProjectColumnByIdInput!
  ): UpdateProjectColumnPayload

  """Updates a single `ProjectColumn` using a unique key and a patch."""
  updateProjectColumn(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateProjectColumnInput!
  ): UpdateProjectColumnPayload

  """
  Updates a single `UserPreference` using its globally unique id and a patch.
  """
  updateUserPreferenceById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateUserPreferenceByIdInput!
  ): UpdateUserPreferencePayload

  """Updates a single `UserPreference` using a unique key and a patch."""
  updateUserPreference(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateUserPreferenceInput!
  ): UpdateUserPreferencePayload

  """
  Updates a single `AgentMarketplaceListing` using its globally unique id and a patch.
  """
  updateAgentMarketplaceListingById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateAgentMarketplaceListingByIdInput!
  ): UpdateAgentMarketplaceListingPayload

  """
  Updates a single `AgentMarketplaceListing` using a unique key and a patch.
  """
  updateAgentMarketplaceListing(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateAgentMarketplaceListingInput!
  ): UpdateAgentMarketplaceListingPayload

  """
  Updates a single `AgentWebhook` using its globally unique id and a patch.
  """
  updateAgentWebhookById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateAgentWebhookByIdInput!
  ): UpdateAgentWebhookPayload

  """Updates a single `AgentWebhook` using a unique key and a patch."""
  updateAgentWebhook(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateAgentWebhookInput!
  ): UpdateAgentWebhookPayload

  """
  Updates a single `AgentSchedule` using its globally unique id and a patch.
  """
  updateAgentScheduleById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateAgentScheduleByIdInput!
  ): UpdateAgentSchedulePayload

  """Updates a single `AgentSchedule` using a unique key and a patch."""
  updateAgentSchedule(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateAgentScheduleInput!
  ): UpdateAgentSchedulePayload

  """
  Updates a single `AgentSession` using its globally unique id and a patch.
  """
  updateAgentSessionById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateAgentSessionByIdInput!
  ): UpdateAgentSessionPayload

  """Updates a single `AgentSession` using a unique key and a patch."""
  updateAgentSession(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateAgentSessionInput!
  ): UpdateAgentSessionPayload

  """Updates a single `Setting` using its globally unique id and a patch."""
  updateSettingById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateSettingByIdInput!
  ): UpdateSettingPayload

  """Updates a single `Setting` using a unique key and a patch."""
  updateSetting(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateSettingInput!
  ): UpdateSettingPayload

  """Updates a single `Project` using its globally unique id and a patch."""
  updateProjectById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateProjectByIdInput!
  ): UpdateProjectPayload

  """Updates a single `Project` using a unique key and a patch."""
  updateProject(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateProjectInput!
  ): UpdateProjectPayload

  """Updates a single `Task` using its globally unique id and a patch."""
  updateTaskById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateTaskByIdInput!
  ): UpdateTaskPayload

  """Updates a single `Task` using a unique key and a patch."""
  updateTask(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateTaskInput!
  ): UpdateTaskPayload

  """
  Updates a single `AgentConfig` using its globally unique id and a patch.
  """
  updateAgentConfigById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateAgentConfigByIdInput!
  ): UpdateAgentConfigPayload

  """Updates a single `AgentConfig` using a unique key and a patch."""
  updateAgentConfig(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateAgentConfigInput!
  ): UpdateAgentConfigPayload

  """
  Updates a single `AgentActivity` using its globally unique id and a patch.
  """
  updateAgentActivityById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateAgentActivityByIdInput!
  ): UpdateAgentActivityPayload

  """Updates a single `AgentActivity` using a unique key and a patch."""
  updateAgentActivity(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateAgentActivityInput!
  ): UpdateAgentActivityPayload

  """
  Updates a single `UserOrganization` using its globally unique id and a patch.
  """
  updateUserOrganizationById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateUserOrganizationByIdInput!
  ): UpdateUserOrganizationPayload

  """Updates a single `UserOrganization` using a unique key and a patch."""
  updateUserOrganization(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateUserOrganizationInput!
  ): UpdateUserOrganizationPayload

  """Deletes a single `ProjectProjectLabel` using its globally unique id."""
  deleteProjectProjectLabelById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteProjectProjectLabelByIdInput!
  ): DeleteProjectProjectLabelPayload

  """Deletes a single `ProjectProjectLabel` using a unique key."""
  deleteProjectProjectLabel(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteProjectProjectLabelInput!
  ): DeleteProjectProjectLabelPayload

  """Deletes a single `TaskLabel` using its globally unique id."""
  deleteTaskLabelById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteTaskLabelByIdInput!
  ): DeleteTaskLabelPayload

  """Deletes a single `TaskLabel` using a unique key."""
  deleteTaskLabel(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteTaskLabelInput!
  ): DeleteTaskLabelPayload

  """Deletes a single `Assignee` using its globally unique id."""
  deleteAssigneeById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteAssigneeByIdInput!
  ): DeleteAssigneePayload

  """Deletes a single `Assignee` using a unique key."""
  deleteAssignee(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteAssigneeInput!
  ): DeleteAssigneePayload

  """Deletes a single `Emoji` using its globally unique id."""
  deleteEmojiById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteEmojiByIdInput!
  ): DeleteEmojiPayload

  """Deletes a single `Emoji` using a unique key."""
  deleteEmoji(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteEmojiInput!
  ): DeleteEmojiPayload

  """Deletes a single `User` using its globally unique id."""
  deleteUserById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteUserByIdInput!
  ): DeleteUserPayload

  """Deletes a single `User` using a unique key."""
  deleteUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteUserInput!
  ): DeleteUserPayload

  """Deletes a single `Post` using its globally unique id."""
  deletePostById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeletePostByIdInput!
  ): DeletePostPayload

  """Deletes a single `Post` using a unique key."""
  deletePost(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeletePostInput!
  ): DeletePostPayload

  """Deletes a single `ProjectLabel` using its globally unique id."""
  deleteProjectLabelById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteProjectLabelByIdInput!
  ): DeleteProjectLabelPayload

  """Deletes a single `ProjectLabel` using a unique key."""
  deleteProjectLabel(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteProjectLabelInput!
  ): DeleteProjectLabelPayload

  """Deletes a single `Label` using its globally unique id."""
  deleteLabelById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteLabelByIdInput!
  ): DeleteLabelPayload

  """Deletes a single `Label` using a unique key."""
  deleteLabel(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteLabelInput!
  ): DeleteLabelPayload

  """Deletes a single `Column` using its globally unique id."""
  deleteColumnById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteColumnByIdInput!
  ): DeleteColumnPayload

  """Deletes a single `Column` using a unique key."""
  deleteColumn(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteColumnInput!
  ): DeleteColumnPayload

  """Deletes a single `AgentPersona` using its globally unique id."""
  deleteAgentPersonaById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteAgentPersonaByIdInput!
  ): DeleteAgentPersonaPayload

  """Deletes a single `AgentPersona` using a unique key."""
  deleteAgentPersona(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteAgentPersonaInput!
  ): DeleteAgentPersonaPayload

  """Deletes a single `ProjectColumn` using its globally unique id."""
  deleteProjectColumnById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteProjectColumnByIdInput!
  ): DeleteProjectColumnPayload

  """Deletes a single `ProjectColumn` using a unique key."""
  deleteProjectColumn(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteProjectColumnInput!
  ): DeleteProjectColumnPayload

  """Deletes a single `UserPreference` using its globally unique id."""
  deleteUserPreferenceById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteUserPreferenceByIdInput!
  ): DeleteUserPreferencePayload

  """Deletes a single `UserPreference` using a unique key."""
  deleteUserPreference(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteUserPreferenceInput!
  ): DeleteUserPreferencePayload

  """
  Deletes a single `AgentMarketplaceListing` using its globally unique id.
  """
  deleteAgentMarketplaceListingById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteAgentMarketplaceListingByIdInput!
  ): DeleteAgentMarketplaceListingPayload

  """Deletes a single `AgentMarketplaceListing` using a unique key."""
  deleteAgentMarketplaceListing(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteAgentMarketplaceListingInput!
  ): DeleteAgentMarketplaceListingPayload

  """Deletes a single `AgentWebhook` using its globally unique id."""
  deleteAgentWebhookById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteAgentWebhookByIdInput!
  ): DeleteAgentWebhookPayload

  """Deletes a single `AgentWebhook` using a unique key."""
  deleteAgentWebhook(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteAgentWebhookInput!
  ): DeleteAgentWebhookPayload

  """Deletes a single `AgentSchedule` using its globally unique id."""
  deleteAgentScheduleById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteAgentScheduleByIdInput!
  ): DeleteAgentSchedulePayload

  """Deletes a single `AgentSchedule` using a unique key."""
  deleteAgentSchedule(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteAgentScheduleInput!
  ): DeleteAgentSchedulePayload

  """Deletes a single `AgentSession` using its globally unique id."""
  deleteAgentSessionById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteAgentSessionByIdInput!
  ): DeleteAgentSessionPayload

  """Deletes a single `AgentSession` using a unique key."""
  deleteAgentSession(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteAgentSessionInput!
  ): DeleteAgentSessionPayload

  """Deletes a single `Setting` using its globally unique id."""
  deleteSettingById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteSettingByIdInput!
  ): DeleteSettingPayload

  """Deletes a single `Setting` using a unique key."""
  deleteSetting(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteSettingInput!
  ): DeleteSettingPayload

  """Deletes a single `Project` using its globally unique id."""
  deleteProjectById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteProjectByIdInput!
  ): DeleteProjectPayload

  """Deletes a single `Project` using a unique key."""
  deleteProject(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteProjectInput!
  ): DeleteProjectPayload

  """Deletes a single `Task` using its globally unique id."""
  deleteTaskById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteTaskByIdInput!
  ): DeleteTaskPayload

  """Deletes a single `Task` using a unique key."""
  deleteTask(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteTaskInput!
  ): DeleteTaskPayload

  """Deletes a single `AgentConfig` using its globally unique id."""
  deleteAgentConfigById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteAgentConfigByIdInput!
  ): DeleteAgentConfigPayload

  """Deletes a single `AgentConfig` using a unique key."""
  deleteAgentConfig(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteAgentConfigInput!
  ): DeleteAgentConfigPayload

  """Deletes a single `AgentActivity` using its globally unique id."""
  deleteAgentActivityById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteAgentActivityByIdInput!
  ): DeleteAgentActivityPayload

  """Deletes a single `AgentActivity` using a unique key."""
  deleteAgentActivity(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteAgentActivityInput!
  ): DeleteAgentActivityPayload

  """Deletes a single `UserOrganization` using its globally unique id."""
  deleteUserOrganizationById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteUserOrganizationByIdInput!
  ): DeleteUserOrganizationPayload

  """Deletes a single `UserOrganization` using a unique key."""
  deleteUserOrganization(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteUserOrganizationInput!
  ): DeleteUserOrganizationPayload
}

"""The output of our create `ProjectProjectLabel` mutation."""
type CreateProjectProjectLabelPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ProjectProjectLabel` that was created by this mutation."""
  projectProjectLabel: ProjectProjectLabel

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `ProjectProjectLabel`. May be used by Relay 1."""
  projectProjectLabelEdge(
    """The method to use when ordering `ProjectProjectLabel`."""
    orderBy: [ProjectProjectLabelOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ProjectProjectLabelEdge
}

"""All input for the create `ProjectProjectLabel` mutation."""
input CreateProjectProjectLabelInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `ProjectProjectLabel` to be created by this mutation."""
  projectProjectLabel: ProjectProjectLabelInput!
}

"""An input for mutations affecting `ProjectProjectLabel`"""
input ProjectProjectLabelInput {
  projectId: UUID!
  projectLabelId: UUID!
  createdAt: Datetime
}

"""The output of our create `TaskLabel` mutation."""
type CreateTaskLabelPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TaskLabel` that was created by this mutation."""
  taskLabel: TaskLabel

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `TaskLabel`. May be used by Relay 1."""
  taskLabelEdge(
    """The method to use when ordering `TaskLabel`."""
    orderBy: [TaskLabelOrderBy!]! = [PRIMARY_KEY_ASC]
  ): TaskLabelEdge
}

"""All input for the create `TaskLabel` mutation."""
input CreateTaskLabelInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `TaskLabel` to be created by this mutation."""
  taskLabel: TaskLabelInput!
}

"""An input for mutations affecting `TaskLabel`"""
input TaskLabelInput {
  taskId: UUID!
  labelId: UUID!
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create `Assignee` mutation."""
type CreateAssigneePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Assignee` that was created by this mutation."""
  assignee: Assignee

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Assignee`. May be used by Relay 1."""
  assigneeEdge(
    """The method to use when ordering `Assignee`."""
    orderBy: [AssigneeOrderBy!]! = [PRIMARY_KEY_ASC]
  ): AssigneeEdge
}

"""All input for the create `Assignee` mutation."""
input CreateAssigneeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Assignee` to be created by this mutation."""
  assignee: AssigneeInput!
}

"""An input for mutations affecting `Assignee`"""
input AssigneeInput {
  userId: UUID!
  taskId: UUID!
  createdAt: Datetime
  updatedAt: Datetime
  deletedAt: Datetime
}

"""The output of our create `Emoji` mutation."""
type CreateEmojiPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Emoji` that was created by this mutation."""
  emoji: Emoji

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Emoji`. May be used by Relay 1."""
  emojiEdge(
    """The method to use when ordering `Emoji`."""
    orderBy: [EmojiOrderBy!]! = [PRIMARY_KEY_ASC]
  ): EmojiEdge
}

"""All input for the create `Emoji` mutation."""
input CreateEmojiInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Emoji` to be created by this mutation."""
  emoji: EmojiInput!
}

"""An input for mutations affecting `Emoji`"""
input EmojiInput {
  rowId: UUID
  emoji: String
  postId: UUID!
  userId: UUID!
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create `User` mutation."""
type CreateUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was created by this mutation."""
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UserOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UserEdge
}

"""All input for the create `User` mutation."""
input CreateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `User` to be created by this mutation."""
  user: UserInput!
}

"""An input for mutations affecting `User`"""
input UserInput {
  rowId: UUID
  identityProviderId: UUID!
  name: String!
  avatarUrl: String
  createdAt: Datetime
  updatedAt: Datetime
  email: String!
}

"""The output of our create `Post` mutation."""
type CreatePostPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Post` that was created by this mutation."""
  post: Post

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Post`. May be used by Relay 1."""
  postEdge(
    """The method to use when ordering `Post`."""
    orderBy: [PostOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PostEdge
}

"""All input for the create `Post` mutation."""
input CreatePostInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Post` to be created by this mutation."""
  post: PostInput!
}

"""An input for mutations affecting `Post`"""
input PostInput {
  rowId: UUID
  title: String
  description: String
  authorId: UUID
  taskId: UUID!
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create `ProjectLabel` mutation."""
type CreateProjectLabelPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ProjectLabel` that was created by this mutation."""
  projectLabel: ProjectLabel

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `ProjectLabel`. May be used by Relay 1."""
  projectLabelEdge(
    """The method to use when ordering `ProjectLabel`."""
    orderBy: [ProjectLabelOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ProjectLabelEdge
}

"""All input for the create `ProjectLabel` mutation."""
input CreateProjectLabelInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `ProjectLabel` to be created by this mutation."""
  projectLabel: ProjectLabelInput!
}

"""An input for mutations affecting `ProjectLabel`"""
input ProjectLabelInput {
  rowId: UUID
  name: String!
  color: String!
  icon: String
  organizationId: String!
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create `Label` mutation."""
type CreateLabelPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Label` that was created by this mutation."""
  label: Label

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Label`. May be used by Relay 1."""
  labelEdge(
    """The method to use when ordering `Label`."""
    orderBy: [LabelOrderBy!]! = [PRIMARY_KEY_ASC]
  ): LabelEdge
}

"""All input for the create `Label` mutation."""
input CreateLabelInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Label` to be created by this mutation."""
  label: LabelInput!
}

"""An input for mutations affecting `Label`"""
input LabelInput {
  rowId: UUID
  name: String!
  color: String!
  projectId: UUID
  createdAt: Datetime
  updatedAt: Datetime
  icon: String
  organizationId: String
}

"""The output of our create `Column` mutation."""
type CreateColumnPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Column` that was created by this mutation."""
  column: Column

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Column`. May be used by Relay 1."""
  columnEdge(
    """The method to use when ordering `Column`."""
    orderBy: [ColumnOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ColumnEdge
}

"""All input for the create `Column` mutation."""
input CreateColumnInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Column` to be created by this mutation."""
  column: ColumnInput!
}

"""An input for mutations affecting `Column`"""
input ColumnInput {
  rowId: UUID
  title: String!
  projectId: UUID!
  createdAt: Datetime
  updatedAt: Datetime
  index: Int
  icon: String
}

"""The output of our create `AgentPersona` mutation."""
type CreateAgentPersonaPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AgentPersona` that was created by this mutation."""
  agentPersona: AgentPersona

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `AgentPersona`. May be used by Relay 1."""
  agentPersonaEdge(
    """The method to use when ordering `AgentPersona`."""
    orderBy: [AgentPersonaOrderBy!]! = [PRIMARY_KEY_ASC]
  ): AgentPersonaEdge
}

"""All input for the create `AgentPersona` mutation."""
input CreateAgentPersonaInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `AgentPersona` to be created by this mutation."""
  agentPersona: AgentPersonaInput!
}

"""An input for mutations affecting `AgentPersona`"""
input AgentPersonaInput {
  rowId: UUID
  organizationId: String!
  name: String!
  description: String
  systemPrompt: String!
  icon: String
  enabled: Boolean
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create `ProjectColumn` mutation."""
type CreateProjectColumnPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ProjectColumn` that was created by this mutation."""
  projectColumn: ProjectColumn

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `ProjectColumn`. May be used by Relay 1."""
  projectColumnEdge(
    """The method to use when ordering `ProjectColumn`."""
    orderBy: [ProjectColumnOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ProjectColumnEdge
}

"""All input for the create `ProjectColumn` mutation."""
input CreateProjectColumnInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `ProjectColumn` to be created by this mutation."""
  projectColumn: ProjectColumnInput!
}

"""An input for mutations affecting `ProjectColumn`"""
input ProjectColumnInput {
  rowId: UUID
  icon: String
  title: String!
  organizationId: String!
  index: Int
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create `UserPreference` mutation."""
type CreateUserPreferencePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserPreference` that was created by this mutation."""
  userPreference: UserPreference

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `UserPreference`. May be used by Relay 1."""
  userPreferenceEdge(
    """The method to use when ordering `UserPreference`."""
    orderBy: [UserPreferenceOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UserPreferenceEdge
}

"""All input for the create `UserPreference` mutation."""
input CreateUserPreferenceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `UserPreference` to be created by this mutation."""
  userPreference: UserPreferenceInput!
}

"""An input for mutations affecting `UserPreference`"""
input UserPreferenceInput {
  rowId: UUID
  userId: UUID!
  projectId: UUID!
  hiddenColumnIds: [String]
  createdAt: Datetime
  updatedAt: Datetime
  viewMode: String
  color: String
}

"""The output of our create `AgentMarketplaceListing` mutation."""
type CreateAgentMarketplaceListingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AgentMarketplaceListing` that was created by this mutation."""
  agentMarketplaceListing: AgentMarketplaceListing

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `AgentMarketplaceListing`. May be used by Relay 1."""
  agentMarketplaceListingEdge(
    """The method to use when ordering `AgentMarketplaceListing`."""
    orderBy: [AgentMarketplaceListingOrderBy!]! = [PRIMARY_KEY_ASC]
  ): AgentMarketplaceListingEdge
}

"""All input for the create `AgentMarketplaceListing` mutation."""
input CreateAgentMarketplaceListingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `AgentMarketplaceListing` to be created by this mutation."""
  agentMarketplaceListing: AgentMarketplaceListingInput!
}

"""An input for mutations affecting `AgentMarketplaceListing`"""
input AgentMarketplaceListingInput {
  rowId: UUID
  personaId: UUID!
  organizationId: String!
  title: String!
  description: String
  category: String!
  installCount: Int
  publishedAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create `AgentWebhook` mutation."""
type CreateAgentWebhookPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AgentWebhook` that was created by this mutation."""
  agentWebhook: AgentWebhook

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `AgentWebhook`. May be used by Relay 1."""
  agentWebhookEdge(
    """The method to use when ordering `AgentWebhook`."""
    orderBy: [AgentWebhookOrderBy!]! = [PRIMARY_KEY_ASC]
  ): AgentWebhookEdge
}

"""All input for the create `AgentWebhook` mutation."""
input CreateAgentWebhookInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `AgentWebhook` to be created by this mutation."""
  agentWebhook: AgentWebhookInput!
}

"""An input for mutations affecting `AgentWebhook`"""
input AgentWebhookInput {
  rowId: UUID
  organizationId: String!
  projectId: UUID!
  name: String!
  eventType: String!
  instructionTemplate: String!
  signingSecret: String!
  enabled: Boolean
  lastTriggeredAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create `AgentSchedule` mutation."""
type CreateAgentSchedulePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AgentSchedule` that was created by this mutation."""
  agentSchedule: AgentSchedule

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `AgentSchedule`. May be used by Relay 1."""
  agentScheduleEdge(
    """The method to use when ordering `AgentSchedule`."""
    orderBy: [AgentScheduleOrderBy!]! = [PRIMARY_KEY_ASC]
  ): AgentScheduleEdge
}

"""All input for the create `AgentSchedule` mutation."""
input CreateAgentScheduleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `AgentSchedule` to be created by this mutation."""
  agentSchedule: AgentScheduleInput!
}

"""An input for mutations affecting `AgentSchedule`"""
input AgentScheduleInput {
  rowId: UUID
  organizationId: String!
  projectId: UUID!
  name: String!
  cronExpression: String!
  instruction: String!
  personaId: UUID
  enabled: Boolean
  lastRunAt: Datetime
  nextRunAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create `AgentSession` mutation."""
type CreateAgentSessionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AgentSession` that was created by this mutation."""
  agentSession: AgentSession

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `AgentSession`. May be used by Relay 1."""
  agentSessionEdge(
    """The method to use when ordering `AgentSession`."""
    orderBy: [AgentSessionOrderBy!]! = [PRIMARY_KEY_ASC]
  ): AgentSessionEdge
}

"""All input for the create `AgentSession` mutation."""
input CreateAgentSessionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `AgentSession` to be created by this mutation."""
  agentSession: AgentSessionInput!
}

"""An input for mutations affecting `AgentSession`"""
input AgentSessionInput {
  rowId: UUID
  organizationId: String!
  projectId: UUID
  userId: UUID!
  title: String
  messages: JSON
  totalTokensUsed: Int
  toolCallCount: Int
  createdAt: Datetime
  updatedAt: Datetime
  type: String
}

"""The output of our create `Setting` mutation."""
type CreateSettingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Setting` that was created by this mutation."""
  setting: Setting

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Setting`. May be used by Relay 1."""
  settingEdge(
    """The method to use when ordering `Setting`."""
    orderBy: [SettingOrderBy!]! = [PRIMARY_KEY_ASC]
  ): SettingEdge
}

"""All input for the create `Setting` mutation."""
input CreateSettingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Setting` to be created by this mutation."""
  setting: SettingInput!
}

"""An input for mutations affecting `Setting`"""
input SettingInput {
  rowId: UUID
  createdAt: Datetime
  updatedAt: Datetime
  viewMode: String
  billingAccountId: String
  organizationId: String!
  subscriptionId: String
  deletedAt: Datetime
  deletionReason: String
}

"""The output of our create `Project` mutation."""
type CreateProjectPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Project` that was created by this mutation."""
  project: Project

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Project`. May be used by Relay 1."""
  projectEdge(
    """The method to use when ordering `Project`."""
    orderBy: [ProjectOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ProjectEdge
}

"""All input for the create `Project` mutation."""
input CreateProjectInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Project` to be created by this mutation."""
  project: ProjectInput!
}

"""An input for mutations affecting `Project`"""
input ProjectInput {
  rowId: UUID
  name: String!
  description: String
  prefix: String
  organizationId: String!
  createdAt: Datetime
  updatedAt: Datetime
  projectColumnId: UUID!
  slug: String!
  columnIndex: Int
  isPublic: Boolean
  nextTaskNumber: Int
}

"""The output of our create `Task` mutation."""
type CreateTaskPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Task` that was created by this mutation."""
  task: Task

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Task`. May be used by Relay 1."""
  taskEdge(
    """The method to use when ordering `Task`."""
    orderBy: [TaskOrderBy!]! = [PRIMARY_KEY_ASC]
  ): TaskEdge
}

"""All input for the create `Task` mutation."""
input CreateTaskInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Task` to be created by this mutation."""
  task: TaskInput!
}

"""An input for mutations affecting `Task`"""
input TaskInput {
  rowId: UUID
  content: String!
  description: String!
  priority: String
  authorId: UUID
  columnId: UUID!
  dueDate: Datetime
  createdAt: Datetime
  updatedAt: Datetime
  columnIndex: Int
  projectId: UUID!
  number: Int
}

"""The output of our create `AgentConfig` mutation."""
type CreateAgentConfigPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AgentConfig` that was created by this mutation."""
  agentConfig: AgentConfig

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `AgentConfig`. May be used by Relay 1."""
  agentConfigEdge(
    """The method to use when ordering `AgentConfig`."""
    orderBy: [AgentConfigOrderBy!]! = [PRIMARY_KEY_ASC]
  ): AgentConfigEdge
}

"""All input for the create `AgentConfig` mutation."""
input CreateAgentConfigInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `AgentConfig` to be created by this mutation."""
  agentConfig: AgentConfigInput!
}

"""An input for mutations affecting `AgentConfig`"""
input AgentConfigInput {
  rowId: UUID
  organizationId: String!
  model: String
  enabled: Boolean
  maxIterationsPerRequest: Int
  requireApprovalForDestructive: Boolean
  requireApprovalForCreate: Boolean
  customInstructions: String
  createdAt: Datetime
  updatedAt: Datetime
  encryptedApiKey: String
  defaultPersonaId: UUID
}

"""The output of our create `AgentActivity` mutation."""
type CreateAgentActivityPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AgentActivity` that was created by this mutation."""
  agentActivity: AgentActivity

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `AgentActivity`. May be used by Relay 1."""
  agentActivityEdge(
    """The method to use when ordering `AgentActivity`."""
    orderBy: [AgentActivityOrderBy!]! = [PRIMARY_KEY_ASC]
  ): AgentActivityEdge
}

"""All input for the create `AgentActivity` mutation."""
input CreateAgentActivityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `AgentActivity` to be created by this mutation."""
  agentActivity: AgentActivityInput!
}

"""An input for mutations affecting `AgentActivity`"""
input AgentActivityInput {
  rowId: UUID
  organizationId: String!
  projectId: UUID!
  sessionId: UUID!
  userId: UUID!
  toolName: String!
  toolInput: JSON!
  toolOutput: JSON
  requiresApproval: Boolean
  approvalStatus: String
  status: String
  errorMessage: String
  affectedTaskIds: JSON
  createdAt: Datetime
  snapshotBefore: JSON
}

"""The output of our create `UserOrganization` mutation."""
type CreateUserOrganizationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserOrganization` that was created by this mutation."""
  userOrganization: UserOrganization

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `UserOrganization`. May be used by Relay 1."""
  userOrganizationEdge(
    """The method to use when ordering `UserOrganization`."""
    orderBy: [UserOrganizationOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UserOrganizationEdge
}

"""All input for the create `UserOrganization` mutation."""
input CreateUserOrganizationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `UserOrganization` to be created by this mutation."""
  userOrganization: UserOrganizationInput!
}

"""An input for mutations affecting `UserOrganization`"""
input UserOrganizationInput {
  rowId: UUID
  userId: UUID!
  organizationId: String!
  slug: String!
  name: String
  type: OrganizationType
  role: MemberRole
  syncedAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our update `ProjectProjectLabel` mutation."""
type UpdateProjectProjectLabelPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ProjectProjectLabel` that was updated by this mutation."""
  projectProjectLabel: ProjectProjectLabel

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `ProjectProjectLabel`. May be used by Relay 1."""
  projectProjectLabelEdge(
    """The method to use when ordering `ProjectProjectLabel`."""
    orderBy: [ProjectProjectLabelOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ProjectProjectLabelEdge
}

"""All input for the `updateProjectProjectLabelById` mutation."""
input UpdateProjectProjectLabelByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ProjectProjectLabel` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `ProjectProjectLabel` being updated.
  """
  patch: ProjectProjectLabelPatch!
}

"""
Represents an update to a `ProjectProjectLabel`. Fields that are set will be updated.
"""
input ProjectProjectLabelPatch {
  projectId: UUID
  projectLabelId: UUID
  createdAt: Datetime
}

"""All input for the `updateProjectProjectLabel` mutation."""
input UpdateProjectProjectLabelInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  projectId: UUID!
  projectLabelId: UUID!

  """
  An object where the defined keys will be set on the `ProjectProjectLabel` being updated.
  """
  patch: ProjectProjectLabelPatch!
}

"""The output of our update `TaskLabel` mutation."""
type UpdateTaskLabelPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TaskLabel` that was updated by this mutation."""
  taskLabel: TaskLabel

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `TaskLabel`. May be used by Relay 1."""
  taskLabelEdge(
    """The method to use when ordering `TaskLabel`."""
    orderBy: [TaskLabelOrderBy!]! = [PRIMARY_KEY_ASC]
  ): TaskLabelEdge
}

"""All input for the `updateTaskLabelById` mutation."""
input UpdateTaskLabelByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `TaskLabel` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `TaskLabel` being updated.
  """
  patch: TaskLabelPatch!
}

"""
Represents an update to a `TaskLabel`. Fields that are set will be updated.
"""
input TaskLabelPatch {
  taskId: UUID
  labelId: UUID
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updateTaskLabel` mutation."""
input UpdateTaskLabelInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  taskId: UUID!
  labelId: UUID!

  """
  An object where the defined keys will be set on the `TaskLabel` being updated.
  """
  patch: TaskLabelPatch!
}

"""The output of our update `Assignee` mutation."""
type UpdateAssigneePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Assignee` that was updated by this mutation."""
  assignee: Assignee

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Assignee`. May be used by Relay 1."""
  assigneeEdge(
    """The method to use when ordering `Assignee`."""
    orderBy: [AssigneeOrderBy!]! = [PRIMARY_KEY_ASC]
  ): AssigneeEdge
}

"""All input for the `updateAssigneeById` mutation."""
input UpdateAssigneeByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Assignee` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `Assignee` being updated.
  """
  patch: AssigneePatch!
}

"""
Represents an update to a `Assignee`. Fields that are set will be updated.
"""
input AssigneePatch {
  userId: UUID
  taskId: UUID
  createdAt: Datetime
  updatedAt: Datetime
  deletedAt: Datetime
}

"""All input for the `updateAssignee` mutation."""
input UpdateAssigneeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  taskId: UUID!
  userId: UUID!

  """
  An object where the defined keys will be set on the `Assignee` being updated.
  """
  patch: AssigneePatch!
}

"""The output of our update `Emoji` mutation."""
type UpdateEmojiPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Emoji` that was updated by this mutation."""
  emoji: Emoji

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Emoji`. May be used by Relay 1."""
  emojiEdge(
    """The method to use when ordering `Emoji`."""
    orderBy: [EmojiOrderBy!]! = [PRIMARY_KEY_ASC]
  ): EmojiEdge
}

"""All input for the `updateEmojiById` mutation."""
input UpdateEmojiByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Emoji` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `Emoji` being updated.
  """
  patch: EmojiPatch!
}

"""
Represents an update to a `Emoji`. Fields that are set will be updated.
"""
input EmojiPatch {
  rowId: UUID
  emoji: String
  postId: UUID
  userId: UUID
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updateEmoji` mutation."""
input UpdateEmojiInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the `Emoji` being updated.
  """
  patch: EmojiPatch!
}

"""The output of our update `User` mutation."""
type UpdateUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was updated by this mutation."""
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UserOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UserEdge
}

"""All input for the `updateUserById` mutation."""
input UpdateUserByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `User` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `User` being updated.
  """
  patch: UserPatch!
}

"""Represents an update to a `User`. Fields that are set will be updated."""
input UserPatch {
  rowId: UUID
  identityProviderId: UUID
  name: String
  avatarUrl: String
  createdAt: Datetime
  updatedAt: Datetime
  email: String
}

"""All input for the `updateUser` mutation."""
input UpdateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the `User` being updated.
  """
  patch: UserPatch!
}

"""The output of our update `Post` mutation."""
type UpdatePostPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Post` that was updated by this mutation."""
  post: Post

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Post`. May be used by Relay 1."""
  postEdge(
    """The method to use when ordering `Post`."""
    orderBy: [PostOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PostEdge
}

"""All input for the `updatePostById` mutation."""
input UpdatePostByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Post` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `Post` being updated.
  """
  patch: PostPatch!
}

"""Represents an update to a `Post`. Fields that are set will be updated."""
input PostPatch {
  rowId: UUID
  title: String
  description: String
  authorId: UUID
  taskId: UUID
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updatePost` mutation."""
input UpdatePostInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the `Post` being updated.
  """
  patch: PostPatch!
}

"""The output of our update `ProjectLabel` mutation."""
type UpdateProjectLabelPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ProjectLabel` that was updated by this mutation."""
  projectLabel: ProjectLabel

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `ProjectLabel`. May be used by Relay 1."""
  projectLabelEdge(
    """The method to use when ordering `ProjectLabel`."""
    orderBy: [ProjectLabelOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ProjectLabelEdge
}

"""All input for the `updateProjectLabelById` mutation."""
input UpdateProjectLabelByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ProjectLabel` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `ProjectLabel` being updated.
  """
  patch: ProjectLabelPatch!
}

"""
Represents an update to a `ProjectLabel`. Fields that are set will be updated.
"""
input ProjectLabelPatch {
  rowId: UUID
  name: String
  color: String
  icon: String
  organizationId: String
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updateProjectLabel` mutation."""
input UpdateProjectLabelInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the `ProjectLabel` being updated.
  """
  patch: ProjectLabelPatch!
}

"""The output of our update `Label` mutation."""
type UpdateLabelPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Label` that was updated by this mutation."""
  label: Label

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Label`. May be used by Relay 1."""
  labelEdge(
    """The method to use when ordering `Label`."""
    orderBy: [LabelOrderBy!]! = [PRIMARY_KEY_ASC]
  ): LabelEdge
}

"""All input for the `updateLabelById` mutation."""
input UpdateLabelByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Label` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `Label` being updated.
  """
  patch: LabelPatch!
}

"""
Represents an update to a `Label`. Fields that are set will be updated.
"""
input LabelPatch {
  rowId: UUID
  name: String
  color: String
  projectId: UUID
  createdAt: Datetime
  updatedAt: Datetime
  icon: String
  organizationId: String
}

"""All input for the `updateLabel` mutation."""
input UpdateLabelInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the `Label` being updated.
  """
  patch: LabelPatch!
}

"""The output of our update `Column` mutation."""
type UpdateColumnPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Column` that was updated by this mutation."""
  column: Column

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Column`. May be used by Relay 1."""
  columnEdge(
    """The method to use when ordering `Column`."""
    orderBy: [ColumnOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ColumnEdge
}

"""All input for the `updateColumnById` mutation."""
input UpdateColumnByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Column` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `Column` being updated.
  """
  patch: ColumnPatch!
}

"""
Represents an update to a `Column`. Fields that are set will be updated.
"""
input ColumnPatch {
  rowId: UUID
  title: String
  projectId: UUID
  createdAt: Datetime
  updatedAt: Datetime
  index: Int
  icon: String
}

"""All input for the `updateColumn` mutation."""
input UpdateColumnInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the `Column` being updated.
  """
  patch: ColumnPatch!
}

"""The output of our update `AgentPersona` mutation."""
type UpdateAgentPersonaPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AgentPersona` that was updated by this mutation."""
  agentPersona: AgentPersona

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `AgentPersona`. May be used by Relay 1."""
  agentPersonaEdge(
    """The method to use when ordering `AgentPersona`."""
    orderBy: [AgentPersonaOrderBy!]! = [PRIMARY_KEY_ASC]
  ): AgentPersonaEdge
}

"""All input for the `updateAgentPersonaById` mutation."""
input UpdateAgentPersonaByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AgentPersona` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `AgentPersona` being updated.
  """
  patch: AgentPersonaPatch!
}

"""
Represents an update to a `AgentPersona`. Fields that are set will be updated.
"""
input AgentPersonaPatch {
  rowId: UUID
  organizationId: String
  name: String
  description: String
  systemPrompt: String
  icon: String
  enabled: Boolean
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updateAgentPersona` mutation."""
input UpdateAgentPersonaInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the `AgentPersona` being updated.
  """
  patch: AgentPersonaPatch!
}

"""The output of our update `ProjectColumn` mutation."""
type UpdateProjectColumnPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ProjectColumn` that was updated by this mutation."""
  projectColumn: ProjectColumn

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `ProjectColumn`. May be used by Relay 1."""
  projectColumnEdge(
    """The method to use when ordering `ProjectColumn`."""
    orderBy: [ProjectColumnOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ProjectColumnEdge
}

"""All input for the `updateProjectColumnById` mutation."""
input UpdateProjectColumnByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ProjectColumn` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `ProjectColumn` being updated.
  """
  patch: ProjectColumnPatch!
}

"""
Represents an update to a `ProjectColumn`. Fields that are set will be updated.
"""
input ProjectColumnPatch {
  rowId: UUID
  icon: String
  title: String
  organizationId: String
  index: Int
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updateProjectColumn` mutation."""
input UpdateProjectColumnInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the `ProjectColumn` being updated.
  """
  patch: ProjectColumnPatch!
}

"""The output of our update `UserPreference` mutation."""
type UpdateUserPreferencePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserPreference` that was updated by this mutation."""
  userPreference: UserPreference

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `UserPreference`. May be used by Relay 1."""
  userPreferenceEdge(
    """The method to use when ordering `UserPreference`."""
    orderBy: [UserPreferenceOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UserPreferenceEdge
}

"""All input for the `updateUserPreferenceById` mutation."""
input UpdateUserPreferenceByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `UserPreference` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `UserPreference` being updated.
  """
  patch: UserPreferencePatch!
}

"""
Represents an update to a `UserPreference`. Fields that are set will be updated.
"""
input UserPreferencePatch {
  rowId: UUID
  userId: UUID
  projectId: UUID
  hiddenColumnIds: [String]
  createdAt: Datetime
  updatedAt: Datetime
  viewMode: String
  color: String
}

"""All input for the `updateUserPreference` mutation."""
input UpdateUserPreferenceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the `UserPreference` being updated.
  """
  patch: UserPreferencePatch!
}

"""The output of our update `AgentMarketplaceListing` mutation."""
type UpdateAgentMarketplaceListingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AgentMarketplaceListing` that was updated by this mutation."""
  agentMarketplaceListing: AgentMarketplaceListing

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `AgentMarketplaceListing`. May be used by Relay 1."""
  agentMarketplaceListingEdge(
    """The method to use when ordering `AgentMarketplaceListing`."""
    orderBy: [AgentMarketplaceListingOrderBy!]! = [PRIMARY_KEY_ASC]
  ): AgentMarketplaceListingEdge
}

"""All input for the `updateAgentMarketplaceListingById` mutation."""
input UpdateAgentMarketplaceListingByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AgentMarketplaceListing` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `AgentMarketplaceListing` being updated.
  """
  patch: AgentMarketplaceListingPatch!
}

"""
Represents an update to a `AgentMarketplaceListing`. Fields that are set will be updated.
"""
input AgentMarketplaceListingPatch {
  rowId: UUID
  personaId: UUID
  organizationId: String
  title: String
  description: String
  category: String
  installCount: Int
  publishedAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updateAgentMarketplaceListing` mutation."""
input UpdateAgentMarketplaceListingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the `AgentMarketplaceListing` being updated.
  """
  patch: AgentMarketplaceListingPatch!
}

"""The output of our update `AgentWebhook` mutation."""
type UpdateAgentWebhookPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AgentWebhook` that was updated by this mutation."""
  agentWebhook: AgentWebhook

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `AgentWebhook`. May be used by Relay 1."""
  agentWebhookEdge(
    """The method to use when ordering `AgentWebhook`."""
    orderBy: [AgentWebhookOrderBy!]! = [PRIMARY_KEY_ASC]
  ): AgentWebhookEdge
}

"""All input for the `updateAgentWebhookById` mutation."""
input UpdateAgentWebhookByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AgentWebhook` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `AgentWebhook` being updated.
  """
  patch: AgentWebhookPatch!
}

"""
Represents an update to a `AgentWebhook`. Fields that are set will be updated.
"""
input AgentWebhookPatch {
  rowId: UUID
  organizationId: String
  projectId: UUID
  name: String
  eventType: String
  instructionTemplate: String
  signingSecret: String
  enabled: Boolean
  lastTriggeredAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updateAgentWebhook` mutation."""
input UpdateAgentWebhookInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the `AgentWebhook` being updated.
  """
  patch: AgentWebhookPatch!
}

"""The output of our update `AgentSchedule` mutation."""
type UpdateAgentSchedulePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AgentSchedule` that was updated by this mutation."""
  agentSchedule: AgentSchedule

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `AgentSchedule`. May be used by Relay 1."""
  agentScheduleEdge(
    """The method to use when ordering `AgentSchedule`."""
    orderBy: [AgentScheduleOrderBy!]! = [PRIMARY_KEY_ASC]
  ): AgentScheduleEdge
}

"""All input for the `updateAgentScheduleById` mutation."""
input UpdateAgentScheduleByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AgentSchedule` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `AgentSchedule` being updated.
  """
  patch: AgentSchedulePatch!
}

"""
Represents an update to a `AgentSchedule`. Fields that are set will be updated.
"""
input AgentSchedulePatch {
  rowId: UUID
  organizationId: String
  projectId: UUID
  name: String
  cronExpression: String
  instruction: String
  personaId: UUID
  enabled: Boolean
  lastRunAt: Datetime
  nextRunAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updateAgentSchedule` mutation."""
input UpdateAgentScheduleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the `AgentSchedule` being updated.
  """
  patch: AgentSchedulePatch!
}

"""The output of our update `AgentSession` mutation."""
type UpdateAgentSessionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AgentSession` that was updated by this mutation."""
  agentSession: AgentSession

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `AgentSession`. May be used by Relay 1."""
  agentSessionEdge(
    """The method to use when ordering `AgentSession`."""
    orderBy: [AgentSessionOrderBy!]! = [PRIMARY_KEY_ASC]
  ): AgentSessionEdge
}

"""All input for the `updateAgentSessionById` mutation."""
input UpdateAgentSessionByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AgentSession` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `AgentSession` being updated.
  """
  patch: AgentSessionPatch!
}

"""
Represents an update to a `AgentSession`. Fields that are set will be updated.
"""
input AgentSessionPatch {
  rowId: UUID
  organizationId: String
  projectId: UUID
  userId: UUID
  title: String
  messages: JSON
  totalTokensUsed: Int
  toolCallCount: Int
  createdAt: Datetime
  updatedAt: Datetime
  type: String
}

"""All input for the `updateAgentSession` mutation."""
input UpdateAgentSessionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the `AgentSession` being updated.
  """
  patch: AgentSessionPatch!
}

"""The output of our update `Setting` mutation."""
type UpdateSettingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Setting` that was updated by this mutation."""
  setting: Setting

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Setting`. May be used by Relay 1."""
  settingEdge(
    """The method to use when ordering `Setting`."""
    orderBy: [SettingOrderBy!]! = [PRIMARY_KEY_ASC]
  ): SettingEdge
}

"""All input for the `updateSettingById` mutation."""
input UpdateSettingByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Setting` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `Setting` being updated.
  """
  patch: SettingPatch!
}

"""
Represents an update to a `Setting`. Fields that are set will be updated.
"""
input SettingPatch {
  rowId: UUID
  createdAt: Datetime
  updatedAt: Datetime
  viewMode: String
  billingAccountId: String
  organizationId: String
  subscriptionId: String
  deletedAt: Datetime
  deletionReason: String
}

"""All input for the `updateSetting` mutation."""
input UpdateSettingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the `Setting` being updated.
  """
  patch: SettingPatch!
}

"""The output of our update `Project` mutation."""
type UpdateProjectPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Project` that was updated by this mutation."""
  project: Project

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Project`. May be used by Relay 1."""
  projectEdge(
    """The method to use when ordering `Project`."""
    orderBy: [ProjectOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ProjectEdge
}

"""All input for the `updateProjectById` mutation."""
input UpdateProjectByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Project` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `Project` being updated.
  """
  patch: ProjectPatch!
}

"""
Represents an update to a `Project`. Fields that are set will be updated.
"""
input ProjectPatch {
  rowId: UUID
  name: String
  description: String
  prefix: String
  organizationId: String
  createdAt: Datetime
  updatedAt: Datetime
  projectColumnId: UUID
  slug: String
  columnIndex: Int
  isPublic: Boolean
  nextTaskNumber: Int
}

"""All input for the `updateProject` mutation."""
input UpdateProjectInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the `Project` being updated.
  """
  patch: ProjectPatch!
}

"""The output of our update `Task` mutation."""
type UpdateTaskPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Task` that was updated by this mutation."""
  task: Task

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Task`. May be used by Relay 1."""
  taskEdge(
    """The method to use when ordering `Task`."""
    orderBy: [TaskOrderBy!]! = [PRIMARY_KEY_ASC]
  ): TaskEdge
}

"""All input for the `updateTaskById` mutation."""
input UpdateTaskByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Task` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `Task` being updated.
  """
  patch: TaskPatch!
}

"""Represents an update to a `Task`. Fields that are set will be updated."""
input TaskPatch {
  rowId: UUID
  content: String
  description: String
  priority: String
  authorId: UUID
  columnId: UUID
  dueDate: Datetime
  createdAt: Datetime
  updatedAt: Datetime
  columnIndex: Int
  projectId: UUID
  number: Int
}

"""All input for the `updateTask` mutation."""
input UpdateTaskInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the `Task` being updated.
  """
  patch: TaskPatch!
}

"""The output of our update `AgentConfig` mutation."""
type UpdateAgentConfigPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AgentConfig` that was updated by this mutation."""
  agentConfig: AgentConfig

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `AgentConfig`. May be used by Relay 1."""
  agentConfigEdge(
    """The method to use when ordering `AgentConfig`."""
    orderBy: [AgentConfigOrderBy!]! = [PRIMARY_KEY_ASC]
  ): AgentConfigEdge
}

"""All input for the `updateAgentConfigById` mutation."""
input UpdateAgentConfigByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AgentConfig` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `AgentConfig` being updated.
  """
  patch: AgentConfigPatch!
}

"""
Represents an update to a `AgentConfig`. Fields that are set will be updated.
"""
input AgentConfigPatch {
  rowId: UUID
  organizationId: String
  model: String
  enabled: Boolean
  maxIterationsPerRequest: Int
  requireApprovalForDestructive: Boolean
  requireApprovalForCreate: Boolean
  customInstructions: String
  createdAt: Datetime
  updatedAt: Datetime
  encryptedApiKey: String
  defaultPersonaId: UUID
}

"""All input for the `updateAgentConfig` mutation."""
input UpdateAgentConfigInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the `AgentConfig` being updated.
  """
  patch: AgentConfigPatch!
}

"""The output of our update `AgentActivity` mutation."""
type UpdateAgentActivityPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AgentActivity` that was updated by this mutation."""
  agentActivity: AgentActivity

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `AgentActivity`. May be used by Relay 1."""
  agentActivityEdge(
    """The method to use when ordering `AgentActivity`."""
    orderBy: [AgentActivityOrderBy!]! = [PRIMARY_KEY_ASC]
  ): AgentActivityEdge
}

"""All input for the `updateAgentActivityById` mutation."""
input UpdateAgentActivityByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AgentActivity` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `AgentActivity` being updated.
  """
  patch: AgentActivityPatch!
}

"""
Represents an update to a `AgentActivity`. Fields that are set will be updated.
"""
input AgentActivityPatch {
  rowId: UUID
  organizationId: String
  projectId: UUID
  sessionId: UUID
  userId: UUID
  toolName: String
  toolInput: JSON
  toolOutput: JSON
  requiresApproval: Boolean
  approvalStatus: String
  status: String
  errorMessage: String
  affectedTaskIds: JSON
  createdAt: Datetime
  snapshotBefore: JSON
}

"""All input for the `updateAgentActivity` mutation."""
input UpdateAgentActivityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the `AgentActivity` being updated.
  """
  patch: AgentActivityPatch!
}

"""The output of our update `UserOrganization` mutation."""
type UpdateUserOrganizationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserOrganization` that was updated by this mutation."""
  userOrganization: UserOrganization

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `UserOrganization`. May be used by Relay 1."""
  userOrganizationEdge(
    """The method to use when ordering `UserOrganization`."""
    orderBy: [UserOrganizationOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UserOrganizationEdge
}

"""All input for the `updateUserOrganizationById` mutation."""
input UpdateUserOrganizationByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `UserOrganization` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `UserOrganization` being updated.
  """
  patch: UserOrganizationPatch!
}

"""
Represents an update to a `UserOrganization`. Fields that are set will be updated.
"""
input UserOrganizationPatch {
  rowId: UUID
  userId: UUID
  organizationId: String
  slug: String
  name: String
  type: OrganizationType
  role: MemberRole
  syncedAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updateUserOrganization` mutation."""
input UpdateUserOrganizationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the `UserOrganization` being updated.
  """
  patch: UserOrganizationPatch!
}

"""The output of our delete `ProjectProjectLabel` mutation."""
type DeleteProjectProjectLabelPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ProjectProjectLabel` that was deleted by this mutation."""
  projectProjectLabel: ProjectProjectLabel
  deletedProjectProjectLabelId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `ProjectProjectLabel`. May be used by Relay 1."""
  projectProjectLabelEdge(
    """The method to use when ordering `ProjectProjectLabel`."""
    orderBy: [ProjectProjectLabelOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ProjectProjectLabelEdge
}

"""All input for the `deleteProjectProjectLabelById` mutation."""
input DeleteProjectProjectLabelByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ProjectProjectLabel` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteProjectProjectLabel` mutation."""
input DeleteProjectProjectLabelInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  projectId: UUID!
  projectLabelId: UUID!
}

"""The output of our delete `TaskLabel` mutation."""
type DeleteTaskLabelPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `TaskLabel` that was deleted by this mutation."""
  taskLabel: TaskLabel
  deletedTaskLabelId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `TaskLabel`. May be used by Relay 1."""
  taskLabelEdge(
    """The method to use when ordering `TaskLabel`."""
    orderBy: [TaskLabelOrderBy!]! = [PRIMARY_KEY_ASC]
  ): TaskLabelEdge
}

"""All input for the `deleteTaskLabelById` mutation."""
input DeleteTaskLabelByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `TaskLabel` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteTaskLabel` mutation."""
input DeleteTaskLabelInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  taskId: UUID!
  labelId: UUID!
}

"""The output of our delete `Assignee` mutation."""
type DeleteAssigneePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Assignee` that was deleted by this mutation."""
  assignee: Assignee
  deletedAssigneeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Assignee`. May be used by Relay 1."""
  assigneeEdge(
    """The method to use when ordering `Assignee`."""
    orderBy: [AssigneeOrderBy!]! = [PRIMARY_KEY_ASC]
  ): AssigneeEdge
}

"""All input for the `deleteAssigneeById` mutation."""
input DeleteAssigneeByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Assignee` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteAssignee` mutation."""
input DeleteAssigneeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  taskId: UUID!
  userId: UUID!
}

"""The output of our delete `Emoji` mutation."""
type DeleteEmojiPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Emoji` that was deleted by this mutation."""
  emoji: Emoji
  deletedEmojiId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Emoji`. May be used by Relay 1."""
  emojiEdge(
    """The method to use when ordering `Emoji`."""
    orderBy: [EmojiOrderBy!]! = [PRIMARY_KEY_ASC]
  ): EmojiEdge
}

"""All input for the `deleteEmojiById` mutation."""
input DeleteEmojiByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Emoji` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteEmoji` mutation."""
input DeleteEmojiInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete `User` mutation."""
type DeleteUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was deleted by this mutation."""
  user: User
  deletedUserId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UserOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UserEdge
}

"""All input for the `deleteUserById` mutation."""
input DeleteUserByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `User` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteUser` mutation."""
input DeleteUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete `Post` mutation."""
type DeletePostPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Post` that was deleted by this mutation."""
  post: Post
  deletedPostId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Post`. May be used by Relay 1."""
  postEdge(
    """The method to use when ordering `Post`."""
    orderBy: [PostOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PostEdge
}

"""All input for the `deletePostById` mutation."""
input DeletePostByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Post` to be deleted.
  """
  id: ID!
}

"""All input for the `deletePost` mutation."""
input DeletePostInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete `ProjectLabel` mutation."""
type DeleteProjectLabelPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ProjectLabel` that was deleted by this mutation."""
  projectLabel: ProjectLabel
  deletedProjectLabelId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `ProjectLabel`. May be used by Relay 1."""
  projectLabelEdge(
    """The method to use when ordering `ProjectLabel`."""
    orderBy: [ProjectLabelOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ProjectLabelEdge
}

"""All input for the `deleteProjectLabelById` mutation."""
input DeleteProjectLabelByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ProjectLabel` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteProjectLabel` mutation."""
input DeleteProjectLabelInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete `Label` mutation."""
type DeleteLabelPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Label` that was deleted by this mutation."""
  label: Label
  deletedLabelId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Label`. May be used by Relay 1."""
  labelEdge(
    """The method to use when ordering `Label`."""
    orderBy: [LabelOrderBy!]! = [PRIMARY_KEY_ASC]
  ): LabelEdge
}

"""All input for the `deleteLabelById` mutation."""
input DeleteLabelByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Label` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteLabel` mutation."""
input DeleteLabelInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete `Column` mutation."""
type DeleteColumnPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Column` that was deleted by this mutation."""
  column: Column
  deletedColumnId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Column`. May be used by Relay 1."""
  columnEdge(
    """The method to use when ordering `Column`."""
    orderBy: [ColumnOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ColumnEdge
}

"""All input for the `deleteColumnById` mutation."""
input DeleteColumnByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Column` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteColumn` mutation."""
input DeleteColumnInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete `AgentPersona` mutation."""
type DeleteAgentPersonaPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AgentPersona` that was deleted by this mutation."""
  agentPersona: AgentPersona
  deletedAgentPersonaId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `AgentPersona`. May be used by Relay 1."""
  agentPersonaEdge(
    """The method to use when ordering `AgentPersona`."""
    orderBy: [AgentPersonaOrderBy!]! = [PRIMARY_KEY_ASC]
  ): AgentPersonaEdge
}

"""All input for the `deleteAgentPersonaById` mutation."""
input DeleteAgentPersonaByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AgentPersona` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteAgentPersona` mutation."""
input DeleteAgentPersonaInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete `ProjectColumn` mutation."""
type DeleteProjectColumnPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ProjectColumn` that was deleted by this mutation."""
  projectColumn: ProjectColumn
  deletedProjectColumnId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `ProjectColumn`. May be used by Relay 1."""
  projectColumnEdge(
    """The method to use when ordering `ProjectColumn`."""
    orderBy: [ProjectColumnOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ProjectColumnEdge
}

"""All input for the `deleteProjectColumnById` mutation."""
input DeleteProjectColumnByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ProjectColumn` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteProjectColumn` mutation."""
input DeleteProjectColumnInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete `UserPreference` mutation."""
type DeleteUserPreferencePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserPreference` that was deleted by this mutation."""
  userPreference: UserPreference
  deletedUserPreferenceId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `UserPreference`. May be used by Relay 1."""
  userPreferenceEdge(
    """The method to use when ordering `UserPreference`."""
    orderBy: [UserPreferenceOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UserPreferenceEdge
}

"""All input for the `deleteUserPreferenceById` mutation."""
input DeleteUserPreferenceByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `UserPreference` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteUserPreference` mutation."""
input DeleteUserPreferenceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete `AgentMarketplaceListing` mutation."""
type DeleteAgentMarketplaceListingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AgentMarketplaceListing` that was deleted by this mutation."""
  agentMarketplaceListing: AgentMarketplaceListing
  deletedAgentMarketplaceListingId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `AgentMarketplaceListing`. May be used by Relay 1."""
  agentMarketplaceListingEdge(
    """The method to use when ordering `AgentMarketplaceListing`."""
    orderBy: [AgentMarketplaceListingOrderBy!]! = [PRIMARY_KEY_ASC]
  ): AgentMarketplaceListingEdge
}

"""All input for the `deleteAgentMarketplaceListingById` mutation."""
input DeleteAgentMarketplaceListingByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AgentMarketplaceListing` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteAgentMarketplaceListing` mutation."""
input DeleteAgentMarketplaceListingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete `AgentWebhook` mutation."""
type DeleteAgentWebhookPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AgentWebhook` that was deleted by this mutation."""
  agentWebhook: AgentWebhook
  deletedAgentWebhookId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `AgentWebhook`. May be used by Relay 1."""
  agentWebhookEdge(
    """The method to use when ordering `AgentWebhook`."""
    orderBy: [AgentWebhookOrderBy!]! = [PRIMARY_KEY_ASC]
  ): AgentWebhookEdge
}

"""All input for the `deleteAgentWebhookById` mutation."""
input DeleteAgentWebhookByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AgentWebhook` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteAgentWebhook` mutation."""
input DeleteAgentWebhookInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete `AgentSchedule` mutation."""
type DeleteAgentSchedulePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AgentSchedule` that was deleted by this mutation."""
  agentSchedule: AgentSchedule
  deletedAgentScheduleId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `AgentSchedule`. May be used by Relay 1."""
  agentScheduleEdge(
    """The method to use when ordering `AgentSchedule`."""
    orderBy: [AgentScheduleOrderBy!]! = [PRIMARY_KEY_ASC]
  ): AgentScheduleEdge
}

"""All input for the `deleteAgentScheduleById` mutation."""
input DeleteAgentScheduleByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AgentSchedule` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteAgentSchedule` mutation."""
input DeleteAgentScheduleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete `AgentSession` mutation."""
type DeleteAgentSessionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AgentSession` that was deleted by this mutation."""
  agentSession: AgentSession
  deletedAgentSessionId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `AgentSession`. May be used by Relay 1."""
  agentSessionEdge(
    """The method to use when ordering `AgentSession`."""
    orderBy: [AgentSessionOrderBy!]! = [PRIMARY_KEY_ASC]
  ): AgentSessionEdge
}

"""All input for the `deleteAgentSessionById` mutation."""
input DeleteAgentSessionByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AgentSession` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteAgentSession` mutation."""
input DeleteAgentSessionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete `Setting` mutation."""
type DeleteSettingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Setting` that was deleted by this mutation."""
  setting: Setting
  deletedSettingId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Setting`. May be used by Relay 1."""
  settingEdge(
    """The method to use when ordering `Setting`."""
    orderBy: [SettingOrderBy!]! = [PRIMARY_KEY_ASC]
  ): SettingEdge
}

"""All input for the `deleteSettingById` mutation."""
input DeleteSettingByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Setting` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteSetting` mutation."""
input DeleteSettingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete `Project` mutation."""
type DeleteProjectPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Project` that was deleted by this mutation."""
  project: Project
  deletedProjectId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Project`. May be used by Relay 1."""
  projectEdge(
    """The method to use when ordering `Project`."""
    orderBy: [ProjectOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ProjectEdge
}

"""All input for the `deleteProjectById` mutation."""
input DeleteProjectByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Project` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteProject` mutation."""
input DeleteProjectInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete `Task` mutation."""
type DeleteTaskPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Task` that was deleted by this mutation."""
  task: Task
  deletedTaskId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Task`. May be used by Relay 1."""
  taskEdge(
    """The method to use when ordering `Task`."""
    orderBy: [TaskOrderBy!]! = [PRIMARY_KEY_ASC]
  ): TaskEdge
}

"""All input for the `deleteTaskById` mutation."""
input DeleteTaskByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Task` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteTask` mutation."""
input DeleteTaskInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete `AgentConfig` mutation."""
type DeleteAgentConfigPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AgentConfig` that was deleted by this mutation."""
  agentConfig: AgentConfig
  deletedAgentConfigId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `AgentConfig`. May be used by Relay 1."""
  agentConfigEdge(
    """The method to use when ordering `AgentConfig`."""
    orderBy: [AgentConfigOrderBy!]! = [PRIMARY_KEY_ASC]
  ): AgentConfigEdge
}

"""All input for the `deleteAgentConfigById` mutation."""
input DeleteAgentConfigByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AgentConfig` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteAgentConfig` mutation."""
input DeleteAgentConfigInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete `AgentActivity` mutation."""
type DeleteAgentActivityPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AgentActivity` that was deleted by this mutation."""
  agentActivity: AgentActivity
  deletedAgentActivityId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `AgentActivity`. May be used by Relay 1."""
  agentActivityEdge(
    """The method to use when ordering `AgentActivity`."""
    orderBy: [AgentActivityOrderBy!]! = [PRIMARY_KEY_ASC]
  ): AgentActivityEdge
}

"""All input for the `deleteAgentActivityById` mutation."""
input DeleteAgentActivityByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AgentActivity` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteAgentActivity` mutation."""
input DeleteAgentActivityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete `UserOrganization` mutation."""
type DeleteUserOrganizationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserOrganization` that was deleted by this mutation."""
  userOrganization: UserOrganization
  deletedUserOrganizationId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `UserOrganization`. May be used by Relay 1."""
  userOrganizationEdge(
    """The method to use when ordering `UserOrganization`."""
    orderBy: [UserOrganizationOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UserOrganizationEdge
}

"""All input for the `deleteUserOrganizationById` mutation."""
input DeleteUserOrganizationByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `UserOrganization` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteUserOrganization` mutation."""
input DeleteUserOrganizationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The currently authenticated user."""
type Observer {
  rowId: UUID!
  identityProviderId: UUID!
  name: String!
  email: String!
}